---
phase: 18-specification-pattern
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/TradingBot.ApiService.csproj
  - TradingBot.ApiService/Application/Specifications/SpecificationExtensions.cs
  - TradingBot.ApiService/Application/Specifications/Purchases/PurchaseFilledStatusSpec.cs
  - TradingBot.ApiService/Application/Specifications/Purchases/PurchaseDateRangeSpec.cs
  - TradingBot.ApiService/Application/Specifications/Purchases/PurchaseTierFilterSpec.cs
  - TradingBot.ApiService/Application/Specifications/Purchases/PurchaseCursorSpec.cs
  - TradingBot.ApiService/Application/Specifications/Purchases/PurchasesOrderedByDateSpec.cs
  - TradingBot.ApiService/Application/Specifications/DailyPrices/DailyPriceByDateRangeSpec.cs
autonomous: true
requirements:
  - QP-01

must_haves:
  truths:
    - "Ardalis.Specification and Ardalis.Specification.EntityFrameworkCore 9.3.1 are installed in ApiService project"
    - "WithSpecification extension method is available on IQueryable<T> returning IQueryable<T>"
    - "Each spec class applies exactly one filter or sort concern (composable, not monolithic)"
    - "Specs handle filtering and sorting only -- no .Select() projection inside specs"
    - "All spec classes compile and inherit from Specification<T>"
  artifacts:
    - path: "TradingBot.ApiService/Application/Specifications/SpecificationExtensions.cs"
      provides: "WithSpecification extension method on IQueryable<T>"
      contains: "WithSpecification"
    - path: "TradingBot.ApiService/Application/Specifications/Purchases/PurchaseFilledStatusSpec.cs"
      provides: "Filter for non-dry-run filled/partially-filled purchases"
      contains: "PurchaseFilledStatusSpec"
    - path: "TradingBot.ApiService/Application/Specifications/Purchases/PurchaseDateRangeSpec.cs"
      provides: "Date range filter for purchases"
      contains: "PurchaseDateRangeSpec"
    - path: "TradingBot.ApiService/Application/Specifications/Purchases/PurchaseTierFilterSpec.cs"
      provides: "Multiplier tier filter for purchases"
      contains: "PurchaseTierFilterSpec"
    - path: "TradingBot.ApiService/Application/Specifications/Purchases/PurchaseCursorSpec.cs"
      provides: "Cursor-based pagination filter with built-in descending sort"
      contains: "PurchaseCursorSpec"
    - path: "TradingBot.ApiService/Application/Specifications/Purchases/PurchasesOrderedByDateSpec.cs"
      provides: "Default descending date sort with AsNoTracking"
      contains: "PurchasesOrderedByDateSpec"
    - path: "TradingBot.ApiService/Application/Specifications/DailyPrices/DailyPriceByDateRangeSpec.cs"
      provides: "Symbol + date range filter with ascending sort for chart data"
      contains: "DailyPriceByDateRangeSpec"
  key_links:
    - from: "TradingBot.ApiService/Application/Specifications/SpecificationExtensions.cs"
      to: "Ardalis.Specification.EntityFrameworkCore"
      via: "SpecificationEvaluator.Default.GetQuery()"
      pattern: "SpecificationEvaluator"
    - from: "TradingBot.ApiService/Application/Specifications/Purchases/*.cs"
      to: "Ardalis.Specification.Specification<Purchase>"
      via: "inheritance"
      pattern: "Specification<Purchase>"
---

<objective>
Install Ardalis.Specification packages, create the WithSpecification IQueryable extension method, and define all composable specification classes for Purchase and DailyPrice entities.

Purpose: Establish the specification infrastructure and all reusable spec building blocks that endpoints and services will compose in Plan 02.
Output: NuGet packages installed, extension method available, 6 Purchase specs + 1 DailyPrice spec ready for use.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-specification-pattern/18-RESEARCH.md

@TradingBot.ApiService/TradingBot.ApiService.csproj
@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/Models/DailyPrice.cs
@TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Ardalis.Specification packages and create WithSpecification extension</name>
  <files>
    TradingBot.ApiService/TradingBot.ApiService.csproj
    TradingBot.ApiService/Application/Specifications/SpecificationExtensions.cs
  </files>
  <action>
1. Add NuGet packages to TradingBot.ApiService.csproj:
   ```bash
   cd TradingBot.ApiService && dotnet add package Ardalis.Specification --version 9.3.1
   cd TradingBot.ApiService && dotnet add package Ardalis.Specification.EntityFrameworkCore --version 9.3.1
   ```

2. Create `Application/Specifications/SpecificationExtensions.cs` with a static extension method:
   - Method signature: `public static IQueryable<T> WithSpecification<T>(this IQueryable<T> source, Specification<T> spec) where T : class`
   - Implementation: use `SpecificationEvaluator.Default.GetQuery(source, spec)` from `Ardalis.Specification.EntityFrameworkCore`
   - This returns `IQueryable<T>` so callers can chain `.Select()`, `.Take()`, `.ToListAsync()` after
   - Import `Ardalis.Specification` and `Ardalis.Specification.EntityFrameworkCore` namespaces
   - Place in namespace `TradingBot.ApiService.Application.Specifications`

NOTE: Ardalis.Specification.EntityFrameworkCore provides its own `WithSpecification` on `DbSet<T>`, but we need it on `IQueryable<T>` too (for chaining multiple specs). The custom extension method wraps `SpecificationEvaluator.Default.GetQuery()` which accepts `IQueryable<T>`.

3. Verify build: `dotnet build TradingBot.sln`
  </action>
  <verify>
    `dotnet build TradingBot.sln` succeeds with no errors. SpecificationExtensions.cs compiles.
  </verify>
  <done>
    Ardalis.Specification 9.3.1 and Ardalis.Specification.EntityFrameworkCore 9.3.1 are in the csproj. WithSpecification extension method on IQueryable<T> exists and compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create all composable specification classes</name>
  <files>
    TradingBot.ApiService/Application/Specifications/Purchases/PurchaseFilledStatusSpec.cs
    TradingBot.ApiService/Application/Specifications/Purchases/PurchaseDateRangeSpec.cs
    TradingBot.ApiService/Application/Specifications/Purchases/PurchaseTierFilterSpec.cs
    TradingBot.ApiService/Application/Specifications/Purchases/PurchaseCursorSpec.cs
    TradingBot.ApiService/Application/Specifications/Purchases/PurchasesOrderedByDateSpec.cs
    TradingBot.ApiService/Application/Specifications/DailyPrices/DailyPriceByDateRangeSpec.cs
  </files>
  <action>
Create 6 Purchase specs and 1 DailyPrice spec. All specs inherit from `Ardalis.Specification.Specification<T>`. Use `Query.Where(...)`, `Query.OrderByDescending(...)`, `Query.AsNoTracking()` inside constructors.

**Purchase specs** (in `Application/Specifications/Purchases/`):

1. `PurchaseFilledStatusSpec` -- parameterless constructor:
   - `Query.Where(p => !p.IsDryRun && (p.Status == PurchaseStatus.Filled || p.Status == PurchaseStatus.PartiallyFilled))`
   - NO OrderBy (filtering only -- per research pitfall #3 about ordering conflicts)
   - NO AsNoTracking (that goes in the ordering spec)

2. `PurchaseDateRangeSpec(DateOnly startDate, DateOnly endDate)`:
   - Convert DateOnly to DateTime UTC: `startDate.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc)` and `endDate.ToDateTime(TimeOnly.MaxValue, DateTimeKind.Utc)`
   - `Query.Where(p => p.ExecutedAt >= startDateTime && p.ExecutedAt <= endDateTime)`
   - Support one-sided ranges: if only startDate provided, caller passes `DateOnly.MaxValue` for endDate

3. `PurchaseTierFilterSpec(string tier)`:
   - If tier == "Base": `Query.Where(p => p.MultiplierTier == null || p.MultiplierTier == "Base")`
   - Else: `Query.Where(p => p.MultiplierTier == tier)`
   - Handle the "Base" special case matching existing inline LINQ in DashboardEndpoints.cs line 97-99

4. `PurchaseCursorSpec(DateTimeOffset cursor)`:
   - `Query.Where(p => p.ExecutedAt < cursor).OrderByDescending(p => p.ExecutedAt)`
   - Includes its own OrderByDescending because cursor comparison assumes descending order (per research pitfall #3)

5. `PurchasesOrderedByDateSpec` -- parameterless constructor:
   - `Query.OrderByDescending(p => p.ExecutedAt).AsNoTracking()`
   - This is the "base ordering" spec applied when no cursor is used
   - AsNoTracking lives here as the "always-applied base" for read queries

**DailyPrice specs** (in `Application/Specifications/DailyPrices/`):

6. `DailyPriceByDateRangeSpec(Symbol symbol, DateOnly startDate)`:
   - `Query.Where(dp => dp.Symbol == symbol && dp.Date >= startDate).OrderBy(dp => dp.Date).AsNoTracking()`
   - Symbol and date range always used together for chart queries -- combined per research recommendation

All specs use namespace `TradingBot.ApiService.Application.Specifications.Purchases` or `.DailyPrices` matching folder.

Verify build: `dotnet build TradingBot.sln`
  </action>
  <verify>
    `dotnet build TradingBot.sln` succeeds. All 7 spec files exist in their respective directories. Each spec class inherits Specification<Purchase> or Specification<DailyPrice>.
  </verify>
  <done>
    All 7 composable spec classes compile, each applies exactly one filter/sort concern, none include .Select() projection, and they are ready for call-site composition in Plan 02.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` -- clean build with zero errors
2. All 7 spec files exist under `Application/Specifications/`
3. `SpecificationExtensions.cs` exists with `WithSpecification` extension on `IQueryable<T>`
4. No spec class contains `.Select()` or `.Take()` -- those stay at call sites
5. `PurchaseFilledStatusSpec` has only Where, no OrderBy
6. `PurchasesOrderedByDateSpec` has OrderByDescending + AsNoTracking
7. `PurchaseCursorSpec` has both Where and OrderByDescending
8. Existing tests still pass: `dotnet test`
</verification>

<success_criteria>
- Ardalis.Specification 9.3.1 installed in ApiService
- WithSpecification<T> extension method available on IQueryable<T>
- 6 Purchase specs + 1 DailyPrice spec created (composable, one concern each)
- Solution builds clean, all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-specification-pattern/18-01-SUMMARY.md`
</output>
