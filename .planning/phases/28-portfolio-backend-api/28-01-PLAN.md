---
phase: 28-portfolio-backend-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Models/AssetTransaction.cs
  - TradingBot.ApiService/Models/PortfolioAsset.cs
  - TradingBot.ApiService/Models/FixedDeposit.cs
  - TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
  - TradingBot.ApiService/Infrastructure/Data/Migrations/AddSourcePurchaseIdToAssetTransaction.cs
  - TradingBot.ApiService/Application/Handlers/PortfolioImportHandler.cs
  - TradingBot.ApiService/Application/Services/HistoricalPurchaseMigrator.cs
autonomous: true
requirements:
  - PORT-04
  - PORT-05

must_haves:
  truths:
    - "When DCA bot completes a purchase, an AssetTransaction is created under the BTC PortfolioAsset if it exists"
    - "Running the DCA import twice for the same PurchaseId produces no duplicate AssetTransactions"
    - "If no BTC PortfolioAsset exists when PurchaseCompletedEvent fires, the event is silently skipped with a warning log"
    - "Historical migration imports all existing Purchases into AssetTransactions idempotently"
    - "FixedDeposit fields can be updated via an Update method on the entity"
  artifacts:
    - path: "TradingBot.ApiService/Models/AssetTransaction.cs"
      provides: "SourcePurchaseId nullable property for idempotent import tracking"
      contains: "SourcePurchaseId"
    - path: "TradingBot.ApiService/Application/Handlers/PortfolioImportHandler.cs"
      provides: "MediatR handler for PurchaseCompletedEvent that creates AssetTransaction"
      contains: "INotificationHandler<PurchaseCompletedEvent>"
    - path: "TradingBot.ApiService/Application/Services/HistoricalPurchaseMigrator.cs"
      provides: "Service to bulk-import existing Purchase records into AssetTransactions"
      contains: "MigrateAsync"
  key_links:
    - from: "TradingBot.ApiService/Application/Handlers/PortfolioImportHandler.cs"
      to: "TradingBot.ApiService/Models/PortfolioAsset.cs"
      via: "AddTransaction with SourcePurchaseId"
      pattern: "AddTransaction"
    - from: "TradingBot.ApiService/Application/Services/HistoricalPurchaseMigrator.cs"
      to: "TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs"
      via: "Queries Purchases and PortfolioAssets, creates AssetTransactions"
      pattern: "db\\.Purchases"
---

<objective>
Add SourcePurchaseId to AssetTransaction for idempotent DCA import tracking, implement event-driven auto-import handler, historical migration service, and FixedDeposit update capability.

Purpose: Enable automatic portfolio tracking of DCA purchases (both real-time and historical) without duplicates, and allow fixed deposit edits.
Output: Domain model additions, EF migration, MediatR event handler, historical migration service.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-portfolio-backend-api/28-CONTEXT.md
@.planning/phases/26-portfolio-domain-foundation/26-01-SUMMARY.md
@.planning/phases/26-portfolio-domain-foundation/26-03-SUMMARY.md
@.planning/phases/27-price-feed-infrastructure/27-01-SUMMARY.md

Key existing files to reference:
@TradingBot.ApiService/Models/AssetTransaction.cs
@TradingBot.ApiService/Models/PortfolioAsset.cs
@TradingBot.ApiService/Models/FixedDeposit.cs
@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
@TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SourcePurchaseId to AssetTransaction, Update method to FixedDeposit, EF migration</name>
  <files>
    TradingBot.ApiService/Models/AssetTransaction.cs
    TradingBot.ApiService/Models/PortfolioAsset.cs
    TradingBot.ApiService/Models/FixedDeposit.cs
    TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
    TradingBot.ApiService/Infrastructure/Data/Migrations/{timestamp}_AddSourcePurchaseIdToAssetTransaction.cs
  </files>
  <action>
    **AssetTransaction.cs changes:**
    - Add `public PurchaseId? SourcePurchaseId { get; private set; }` property (nullable — only set for bot-imported transactions)
    - Add a second overload to `AssetTransaction.Create` (internal) that accepts `PurchaseId? sourcePurchaseId` parameter. The existing Create method should call the new one with `null`. This keeps the aggregate boundary enforcement intact.
    - Add `using TradingBot.ApiService.Models.Ids;` if PurchaseId isn't already imported (it should be via the namespace)

    **PortfolioAsset.cs changes:**
    - Add a second `AddTransaction` overload that accepts an additional `PurchaseId? sourcePurchaseId` parameter, passing it through to `AssetTransaction.Create`. The existing overload should call this one with `null`.

    **FixedDeposit.cs changes:**
    - Add an `Update` method: `public void Update(string bankName, VndAmount principal, decimal annualInterestRate, DateOnly startDate, DateOnly maturityDate, CompoundingFrequency compoundingFrequency)`. Apply the same validation guards as `Create` (bankName not null/whitespace, maturityDate > startDate, rate in (0,1]). Set all properties and update `UpdatedAt = DateTimeOffset.UtcNow`.

    **TradingBotDbContext.cs changes:**
    - In the `AssetTransaction` entity configuration, add: `entity.Property(e => e.SourcePurchaseId).IsRequired(false);`
    - Add a unique index on SourcePurchaseId (filtered to non-null) for idempotency enforcement: `entity.HasIndex(e => e.SourcePurchaseId).IsUnique().HasFilter("\"SourcePurchaseId\" IS NOT NULL");`

    **EF Migration:**
    - Run `cd TradingBot.ApiService && dotnet ef migrations add AddSourcePurchaseIdToAssetTransaction` to generate migration
    - Migration auto-runs on startup via `dbContext.Database.MigrateAsync()`

    Build and verify: `dotnet build TradingBot.slnx` — 0 errors.
  </action>
  <verify>
    `dotnet build TradingBot.slnx` passes with 0 errors. Migration file exists. `dotnet test` passes (all existing 76 tests still green).
  </verify>
  <done>
    AssetTransaction has SourcePurchaseId with unique filtered index. FixedDeposit has Update method. PortfolioAsset has AddTransaction overload accepting SourcePurchaseId. Migration created and ready to auto-apply.
  </done>
</task>

<task type="auto">
  <name>Task 2: DCA auto-import event handler and historical migration service</name>
  <files>
    TradingBot.ApiService/Application/Handlers/PortfolioImportHandler.cs
    TradingBot.ApiService/Application/Services/HistoricalPurchaseMigrator.cs
  </files>
  <action>
    **PortfolioImportHandler.cs:**
    Create a new MediatR notification handler `PortfolioPurchaseCompletedEventHandler` implementing `INotificationHandler<PurchaseCompletedEvent>`. Use primary constructor pattern with `TradingBotDbContext`, `ILogger<PortfolioPurchaseCompletedEventHandler>`.

    Handler logic:
    1. Find the BTC PortfolioAsset: query `db.PortfolioAssets.Include(a => a.Transactions).FirstOrDefaultAsync(a => a.Ticker == "BTC" && a.AssetType == AssetType.Crypto, ct)`. Use `AsTracking()` since we need to modify.
    2. If no BTC asset exists: `logger.LogWarning("No BTC PortfolioAsset found — skipping auto-import for Purchase {PurchaseId}. User must create BTC asset first.", notification.PurchaseId)` and return.
    3. Check idempotency: if `asset.Transactions.Any(t => t.SourcePurchaseId == notification.PurchaseId)`, log debug "already imported" and return.
    4. Load the full Purchase entity from DB to get all fields: `var purchase = await db.Purchases.FirstOrDefaultAsync(p => p.Id == notification.PurchaseId, ct)`. If null, log warning and return.
    5. Call `asset.AddTransaction(date: DateOnly.FromDateTime(purchase.ExecutedAt.DateTime), quantity: purchase.Quantity.Value, pricePerUnit: purchase.Price.Value, currency: Currency.USD, type: TransactionType.Buy, fee: null, source: TransactionSource.Bot, sourcePurchaseId: purchase.Id)`.
    6. `await db.SaveChangesAsync(ct)`.
    7. Wrap everything in try/catch, log error on exception (graceful degradation — don't crash DCA bot if portfolio import fails).

    **HistoricalPurchaseMigrator.cs:**
    Create a service class `HistoricalPurchaseMigrator` with primary constructor taking `TradingBotDbContext db, ILogger<HistoricalPurchaseMigrator> logger`. Register as Scoped in DI (add to Program.cs or a ServiceCollectionExtensions).

    Method `public async Task<int> MigrateAsync(PortfolioAssetId btcAssetId, CancellationToken ct)`:
    1. Load the BTC PortfolioAsset with transactions: `var asset = await db.PortfolioAssets.AsTracking().Include(a => a.Transactions).FirstOrDefaultAsync(a => a.Id == btcAssetId, ct)`. If null, throw `InvalidOperationException`.
    2. Get all existing SourcePurchaseIds: `var importedPurchaseIds = asset.Transactions.Where(t => t.SourcePurchaseId != null).Select(t => t.SourcePurchaseId!.Value).ToHashSet()`.
    3. Load all filled purchases: `var purchases = await db.Purchases.Where(p => p.Status == PurchaseStatus.Filled).OrderBy(p => p.ExecutedAt).ToListAsync(ct)`.
    4. Filter out already-imported: `var newPurchases = purchases.Where(p => !importedPurchaseIds.Contains(p.Id)).ToList()`.
    5. For each `purchase` in `newPurchases`: `asset.AddTransaction(DateOnly.FromDateTime(purchase.ExecutedAt.DateTime), purchase.Quantity.Value, purchase.Price.Value, Currency.USD, TransactionType.Buy, null, TransactionSource.Bot, purchase.Id)`.
    6. `await db.SaveChangesAsync(ct)`.
    7. Log: `logger.LogInformation("Migrated {Count} historical purchases into portfolio asset {AssetId}", newPurchases.Count, btcAssetId)`.
    8. Return `newPurchases.Count`.

    **DI Registration:**
    Add `builder.Services.AddScoped<HistoricalPurchaseMigrator>();` in Program.cs, near the existing service registrations.

    Build and verify: `dotnet build TradingBot.slnx` — 0 errors.
  </action>
  <verify>
    `dotnet build TradingBot.slnx` passes with 0 errors. `dotnet test` passes. PortfolioImportHandler is registered as MediatR handler (auto-discovered). HistoricalPurchaseMigrator is registered in DI.
  </verify>
  <done>
    PurchaseCompletedEvent auto-imports into BTC PortfolioAsset idempotently. HistoricalPurchaseMigrator bulk-imports all existing Purchases. Both skip duplicates via SourcePurchaseId check. Graceful degradation on all failure paths.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.slnx` — 0 errors
2. `dotnet test` — all 76 existing tests pass
3. AssetTransaction entity has SourcePurchaseId property with unique filtered index in DB
4. FixedDeposit has Update method with same validation as Create
5. PortfolioPurchaseCompletedEventHandler is discoverable by MediatR assembly scanning
6. HistoricalPurchaseMigrator is registered as Scoped service
</verification>

<success_criteria>
- AssetTransaction.SourcePurchaseId nullable property exists with unique filtered DB index
- PortfolioPurchaseCompletedEventHandler handles PurchaseCompletedEvent for auto-import with idempotency
- HistoricalPurchaseMigrator.MigrateAsync imports all filled Purchases idempotently
- FixedDeposit.Update validates and sets all fields
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/28-portfolio-backend-api/28-01-SUMMARY.md`
</output>
