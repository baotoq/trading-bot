---
phase: 28-portfolio-backend-api
plan: 02
type: execute
wave: 2
depends_on:
  - 28-01
files_modified:
  - TradingBot.ApiService/Endpoints/PortfolioEndpoints.cs
  - TradingBot.ApiService/Endpoints/PortfolioDtos.cs
  - TradingBot.ApiService/Endpoints/FixedDepositEndpoints.cs
  - TradingBot.ApiService/Endpoints/FixedDepositDtos.cs
  - TradingBot.ApiService/Program.cs
autonomous: true
requirements:
  - PORT-04
  - PORT-05

must_haves:
  truths:
    - "GET /api/portfolio/summary returns total portfolio value in USD and VND, per-asset-type allocation percentages, and overall P&L"
    - "GET /api/portfolio/assets returns per-asset breakdown with current value, weighted average cost, unrealized P&L (absolute + percentage)"
    - "POST /api/portfolio/assets/{id}/transactions creates a manual transaction; rejects fractional ETF quantities and future dates"
    - "GET /api/portfolio/summary triggers historical migration when BTC asset has no imported transactions"
    - "POST /api/portfolio/fixed-deposits creates a fixed deposit; GET returns all with accrued and projected maturity values"
    - "PUT /api/portfolio/fixed-deposits/{id} updates all fields; DELETE hard-deletes the record"
  artifacts:
    - path: "TradingBot.ApiService/Endpoints/PortfolioEndpoints.cs"
      provides: "Portfolio summary, assets list, and transaction creation endpoints"
      contains: "MapPortfolioEndpoints"
    - path: "TradingBot.ApiService/Endpoints/PortfolioDtos.cs"
      provides: "Request/response DTOs for portfolio endpoints"
      contains: "PortfolioSummaryResponse"
    - path: "TradingBot.ApiService/Endpoints/FixedDepositEndpoints.cs"
      provides: "Fixed deposit CRUD endpoints"
      contains: "MapFixedDepositEndpoints"
    - path: "TradingBot.ApiService/Endpoints/FixedDepositDtos.cs"
      provides: "Request/response DTOs for fixed deposit endpoints"
      contains: "FixedDepositResponse"
    - path: "TradingBot.ApiService/Program.cs"
      provides: "Endpoint registration"
      contains: "MapPortfolioEndpoints"
  key_links:
    - from: "TradingBot.ApiService/Endpoints/PortfolioEndpoints.cs"
      to: "TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/ICryptoPriceProvider.cs"
      via: "Fetches live crypto prices for portfolio valuation"
      pattern: "ICryptoPriceProvider"
    - from: "TradingBot.ApiService/Endpoints/PortfolioEndpoints.cs"
      to: "TradingBot.ApiService/Application/Services/HistoricalPurchaseMigrator.cs"
      via: "Triggers migration on first summary call"
      pattern: "HistoricalPurchaseMigrator"
    - from: "TradingBot.ApiService/Endpoints/FixedDepositEndpoints.cs"
      to: "TradingBot.ApiService/Application/Services/InterestCalculator.cs"
      via: "Computes accrued and maturity values for response"
      pattern: "InterestCalculator"
---

<objective>
Build all portfolio and fixed deposit API endpoints: summary with cross-currency valuation, per-asset breakdown with P&L, manual transaction creation, historical migration trigger, and full fixed deposit CRUD.

Purpose: Provide the complete API surface the Flutter app will consume for portfolio management.
Output: 4 endpoint/DTO files + Program.cs registration.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-portfolio-backend-api/28-CONTEXT.md
@.planning/phases/28-portfolio-backend-api/28-01-SUMMARY.md
@.planning/phases/26-portfolio-domain-foundation/26-01-SUMMARY.md
@.planning/phases/26-portfolio-domain-foundation/26-02-SUMMARY.md
@.planning/phases/27-price-feed-infrastructure/27-01-SUMMARY.md
@.planning/phases/27-price-feed-infrastructure/27-02-SUMMARY.md

Key existing files to reference:
@TradingBot.ApiService/Endpoints/DashboardEndpoints.cs (pattern for endpoint structure, ApiKeyEndpointFilter)
@TradingBot.ApiService/Endpoints/DashboardDtos.cs (pattern for DTO records)
@TradingBot.ApiService/Models/PortfolioAsset.cs
@TradingBot.ApiService/Models/AssetTransaction.cs
@TradingBot.ApiService/Models/FixedDeposit.cs
@TradingBot.ApiService/Application/Services/InterestCalculator.cs
@TradingBot.ApiService/Application/Services/HistoricalPurchaseMigrator.cs
@TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/ICryptoPriceProvider.cs
@TradingBot.ApiService/Infrastructure/PriceFeeds/Etf/IEtfPriceProvider.cs
@TradingBot.ApiService/Infrastructure/PriceFeeds/ExchangeRate/IExchangeRateProvider.cs
@TradingBot.ApiService/Infrastructure/PriceFeeds/PriceFeedResult.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Portfolio endpoints (summary, assets, transactions) with DTOs</name>
  <files>
    TradingBot.ApiService/Endpoints/PortfolioDtos.cs
    TradingBot.ApiService/Endpoints/PortfolioEndpoints.cs
    TradingBot.ApiService/Program.cs
  </files>
  <action>
    **PortfolioDtos.cs:**
    Create DTO records in `TradingBot.ApiService.Endpoints` namespace. Follow DashboardDtos.cs pattern (record types, all in one file).

    ```
    // Summary response
    record PortfolioSummaryResponse(
        decimal TotalValueUsd,
        decimal TotalValueVnd,
        decimal TotalCostUsd,
        decimal TotalCostVnd,
        decimal UnrealizedPnlUsd,
        decimal UnrealizedPnlVnd,
        decimal? UnrealizedPnlPercent,
        List<AllocationDto> Allocations,
        DateTimeOffset? ExchangeRateUpdatedAt
    );

    record AllocationDto(string AssetType, decimal ValueUsd, decimal Percentage);

    // Assets response
    record PortfolioAssetResponse(
        Guid Id,
        string Name,
        string Ticker,
        string AssetType,
        string NativeCurrency,
        decimal Quantity,
        decimal AverageCost,
        decimal CurrentPrice,
        decimal CurrentValueUsd,
        decimal CurrentValueVnd,
        decimal UnrealizedPnlUsd,
        decimal? UnrealizedPnlPercent,
        DateTimeOffset? PriceUpdatedAt,
        bool IsPriceStale
    );

    // Transaction request
    record CreateTransactionRequest(
        DateOnly Date,
        decimal Quantity,
        decimal PricePerUnit,
        string Currency,
        string Type,
        decimal? Fee
    );

    // Transaction response (for confirmation)
    record TransactionResponse(
        Guid Id,
        DateOnly Date,
        decimal Quantity,
        decimal PricePerUnit,
        string Currency,
        string Type,
        decimal? Fee,
        string Source
    );
    ```

    **PortfolioEndpoints.cs:**
    Create static class `PortfolioEndpoints` with extension method `MapPortfolioEndpoints(this WebApplication app)`. Follow DashboardEndpoints.cs structure exactly.

    Route group: `/api/portfolio` with `ApiKeyEndpointFilter`.

    **GET /summary** (`GetSummaryAsync`):
    Inject: `TradingBotDbContext db`, `ICryptoPriceProvider cryptoPriceProvider`, `IEtfPriceProvider etfPriceProvider`, `IExchangeRateProvider exchangeRateProvider`, `HistoricalPurchaseMigrator migrator`, `ILogger<Program> logger`, `CancellationToken ct`.

    Logic:
    1. Load all PortfolioAssets with Transactions: `db.PortfolioAssets.Include(a => a.Transactions).ToListAsync(ct)`.
    2. Check if BTC asset exists but has no bot-imported transactions — trigger historical migration:
       ```
       var btcAsset = assets.FirstOrDefault(a => a.Ticker == "BTC" && a.AssetType == AssetType.Crypto);
       if (btcAsset != null && !btcAsset.Transactions.Any(t => t.Source == TransactionSource.Bot))
       {
           var migratedCount = await migrator.MigrateAsync(btcAsset.Id, ct);
           if (migratedCount > 0)
           {
               // Reload to get migrated transactions
               assets = await db.PortfolioAssets.Include(a => a.Transactions).ToListAsync(ct);
               btcAsset = assets.First(a => a.Ticker == "BTC" && a.AssetType == AssetType.Crypto);
           }
       }
       ```
    3. Fetch exchange rate: `var exchangeRate = await exchangeRateProvider.GetUsdToVndRateAsync(ct)`.
    4. Load all fixed deposits: `var fixedDeposits = await db.FixedDeposits.Where(fd => fd.Status == FixedDepositStatus.Active).ToListAsync(ct)`.
    5. For each asset, compute current value:
       - Crypto: fetch price via `cryptoPriceProvider.GetPriceAsync(ticker.ToLower())` (CoinGecko uses lowercase IDs — use "bitcoin" for BTC, for now just handle BTC; use a mapping dictionary: `var coinGeckoIds = new Dictionary<string, string> { ["BTC"] = "bitcoin", ["ETH"] = "ethereum" }`)
       - ETF: fetch price via `etfPriceProvider.GetPriceAsync(ticker)`
       - Value = quantity * currentPrice
    6. Compute P&L per asset: weighted avg cost = sum(tx.PricePerUnit * tx.Quantity for Buy) / sum(tx.Quantity for Buy), accounting for sells. P&L = (currentPrice - avgCost) * netQuantity.
    7. Cross-currency: if asset.NativeCurrency == USD, valueVnd = valueUsd * exchangeRate; if VND, valueUsd = valueVnd / exchangeRate.
    8. For fixed deposits: value = InterestCalculator.CalculateAccruedValue(principal, rate, startDate, DateOnly.FromDateTime(DateTime.UtcNow), compounding). These are always VND.
    9. Sum totals. Compute allocation percentages based on current market value in USD.
    10. Return `PortfolioSummaryResponse`.
    Wrap price fetches in try/catch — if a price feed fails, use 0 for that asset and log warning. Don't fail the whole endpoint.

    **GET /assets** (`GetAssetsAsync`):
    Similar to summary but returns `List<PortfolioAssetResponse>`. Compute per-asset: quantity (net of buys/sells), average cost, current price, value in both currencies, P&L, price staleness (from PriceFeedResult.IsStale).

    **POST /assets/{id}/transactions** (`CreateTransactionAsync`):
    Inject: `TradingBotDbContext db`, `Guid id` (route param, this is the PortfolioAssetId), `CreateTransactionRequest request`, `ILogger<Program> logger`, `CancellationToken ct`.

    Validation:
    - Parse `request.Currency` to `Currency` enum. If invalid, return `Results.BadRequest("Invalid currency")`.
    - Parse `request.Type` to `TransactionType` enum. If invalid, return `Results.BadRequest("Invalid transaction type")`.
    - Reject future dates: if `request.Date > DateOnly.FromDateTime(DateTime.UtcNow)`, return `Results.BadRequest("Transaction date cannot be in the future")`.
    - Load asset with `.AsTracking()`: `var asset = await db.PortfolioAssets.AsTracking().Include(a => a.Transactions).FirstOrDefaultAsync(a => a.Id == PortfolioAssetId.From(id), ct)`. If null, return `Results.NotFound()`.
    - For ETF assets: reject fractional quantities. If `asset.AssetType == AssetType.ETF && request.Quantity != Math.Floor(request.Quantity)`, return `Results.BadRequest("ETF quantities must be whole numbers")`.
    - Call `asset.AddTransaction(request.Date, request.Quantity, request.PricePerUnit, currency, type, request.Fee, TransactionSource.Manual)`.
    - `await db.SaveChangesAsync(ct)`.
    - Return `Results.Created($"/api/portfolio/assets/{id}/transactions/{tx.Id}", transactionResponse)`.

    **Program.cs:**
    Add `app.MapPortfolioEndpoints();` after existing `app.MapDashboardEndpoints();` line. Add `app.MapFixedDepositEndpoints();` (for Plan 02's Task 2) right after.
  </action>
  <verify>
    `dotnet build TradingBot.slnx` passes with 0 errors. `dotnet test` passes. Portfolio endpoint methods compile with correct DI injection signatures matching ASP.NET minimal API conventions.
  </verify>
  <done>
    GET /api/portfolio/summary returns USD and VND totals with allocation percentages and triggers historical migration when needed. GET /api/portfolio/assets returns per-asset P&L. POST /api/portfolio/assets/{id}/transactions validates and creates manual transactions. All endpoints protected by ApiKeyEndpointFilter.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fixed deposit CRUD endpoints with DTOs</name>
  <files>
    TradingBot.ApiService/Endpoints/FixedDepositDtos.cs
    TradingBot.ApiService/Endpoints/FixedDepositEndpoints.cs
  </files>
  <action>
    **FixedDepositDtos.cs:**
    Create DTO records:

    ```
    record CreateFixedDepositRequest(
        string BankName,
        decimal Principal,
        decimal AnnualInterestRate,
        DateOnly StartDate,
        DateOnly MaturityDate,
        string CompoundingFrequency
    );

    record UpdateFixedDepositRequest(
        string BankName,
        decimal Principal,
        decimal AnnualInterestRate,
        DateOnly StartDate,
        DateOnly MaturityDate,
        string CompoundingFrequency
    );

    record FixedDepositResponse(
        Guid Id,
        string BankName,
        decimal PrincipalVnd,
        decimal AnnualInterestRate,
        DateOnly StartDate,
        DateOnly MaturityDate,
        string CompoundingFrequency,
        string Status,
        decimal AccruedValueVnd,
        decimal ProjectedMaturityValueVnd,
        int DaysToMaturity,
        DateTimeOffset CreatedAt
    );
    ```

    **FixedDepositEndpoints.cs:**
    Create static class `FixedDepositEndpoints` with extension method `MapFixedDepositEndpoints(this WebApplication app)`.

    Route group: `/api/portfolio/fixed-deposits` with `ApiKeyEndpointFilter`.

    **GET /** (`GetAllAsync`):
    Load all fixed deposits: `db.FixedDeposits.OrderBy(fd => fd.MaturityDate).ToListAsync(ct)`.
    For each, compute:
    - `accruedValue = InterestCalculator.CalculateAccruedValue(fd.Principal.Value, fd.AnnualInterestRate, fd.StartDate, today, fd.CompoundingFrequency)` where `today = DateOnly.FromDateTime(DateTime.UtcNow)`.
    - `projectedMaturityValue = InterestCalculator.CalculateAccruedValue(fd.Principal.Value, fd.AnnualInterestRate, fd.StartDate, fd.MaturityDate, fd.CompoundingFrequency)`.
    - `daysToMaturity = Math.Max(0, fd.MaturityDate.DayNumber - today.DayNumber)`.
    Map to `FixedDepositResponse` list and return.

    **GET /{id}** (`GetByIdAsync`):
    Find by ID. If null, return `Results.NotFound()`. Compute same values as above. Return single `FixedDepositResponse`.

    **POST /** (`CreateAsync`):
    Parse `request.CompoundingFrequency` to `CompoundingFrequency` enum. If invalid, return `Results.BadRequest("Invalid compounding frequency")`.
    Create `VndAmount.From(request.Principal)` — let Vogen validation handle non-negative.
    Call `FixedDeposit.Create(request.BankName, principal, request.AnnualInterestRate, request.StartDate, request.MaturityDate, compoundingFreq)`.
    Wrap in try/catch for ArgumentException from domain validation (bankName, rate, dates) — return `Results.BadRequest(ex.Message)`.
    `db.FixedDeposits.Add(fd)`. `await db.SaveChangesAsync(ct)`.
    Return `Results.Created($"/api/portfolio/fixed-deposits/{fd.Id}", response)`.

    **PUT /{id}** (`UpdateAsync`):
    Load with `.AsTracking()`. If null, return `Results.NotFound()`.
    Parse CompoundingFrequency. Create VndAmount.
    Call `fd.Update(request.BankName, principal, request.AnnualInterestRate, request.StartDate, request.MaturityDate, compoundingFreq)`.
    Wrap in try/catch for ArgumentException — return `Results.BadRequest(ex.Message)`.
    `await db.SaveChangesAsync(ct)`.
    Return `Results.Ok(response)` with updated values including recomputed accrued/projected amounts.

    **DELETE /{id}** (`DeleteAsync`):
    Load entity. If null, return `Results.NotFound()`.
    `db.FixedDeposits.Remove(fd)`. `await db.SaveChangesAsync(ct)`.
    Return `Results.NoContent()`.

    **Program.cs note:** The `app.MapFixedDepositEndpoints()` call was added in Task 1. If not, add it after `MapPortfolioEndpoints()`.
  </action>
  <verify>
    `dotnet build TradingBot.slnx` passes with 0 errors. `dotnet test` passes. All 5 fixed deposit endpoints compile correctly.
  </verify>
  <done>
    GET /api/portfolio/fixed-deposits returns all deposits with accrued and projected values. POST creates with validation. PUT updates all fields. DELETE hard-deletes. GET /{id} returns single deposit. All protected by ApiKeyEndpointFilter.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.slnx` — 0 errors
2. `dotnet test` — all existing tests pass
3. Endpoint routes registered in Program.cs: `MapPortfolioEndpoints()` and `MapFixedDepositEndpoints()`
4. All endpoints protected by `ApiKeyEndpointFilter` (x-api-key header required)
5. Summary endpoint fetches prices from all three providers (crypto, ETF, exchange rate)
6. Summary endpoint triggers historical migration when BTC asset exists with no imported transactions
7. Transaction creation validates: no future dates, no fractional ETF quantities, valid enum parsing
8. Fixed deposit responses include computed accrued value, projected maturity value, and days to maturity
</verification>

<success_criteria>
- GET /api/portfolio/summary returns complete cross-currency portfolio valuation
- GET /api/portfolio/assets returns per-asset P&L with price staleness info
- POST /api/portfolio/assets/{id}/transactions validates and creates manual transactions
- Historical migration triggers automatically on first summary call
- Full fixed deposit CRUD (POST/GET/PUT/DELETE) with computed financial values
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/28-portfolio-backend-api/28-02-SUMMARY.md`
</output>
