---
phase: 19-dashboard-nullable-price-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Endpoints/DashboardDtos.cs
  - TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
  - TradingBot.Dashboard/app/types/dashboard.ts
  - TradingBot.Dashboard/app/components/dashboard/PortfolioStats.vue
  - TradingBot.Dashboard/app/components/dashboard/PriceChart.vue
autonomous: true
requirements: [TS-04]

must_haves:
  truths:
    - "Portfolio endpoint returns 200 with null prices (not 500) when DB is empty"
    - "Portfolio endpoint returns 200 with null CurrentPrice when Hyperliquid is unreachable"
    - "TotalCost is decimal in DTO (not UsdAmount) so zero from empty Sum does not throw"
    - "PnL fields are null (not computed from zero) when CurrentPrice is unavailable"
    - "Chart endpoint returns 200 with null AverageCostBasis when no purchases exist"
    - "Dashboard shows '--' for unavailable price fields instead of crashing or showing $0"
    - "Chart omits average cost line when AverageCostBasis is null"
    - "All existing tests pass without behavioral regression"
  artifacts:
    - path: "TradingBot.ApiService/Endpoints/DashboardDtos.cs"
      provides: "Nullable Price, decimal TotalCost, and nullable decimal PnL fields in PortfolioResponse and PriceChartResponse"
      contains: "Price? AverageCostBasis"
    - path: "TradingBot.ApiService/Endpoints/DashboardEndpoints.cs"
      provides: "Null-safe endpoint logic for empty DB and failed price fetch"
      contains: "Price? currentPrice = null"
    - path: "TradingBot.Dashboard/app/types/dashboard.ts"
      provides: "Nullable TypeScript types matching backend DTOs"
      contains: "averageCostBasis: Price | null"
    - path: "TradingBot.Dashboard/app/components/dashboard/PortfolioStats.vue"
      provides: "Dash display for null price fields"
      contains: "'--'"
    - path: "TradingBot.Dashboard/app/components/dashboard/PriceChart.vue"
      provides: "Conditional average cost line omission"
      contains: "averageCostBasis"
  key_links:
    - from: "TradingBot.ApiService/Endpoints/DashboardEndpoints.cs"
      to: "TradingBot.ApiService/Endpoints/DashboardDtos.cs"
      via: "PortfolioResponse and PriceChartResponse construction with nullable fields"
      pattern: "Price\\? (averageCostBasis|currentPrice)"
    - from: "TradingBot.Dashboard/app/types/dashboard.ts"
      to: "TradingBot.ApiService/Endpoints/DashboardDtos.cs"
      via: "TypeScript types mirror C# DTO nullability"
      pattern: "(Price|number) \\| null"
    - from: "TradingBot.Dashboard/app/components/dashboard/PortfolioStats.vue"
      to: "TradingBot.Dashboard/app/types/dashboard.ts"
      via: "Null checks before formatting price values"
      pattern: "=== null.*'--'"
---

<objective>
Make dashboard endpoints handle empty DB and unreachable Hyperliquid gracefully by using nullable Price fields in DTOs, updating endpoint construction logic to produce nulls instead of zero (which crashes Price.From(0)), and updating the Nuxt dashboard to display "--" for unavailable values.

Purpose: Closes INT-01 and FLOW-01 from v2.0 milestone audit -- prevents 500 errors when Price value object validation rejects zero values in edge cases.

Output: Updated DTOs, endpoint logic, TypeScript types, and Vue components that handle null prices cleanly.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-dashboard-nullable-price-fix/19-CONTEXT.md

@TradingBot.ApiService/Endpoints/DashboardDtos.cs
@TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
@TradingBot.ApiService/Models/Values/Price.cs
@TradingBot.ApiService/Models/Values/UsdAmount.cs
@TradingBot.Dashboard/app/types/dashboard.ts
@TradingBot.Dashboard/app/components/dashboard/PortfolioStats.vue
@TradingBot.Dashboard/app/components/dashboard/PriceChart.vue
@TradingBot.Dashboard/app/components/dashboard/StatCard.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make Price fields nullable in C# DTOs and update endpoint construction logic</name>
  <files>
    TradingBot.ApiService/Endpoints/DashboardDtos.cs
    TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
  </files>
  <action>
**DashboardDtos.cs -- Update PortfolioResponse and PriceChartResponse:**

1. In `PortfolioResponse`, change these fields:
   - `UsdAmount TotalCost` --> `decimal TotalCost` (use plain decimal; UsdAmount rejects zero via `value > 0` validation, but when DB is empty `Sum()` returns `0m` which triggers VogenInvalidValueException on implicit cast. Response DTOs are aggregate output, not domain input -- plain decimal is correct here.)
   - `Price AverageCostBasis` --> `Price? AverageCostBasis` (null when no purchases)
   - `Price CurrentPrice` --> `Price? CurrentPrice` (null when Hyperliquid unreachable)
   - `decimal UnrealizedPnl` --> `decimal? UnrealizedPnl` (null when CurrentPrice unavailable)
   - `decimal UnrealizedPnlPercent` --> `decimal? UnrealizedPnlPercent` (null when CurrentPrice unavailable)
   - Add comment: `// TotalCost is decimal (not UsdAmount) because zero is valid when no purchases exist`

2. In `PriceChartResponse`, change:
   - `Price AverageCostBasis` --> `Price? AverageCostBasis` (null when no purchases)

**DashboardEndpoints.cs -- Update GetPortfolioAsync:**

1. Change the `totalBtc` and `totalCost` computation to extract raw decimals:
   ```csharp
   var totalBtc = purchases.Sum(p => (decimal)p.Quantity);
   var totalCost = purchases.Sum(p => (decimal)p.Cost);
   ```
   This ensures both are plain `decimal` values (0m when no purchases), avoiding any implicit Vogen cast on assignment.

2. Compute `averageCostBasis` as `Price?`:
   - When `totalBtc > 0`: `Price.From(totalCost / totalBtc)` (valid positive value)
   - When `totalBtc == 0` (no purchases): `null`

3. Compute `currentPrice` as `Price?`:
   - On success from `hyperliquidClient.GetSpotPriceAsync`: `Price.From(result)`
   - On exception: `null` (already caught, just change from `decimal currentPrice = 0` to `Price? currentPrice = null`)

4. Compute PnL as `decimal?` using explicit null guard:
   ```csharp
   decimal? unrealizedPnl = null;
   decimal? unrealizedPnlPercent = null;
   if (currentPrice.HasValue)
   {
       unrealizedPnl = (currentPrice.Value.Value * totalBtc) - totalCost;
       unrealizedPnlPercent = totalCost > 0 ? (unrealizedPnl.Value / totalCost) * 100 : 0;
   }
   ```

5. Construct `PortfolioResponse` passing:
   - `TotalBtc: Quantity.From(totalBtc)` (Quantity allows zero)
   - `TotalCost: totalCost` (already `decimal`, matches the updated DTO field type)
   - The nullable `averageCostBasis`, `currentPrice`, `unrealizedPnl`, `unrealizedPnlPercent`

**DashboardEndpoints.cs -- Update GetPriceChartAsync:**

1. Change to extract raw decimals:
   ```csharp
   var totalBtc = allPurchases.Sum(p => (decimal)p.Quantity);
   var totalCost = allPurchases.Sum(p => (decimal)p.Cost);
   ```

2. Compute `averageCostBasis` as `Price?`:
   - When `totalBtc > 0`: `Price.From(totalCost / totalBtc)`
   - When `totalBtc == 0`: `null`

3. Construct `PriceChartResponse` with the nullable `averageCostBasis`.

**Important:** Do NOT change `Price.From()` behavior or `Quantity` validation. The Quantity value object allows zero (`value >= 0`) so `Quantity.From(0)` is safe for `TotalBtc`. The key fix is that `TotalCost` becomes `decimal` in the DTO because `UsdAmount` requires `value > 0` and zero is a valid aggregate output.
  </action>
  <verify>
Run `dotnet build TradingBot.slnx` -- must compile cleanly with no errors or warnings related to nullability.
Run `dotnet test` -- all 53 existing tests pass (no behavioral regression).
  </verify>
  <done>
PortfolioResponse has `decimal TotalCost` (not UsdAmount), `Price? AverageCostBasis`, `Price? CurrentPrice`, `decimal? UnrealizedPnl`, `decimal? UnrealizedPnlPercent`. PriceChartResponse has `Price? AverageCostBasis`. Endpoint logic produces null (not Price.From(0)) for empty DB and failed price fetch. Zero totalCost does not throw. Build succeeds and all tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update TypeScript types and Vue components for null price handling</name>
  <files>
    TradingBot.Dashboard/app/types/dashboard.ts
    TradingBot.Dashboard/app/components/dashboard/PortfolioStats.vue
    TradingBot.Dashboard/app/components/dashboard/PriceChart.vue
  </files>
  <action>
**dashboard.ts -- Update TypeScript interfaces to match backend nullability:**

1. In `PortfolioResponse`:
   - `totalCost: UsdAmount` --> `totalCost: number` (backend changed to plain decimal)
   - `averageCostBasis: Price` --> `averageCostBasis: Price | null`
   - `currentPrice: Price` --> `currentPrice: Price | null`
   - `unrealizedPnl: number` --> `unrealizedPnl: number | null`
   - `unrealizedPnlPercent: number` --> `unrealizedPnlPercent: number | null`

2. In `PriceChartResponse`:
   - `averageCostBasis: Price` --> `averageCostBasis: Price | null`

**PortfolioStats.vue -- Show "--" for null values (per locked decision):**

1. Update `averageCostBasis` computed:
   - If `props.portfolio.averageCostBasis === null`, return `'--'`
   - Otherwise format as before

2. Update `currentPrice` computed:
   - If `props.portfolio.currentPrice === null`, return `null` (which will show the existing skeleton/empty state in the custom card)
   - Better: return the string `'--'` when null so it shows the dash text
   - Refactor the Current Price card to use `DashboardStatCard` like the other cards (for consistency), OR keep the custom card but check for null and display "--" instead of skeleton

3. Update `unrealizedPnl` computed:
   - If `props.portfolio.unrealizedPnl === null` or `props.portfolio.unrealizedPnlPercent === null`, return `'--'`
   - Otherwise format as before

4. Update `pnlColorClass` computed:
   - When PnL is null, return empty string (no color class)

5. For the Current Price card specifically: Change the `v-if` condition from `!pending && currentPrice` to also handle the case where `currentPrice` is the string `'--'`. Simplest approach: refactor the Current Price to also use `DashboardStatCard` like the other 4 cards. The `StatCard` already handles displaying the value string and showing skeleton when undefined. Pass `'--'` when null, formatted price string when available.

**PriceChart.vue -- Omit average cost line when null (per locked decision):**

1. In the `chartOptions` computed, wrap the `avgLine` annotation in a null check:
   - Only add `annotations.avgLine` when `chartData.value.averageCostBasis !== null`
   - When null, the annotations object simply lacks the `avgLine` key, so no reference line renders

2. Keep the empty chart frame behavior for empty price data (already handled by the `v-else-if="!chartData || chartData.prices.length === 0"` block -- leave this as-is).
  </action>
  <verify>
Run `cd TradingBot.Dashboard && npx nuxt typecheck` (if available) or `npx vue-tsc --noEmit` to verify TypeScript types are consistent.
Manually verify: open dashboard types file and confirm all nullable fields use `| null` pattern.
  </verify>
  <done>
TypeScript PortfolioResponse and PriceChartResponse have nullable fields matching backend. PortfolioStats shows "--" for null averageCostBasis, currentPrice, and PnL. PriceChart omits the average cost reference line when averageCostBasis is null. Card layout stays visible in all cases (no empty state replacement).
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.slnx` compiles cleanly
2. `dotnet test` -- all 53 tests pass
3. Backend: mentally trace GetPortfolioAsync with zero purchases:
   - totalBtc = 0m (decimal, via explicit cast), totalCost = 0m (decimal, via explicit cast)
   - TotalCost DTO field is `decimal` (not UsdAmount), so 0m is safe -- no VogenInvalidValueException
   - TotalBtc DTO field: `Quantity.From(0)` is safe (Quantity allows zero)
   - averageCostBasis = null (not Price.From(0))
   - currentPrice = Price.From(fetched) or null if exception
   - PnL = null when currentPrice is null (explicit if/else, no .Value.Value outside null-check)
   - Response serializes with null JSON values -- no VogenInvalidValueException
4. Backend: mentally trace GetPriceChartAsync with zero purchases:
   - averageCostBasis = null (not Price.From(0))
   - Response serializes with null -- no VogenInvalidValueException
5. Frontend: PortfolioStats displays "--" for null fields, not "$0.00" or crash
6. Frontend: PriceChart omits average cost line when null, keeps chart frame for empty data
</verification>

<success_criteria>
- Portfolio endpoint returns 200 JSON (not 500) when DB has no purchases
- Portfolio endpoint returns 200 JSON (not 500) when Hyperliquid is unreachable
- Chart endpoint returns 200 JSON (not 500) when no purchases exist
- Dashboard renders "--" for unavailable price/PnL values
- Chart renders without average cost line when no purchases
- All 53 existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-dashboard-nullable-price-fix/19-01-SUMMARY.md`
</output>
