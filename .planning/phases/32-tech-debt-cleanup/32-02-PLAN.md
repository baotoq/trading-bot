---
phase: 32-tech-debt-cleanup
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - TradingBot.Mobile/lib/features/portfolio/data/portfolio_repository.dart
  - TradingBot.Mobile/lib/features/portfolio/presentation/sub_screens/fixed_deposit_detail_screen.dart
  - TradingBot.Mobile/lib/features/portfolio/presentation/sub_screens/edit_fixed_deposit_screen.dart
  - TradingBot.Mobile/lib/app/router.dart
  - TradingBot.ApiService/Endpoints/PortfolioEndpoints.cs
  - TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/CoinGeckoPriceProvider.cs
  - TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/ICryptoPriceProvider.cs
autonomous: true
requirements: []

must_haves:
  truths:
    - "PortfolioRepository has updateFixedDeposit and deleteFixedDeposit methods"
    - "Flutter fixed deposit detail screen has Edit and Delete buttons that call the backend PUT and DELETE endpoints"
    - "CoinGecko ID mapping uses a dynamic lookup endpoint (search API) instead of only hardcoded BTC/ETH"
    - "Portfolio endpoint GetCurrentPriceAsync resolves unknown crypto tickers dynamically via CoinGecko search"
  artifacts:
    - path: "TradingBot.Mobile/lib/features/portfolio/data/portfolio_repository.dart"
      provides: "updateFixedDeposit and deleteFixedDeposit methods"
      contains: "updateFixedDeposit"
    - path: "TradingBot.Mobile/lib/features/portfolio/presentation/sub_screens/fixed_deposit_detail_screen.dart"
      provides: "Edit and Delete action buttons for fixed deposits"
      contains: "deleteFixedDeposit"
    - path: "TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/ICryptoPriceProvider.cs"
      provides: "SearchCoinIdAsync method for dynamic CoinGecko ID lookup"
      contains: "SearchCoinIdAsync"
  key_links:
    - from: "TradingBot.Mobile/lib/features/portfolio/presentation/sub_screens/fixed_deposit_detail_screen.dart"
      to: "TradingBot.Mobile/lib/features/portfolio/data/portfolio_repository.dart"
      via: "updateFixedDeposit and deleteFixedDeposit repository calls"
      pattern: "updateFixedDeposit|deleteFixedDeposit"
    - from: "TradingBot.ApiService/Endpoints/PortfolioEndpoints.cs"
      to: "TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/ICryptoPriceProvider.cs"
      via: "SearchCoinIdAsync for unknown tickers"
      pattern: "SearchCoinIdAsync"
---

<objective>
Complete Flutter fixed deposit CRUD (edit/delete) and add dynamic CoinGecko ID lookup so crypto tickers beyond BTC/ETH are resolved automatically.

Purpose: Closes remaining 2 of the 5 Phase 32 success criteria — Flutter fixed deposit edit/delete and CoinGecko dynamic ID mapping.
Output: Updated Flutter repository and detail screen with edit/delete, updated CoinGecko provider with search endpoint, updated portfolio endpoints with dynamic lookup.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@TradingBot.Mobile/lib/features/portfolio/data/portfolio_repository.dart
@TradingBot.Mobile/lib/features/portfolio/data/models/fixed_deposit_response.dart
@TradingBot.Mobile/lib/features/portfolio/presentation/sub_screens/fixed_deposit_detail_screen.dart
@TradingBot.Mobile/lib/features/portfolio/presentation/sub_screens/add_transaction_screen.dart
@TradingBot.Mobile/lib/features/portfolio/data/portfolio_providers.dart
@TradingBot.ApiService/Endpoints/FixedDepositEndpoints.cs
@TradingBot.ApiService/Endpoints/FixedDepositDtos.cs
@TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/CoinGeckoPriceProvider.cs
@TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/ICryptoPriceProvider.cs
@TradingBot.ApiService/Endpoints/PortfolioEndpoints.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Flutter fixed deposit edit and delete</name>
  <files>
    TradingBot.Mobile/lib/features/portfolio/data/portfolio_repository.dart
    TradingBot.Mobile/lib/features/portfolio/presentation/sub_screens/fixed_deposit_detail_screen.dart
    TradingBot.Mobile/lib/features/portfolio/presentation/sub_screens/edit_fixed_deposit_screen.dart
  </files>
  <action>
    **Step 1: Add repository methods.**

    In `portfolio_repository.dart`, add two new methods:

    ```dart
    Future<FixedDepositResponse> updateFixedDeposit(
      String id,
      Map<String, dynamic> body,
    ) async {
      final response = await _dio.put(
        '/api/portfolio/fixed-deposits/$id',
        data: body,
      );
      return FixedDepositResponse.fromJson(
          response.data as Map<String, dynamic>);
    }

    Future<void> deleteFixedDeposit(String id) async {
      await _dio.delete('/api/portfolio/fixed-deposits/$id');
    }
    ```

    **Step 2: Add Edit and Delete to FixedDepositDetailScreen.**

    Modify `fixed_deposit_detail_screen.dart`:
    - Convert from ConsumerWidget to HookConsumerWidget (need hooks for delete confirmation state).
    - Add an AppBar action row with Edit (pencil icon) and Delete (trash icon) IconButtons.
    - Edit button: Navigate to an edit screen with `context.push('/portfolio/fixed-deposit/${fd.id}/edit')`.
    - Delete button: Show a confirmation AlertDialog. On confirm, call `ref.read(portfolioRepositoryProvider).deleteFixedDeposit(id)`. On success, invalidate `portfolioPageDataProvider`, show SnackBar "Fixed deposit deleted", and `context.pop()` back to portfolio. Wrap in try/catch for DioException.

    **Step 3: Create EditFixedDepositScreen.**

    Create new file `edit_fixed_deposit_screen.dart` as a HookConsumerWidget. This screen pre-fills a form with the existing fixed deposit data.

    - Accept `id` parameter in constructor.
    - Watch `portfolioPageDataProvider` to get the existing FixedDepositResponse.
    - Pre-fill TextEditingControllers with: bankName, principal, rate, startDate, maturityDate.
    - Pre-fill compoundingFrequency dropdown (use useState).
    - On save: call `ref.read(portfolioRepositoryProvider).updateFixedDeposit(id, body)` with the form data.
    - On success: invalidate `portfolioPageDataProvider`, show SnackBar "Fixed deposit updated", and pop.
    - Use the same field layout as the fixed deposit section in `add_transaction_screen.dart` (copy the field structure for bank name, principal, rate, start date, maturity date, compounding frequency).
    - Follow existing Flutter conventions: HookConsumerWidget, isSaving useState for loading state, DioException catch with SnackBar.

    **Step 4: Add route for edit screen.**

    In the router file (check `TradingBot.Mobile/lib/app/router.dart`), add a route under the existing fixed-deposit detail route:
    ```dart
    GoRoute(
      path: 'fixed-deposit/:id/edit',
      builder: (context, state) => EditFixedDepositScreen(
        id: state.pathParameters['id']!,
      ),
    ),
    ```

    Import the new screen in the router file.

    Important conventions from existing codebase:
    - Use `AppTheme.bitcoinOrange` for primary buttons.
    - Use `CupertinoIcons` for icons.
    - Use `DateFormat('yyyy-MM-dd')` for date formatting.
    - Use `context.pop()` from go_router for navigation back.
    - Use `ref.invalidate(portfolioPageDataProvider)` after mutations to refresh data.
  </action>
  <verify>
    Run `cd TradingBot.Mobile && flutter analyze` — no errors.
    Verify `portfolio_repository.dart` has `updateFixedDeposit` and `deleteFixedDeposit` methods.
    Verify `fixed_deposit_detail_screen.dart` has Edit and Delete buttons in the AppBar.
    Verify `edit_fixed_deposit_screen.dart` exists with pre-filled form and save functionality.
    Verify router has the edit route.
  </verify>
  <done>
    PortfolioRepository has updateFixedDeposit and deleteFixedDeposit methods. Flutter fixed deposit detail screen has Edit and Delete buttons. Edit screen pre-fills existing deposit data and calls PUT endpoint. Delete shows confirmation dialog and calls DELETE endpoint.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add dynamic CoinGecko ID lookup for crypto tickers</name>
  <files>
    TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/ICryptoPriceProvider.cs
    TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/CoinGeckoPriceProvider.cs
    TradingBot.ApiService/Endpoints/PortfolioEndpoints.cs
  </files>
  <action>
    **Current state:** PortfolioEndpoints.cs has a hardcoded `CoinGeckoIds` dictionary mapping only "BTC" -> "bitcoin" and "ETH" -> "ethereum". Any other crypto ticker (e.g., SOL, ADA, DOT) gets no price and returns 0.

    **Step 1: Add SearchCoinIdAsync to ICryptoPriceProvider.**

    Add a new method to the interface:
    ```csharp
    /// <summary>
    /// Searches for a CoinGecko coin ID by ticker symbol.
    /// Uses the CoinGecko /search endpoint. Results are cached in Redis for 7 days.
    /// </summary>
    /// <param name="ticker">Ticker symbol (e.g., "SOL", "ADA")</param>
    /// <param name="ct">Cancellation token</param>
    /// <returns>CoinGecko coin ID (e.g., "solana"), or null if not found</returns>
    Task<string?> SearchCoinIdAsync(string ticker, CancellationToken ct);
    ```

    **Step 2: Implement SearchCoinIdAsync in CoinGeckoPriceProvider.**

    - Keep the existing static dictionary as a fast-path lookup (no API call needed for BTC/ETH).
    - Add a static well-known mappings dictionary inside the class for common coins that don't need search:
      ```csharp
      private static readonly Dictionary<string, string> WellKnownCoinIds = new(StringComparer.OrdinalIgnoreCase)
      {
          ["BTC"] = "bitcoin",
          ["ETH"] = "ethereum",
          ["SOL"] = "solana",
          ["ADA"] = "cardano",
          ["DOT"] = "polkadot",
          ["AVAX"] = "avalanche-2",
          ["LINK"] = "chainlink",
          ["MATIC"] = "matic-network",
          ["UNI"] = "uniswap",
          ["ATOM"] = "cosmos",
      };
      ```
    - For tickers not in the well-known list, call CoinGecko `/search?query={ticker}` endpoint.
    - Cache the result in Redis with key `"coingecko:ticker:{TICKER}"` and 7-day TTL.
    - Parse the response: look for a coin in `response.coins` where the `symbol` (case-insensitive) matches the ticker. Return the `id` field of the first match.
    - If no match found, cache a sentinel value (empty string) with 1-day TTL to avoid repeated API calls for invalid tickers.
    - Return null if not found.

    CoinGecko /search response shape:
    ```json
    {
      "coins": [
        { "id": "solana", "name": "Solana", "symbol": "SOL", "market_cap_rank": 5 }
      ]
    }
    ```

    Use `System.Text.Json` for deserialization. Create a small DTO record:
    ```csharp
    private record CoinSearchResponse(
        [property: JsonPropertyName("coins")] List<CoinSearchItem>? Coins);

    private record CoinSearchItem(
        [property: JsonPropertyName("id")] string Id,
        [property: JsonPropertyName("symbol")] string Symbol,
        [property: JsonPropertyName("market_cap_rank")] int? MarketCapRank);
    ```

    **Step 3: Update GetCurrentPriceAsync in PortfolioEndpoints.cs.**

    Replace the static `CoinGeckoIds` dictionary lookup with dynamic resolution:
    ```csharp
    if (asset.AssetType == AssetType.Crypto)
    {
        var coinGeckoId = await cryptoPriceProvider.SearchCoinIdAsync(asset.Ticker, ct);
        if (coinGeckoId is not null)
        {
            var result = await cryptoPriceProvider.GetPriceAsync(coinGeckoId, ct);
            return (result.Price, result);
        }

        logger.LogWarning("No CoinGecko ID found for crypto ticker {Ticker}", asset.Ticker);
        return (0m, null);
    }
    ```

    Remove the static `CoinGeckoIds` dictionary field from `PortfolioEndpoints` since it's no longer needed (the well-known list is inside CoinGeckoPriceProvider now).

    Important: The SearchCoinIdAsync should check the well-known dictionary first (no API or cache call), then check Redis cache, then call the API. This means BTC/ETH resolution is still instant with no overhead.
  </action>
  <verify>
    Run `dotnet build TradingBot.slnx` — compiles without errors.
    Run `dotnet test` — all tests pass.
    Verify ICryptoPriceProvider has SearchCoinIdAsync method.
    Verify CoinGeckoPriceProvider implements SearchCoinIdAsync with well-known dictionary + search API + Redis cache.
    Verify PortfolioEndpoints.cs no longer has the static CoinGeckoIds dictionary and uses SearchCoinIdAsync.
  </verify>
  <done>
    CoinGecko ID mapping supports dynamic lookup: well-known tickers resolve instantly, unknown tickers searched via CoinGecko /search API with 7-day Redis cache. Portfolio endpoints use SearchCoinIdAsync instead of hardcoded dictionary. Solution compiles and all tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cd TradingBot.Mobile && flutter analyze` — no analysis errors
2. `dotnet build TradingBot.slnx` — solution compiles
3. `dotnet test` — all tests pass
4. Verify portfolio_repository.dart has updateFixedDeposit and deleteFixedDeposit
5. Verify fixed_deposit_detail_screen.dart has edit/delete actions
6. Verify edit_fixed_deposit_screen.dart exists
7. Verify router.dart has edit route
8. Verify ICryptoPriceProvider has SearchCoinIdAsync
9. Verify PortfolioEndpoints.cs uses dynamic CoinGecko lookup
</verification>

<success_criteria>
- PortfolioRepository has updateFixedDeposit and deleteFixedDeposit methods
- Flutter fixed deposit detail screen has Edit and Delete UI
- Edit fixed deposit screen pre-fills and saves via PUT endpoint
- CoinGecko ID lookup is dynamic with well-known fast-path + search API fallback
- Static CoinGeckoIds dictionary removed from PortfolioEndpoints
- No build errors, all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/32-tech-debt-cleanup/32-02-SUMMARY.md`
</output>
