---
phase: 24-push-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Models/DeviceToken.cs
  - TradingBot.ApiService/Models/Ids/DeviceTokenId.cs
  - TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
  - TradingBot.ApiService/Endpoints/DeviceEndpoints.cs
  - TradingBot.ApiService/TradingBot.ApiService.csproj
  - TradingBot.ApiService/Program.cs
  - TradingBot.ApiService/Infrastructure/Firebase/FirebaseServiceCollectionExtensions.cs
  - TradingBot.ApiService/Infrastructure/Firebase/FcmNotificationService.cs
autonomous: true
requirements:
  - PUSH-05
must_haves:
  truths:
    - "POST /api/devices/register stores a device FCM token in the database"
    - "POST /api/devices/register with an existing token updates the UpdatedAt timestamp (upsert)"
    - "DELETE /api/devices/{token} removes the token from the database"
    - "FcmNotificationService can send a push notification to stored device tokens via FirebaseAdmin SDK"
  artifacts:
    - path: "TradingBot.ApiService/Models/DeviceToken.cs"
      provides: "DeviceToken entity with Token and Platform properties"
      contains: "class DeviceToken"
    - path: "TradingBot.ApiService/Models/Ids/DeviceTokenId.cs"
      provides: "Vogen strongly-typed DeviceTokenId"
      contains: "DeviceTokenId"
    - path: "TradingBot.ApiService/Endpoints/DeviceEndpoints.cs"
      provides: "POST /api/devices/register and DELETE /api/devices/{token} endpoints"
      contains: "MapDeviceEndpoints"
    - path: "TradingBot.ApiService/Infrastructure/Firebase/FcmNotificationService.cs"
      provides: "FCM multicast send with stale token cleanup"
      contains: "FcmNotificationService"
    - path: "TradingBot.ApiService/Infrastructure/Firebase/FirebaseServiceCollectionExtensions.cs"
      provides: "DI registration for Firebase and FcmNotificationService"
      contains: "AddFirebase"
  key_links:
    - from: "TradingBot.ApiService/Endpoints/DeviceEndpoints.cs"
      to: "TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs"
      via: "dbContext.DeviceTokens"
      pattern: "DeviceTokens"
    - from: "TradingBot.ApiService/Infrastructure/Firebase/FcmNotificationService.cs"
      to: "FirebaseMessaging.DefaultInstance"
      via: "FirebaseAdmin SDK"
      pattern: "SendEachForMulticastAsync"
user_setup:
  - service: Firebase
    why: "FCM push notifications require a Firebase project with APNs key"
    env_vars:
      - name: "Firebase:ServiceAccountKeyJson"
        source: "Firebase Console -> Project Settings -> Service accounts -> Generate new private key -> paste JSON string"
    dashboard_config:
      - task: "Create Firebase project (if not already)"
        location: "https://console.firebase.google.com/"
      - task: "Upload APNs Authentication Key (.p8) to Firebase"
        location: "Firebase Console -> Project Settings -> Cloud Messaging -> Apple app configuration -> APNs Authentication Key"
      - task: "Note the Firebase project ID and download service account key JSON"
        location: "Firebase Console -> Project Settings -> Service accounts"
---

<objective>
Backend FCM infrastructure: DeviceToken entity with EF migration, register/unregister REST endpoints, FirebaseAdmin SDK integration, and FcmNotificationService with multicast send and stale token cleanup.

Purpose: Provides the server-side foundation for sending push notifications to iOS devices and managing FCM device tokens.
Output: DeviceToken entity, EF migration, POST/DELETE device endpoints, FcmNotificationService class.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/Models/Ids/PurchaseId.cs
@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
@TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
@TradingBot.ApiService/Infrastructure/Telegram/ServiceCollectionExtensions.cs
@TradingBot.ApiService/Infrastructure/Telegram/TelegramNotificationService.cs
@TradingBot.ApiService/Program.cs
@TradingBot.ApiService/TradingBot.ApiService.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DeviceToken entity, Vogen ID, EF configuration, and migration</name>
  <files>
    TradingBot.ApiService/Models/Ids/DeviceTokenId.cs
    TradingBot.ApiService/Models/DeviceToken.cs
    TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
  </files>
  <action>
    1. Create `Models/Ids/DeviceTokenId.cs` following the exact Vogen pattern from PurchaseId:
       ```csharp
       [ValueObject<Guid>]
       public readonly partial struct DeviceTokenId
       {
           public static DeviceTokenId New() => From(Guid.CreateVersion7());
       }
       ```

    2. Create `Models/DeviceToken.cs` as a simple entity (NOT an AggregateRoot -- no domain events needed):
       ```csharp
       public class DeviceToken : BaseEntity<DeviceTokenId>
       {
           public string Token { get; set; } = string.Empty;   // FCM registration token string
           public string Platform { get; set; } = "ios";        // "ios" or "android" (future-proof)
       }
       ```
       Inherits from BaseEntity<DeviceTokenId> which gives Id, CreatedAt, UpdatedAt.

    3. In `TradingBotDbContext.cs`:
       - Add `public DbSet<DeviceToken> DeviceTokens => Set<DeviceToken>();`
       - In `ConfigureConventions`, add:
         ```csharp
         configurationBuilder.Properties<DeviceTokenId>()
             .HaveConversion<DeviceTokenId.EfCoreValueConverter, DeviceTokenId.EfCoreValueComparer>();
         ```
       - In `OnModelCreating`, add DeviceToken entity configuration:
         ```csharp
         modelBuilder.Entity<DeviceToken>(entity =>
         {
             entity.HasKey(e => e.Id);
             entity.Property(e => e.Token).HasMaxLength(512).IsRequired();
             entity.Property(e => e.Platform).HasMaxLength(10).IsRequired();
             entity.HasIndex(e => e.Token).IsUnique();
         });
         ```

    4. Run EF migration from TradingBot.ApiService directory:
       `dotnet ef migrations add AddDeviceToken`

    5. Verify: `dotnet build TradingBot.slnx` succeeds and `dotnet test` passes all 62 tests.
  </action>
  <verify>
    `dotnet build TradingBot.slnx` succeeds. `dotnet test` passes all 62 tests. Migration file exists in Infrastructure/Data/Migrations/.
  </verify>
  <done>
    DeviceToken entity with DeviceTokenId Vogen type exists. EF migration for DeviceTokens table with unique Token index is generated. Build and tests green.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FirebaseAdmin integration, FcmNotificationService, and device REST endpoints</name>
  <files>
    TradingBot.ApiService/TradingBot.ApiService.csproj
    TradingBot.ApiService/Infrastructure/Firebase/FirebaseServiceCollectionExtensions.cs
    TradingBot.ApiService/Infrastructure/Firebase/FcmNotificationService.cs
    TradingBot.ApiService/Endpoints/DeviceEndpoints.cs
    TradingBot.ApiService/Program.cs
  </files>
  <action>
    1. Add NuGet package: `dotnet add TradingBot.ApiService package FirebaseAdmin`

    2. Create `Infrastructure/Firebase/FirebaseServiceCollectionExtensions.cs`:
       ```csharp
       public static class FirebaseServiceCollectionExtensions
       {
           public static IServiceCollection AddFirebase(this IServiceCollection services, IConfiguration configuration)
           {
               var json = configuration["Firebase:ServiceAccountKeyJson"];
               if (!string.IsNullOrEmpty(json))
               {
                   FirebaseApp.Create(new AppOptions
                   {
                       Credential = GoogleCredential.FromJson(json)
                   });
               }
               else
               {
                   // Allow app to start without Firebase (dev mode)
                   // FcmNotificationService will gracefully no-op
               }
               services.AddScoped<FcmNotificationService>();
               return services;
           }
       }
       ```
       Use `FirebaseAdmin` and `Google.Apis.Auth.OAuth2` namespaces.

    3. Create `Infrastructure/Firebase/FcmNotificationService.cs`:
       - Primary constructor: `(TradingBotDbContext dbContext, ILogger<FcmNotificationService> logger)`
       - Method `SendToAllDevicesAsync(string title, string body, Dictionary<string, string>? data = null, CancellationToken ct = default)`:
         - Load all device tokens from dbContext.DeviceTokens
         - If no tokens, log and return
         - If FirebaseMessaging.DefaultInstance is null, log warning "Firebase not configured, skipping push" and return (graceful no-op for dev)
         - Build `MulticastMessage` with `Notification` (title, body), `Data` (data dict), and `Apns` config:
           ```csharp
           Apns = new ApnsConfig
           {
               Aps = new Aps { Sound = "default" }
           }
           ```
         - Call `FirebaseMessaging.DefaultInstance.SendEachForMulticastAsync(message, ct)`
         - Check `BatchResponse.Responses` for failures:
           - For each failed response where `response.Exception` is `FirebaseMessagingException` with `MessagingErrorCode.Unregistered`:
             - Remove the corresponding token from dbContext.DeviceTokens
           - `await dbContext.SaveChangesAsync(ct)` if any tokens removed
         - Log success count and failure count

    4. Create `Endpoints/DeviceEndpoints.cs`:
       ```csharp
       public static class DeviceEndpoints
       {
           public static void MapDeviceEndpoints(this WebApplication app)
           {
               var group = app.MapGroup("/api/devices")
                   .AddEndpointFilter<ApiKeyEndpointFilter>();

               group.MapPost("/register", RegisterDeviceAsync);
               group.MapDelete("/{token}", UnregisterDeviceAsync);
           }
       }
       ```
       - `RegisterDeviceAsync`: Accept `RegisterDeviceRequest { string Token, string Platform }` from body.
         - Upsert: check if token already exists via `dbContext.DeviceTokens.FirstOrDefaultAsync(d => d.Token == request.Token)`
         - If exists: update UpdatedAt and Platform, save
         - If not: create new DeviceToken with DeviceTokenId.New(), save
         - Return `Results.Ok()`
       - `UnregisterDeviceAsync`: Accept token from route.
         - Find by Token string, remove if found, save
         - Return `Results.NoContent()` (204) whether found or not (idempotent)
       - Use the same `ApiKeyEndpointFilter` pattern from DashboardEndpoints for auth.

    5. In `Program.cs`:
       - Add `using TradingBot.ApiService.Infrastructure.Firebase;`
       - After `builder.Services.AddTelegram(builder.Configuration);` add:
         `builder.Services.AddFirebase(builder.Configuration);`
       - After `app.MapConfigurationEndpoints();` add:
         `app.MapDeviceEndpoints();`

    6. Verify: `dotnet build TradingBot.slnx` succeeds and `dotnet test` passes.
  </action>
  <verify>
    `dotnet build TradingBot.slnx` succeeds. `dotnet test` passes all 62 tests. Endpoints registered at /api/devices/register (POST) and /api/devices/{token} (DELETE).
  </verify>
  <done>
    FirebaseAdmin NuGet installed. FcmNotificationService sends multicast to all stored tokens and auto-removes unregistered tokens. POST /api/devices/register upserts a device token. DELETE /api/devices/{token} removes a token. Both endpoints protected by ApiKeyEndpointFilter. Build and tests green.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.slnx` succeeds
2. `dotnet test` passes all existing tests
3. DeviceTokens migration file exists in Infrastructure/Data/Migrations/
4. FcmNotificationService gracefully handles missing Firebase config (dev mode)
5. POST /api/devices/register and DELETE /api/devices/{token} endpoints exist with API key auth
</verification>

<success_criteria>
- DeviceToken entity persisted to PostgreSQL with unique Token index
- FirebaseAdmin SDK configured via DI with service account key from config
- FcmNotificationService can multicast to all registered devices and clean up stale tokens
- REST endpoints for register/unregister protected by x-api-key
- All 62 existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/24-push-notifications/24-01-SUMMARY.md`
</output>
