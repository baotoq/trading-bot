---
phase: 24-push-notifications
plan: 02
type: execute
wave: 2
depends_on:
  - 24-01
files_modified:
  - TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
  - TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
  - TradingBot.ApiService/Application/BackgroundJobs/MissedPurchaseVerificationService.cs
autonomous: true
requirements:
  - PUSH-01
  - PUSH-02
  - PUSH-03
must_haves:
  truths:
    - "When a BTC purchase completes, a push notification is sent showing amount, price, and multiplier"
    - "When a BTC purchase fails, a push notification is sent showing the failure reason"
    - "When no purchase has occurred in over 36 hours, a push notification is sent alerting the user"
    - "All push notifications include a data payload with 'type' and 'route' fields for deep-linking"
  artifacts:
    - path: "TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs"
      provides: "FCM notification on purchase completed"
      contains: "FcmNotificationService"
    - path: "TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs"
      provides: "FCM notification on purchase failed"
      contains: "FcmNotificationService"
    - path: "TradingBot.ApiService/Application/BackgroundJobs/MissedPurchaseVerificationService.cs"
      provides: "FCM notification on missed purchase (36h threshold)"
      contains: "FcmNotificationService"
  key_links:
    - from: "TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs"
      to: "TradingBot.ApiService/Infrastructure/Firebase/FcmNotificationService.cs"
      via: "constructor injection"
      pattern: "fcmService\\.SendToAllDevicesAsync"
    - from: "TradingBot.ApiService/Application/BackgroundJobs/MissedPurchaseVerificationService.cs"
      to: "TradingBot.ApiService/Infrastructure/Firebase/FcmNotificationService.cs"
      via: "service scope resolution"
      pattern: "GetRequiredService<FcmNotificationService>"
---

<objective>
Hook FcmNotificationService into the three existing notification trigger points: PurchaseCompletedHandler, PurchaseFailedHandler, and MissedPurchaseVerificationService. Each sends a push notification with a data payload containing type and route for Flutter deep-linking.

Purpose: Delivers real-time push notifications to the user's iPhone for all three notification scenarios defined in requirements PUSH-01, PUSH-02, PUSH-03.
Output: Three modified files sending FCM push notifications alongside existing Telegram notifications.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-push-notifications/24-01-SUMMARY.md

@TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
@TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
@TradingBot.ApiService/Application/BackgroundJobs/MissedPurchaseVerificationService.cs
@TradingBot.ApiService/Infrastructure/Firebase/FcmNotificationService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FCM notifications to PurchaseCompletedHandler and PurchaseFailedHandler</name>
  <files>
    TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
    TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
  </files>
  <action>
    **PurchaseCompletedHandler.cs:**

    1. Add `FcmNotificationService fcmService` to the primary constructor parameters (after `telegramService`).

    2. After the existing `await telegramService.SendMessageAsync(message, cancellationToken);` line, add FCM notification:
       ```csharp
       // Send FCM push notification
       try
       {
           var pushTitle = purchase.IsDryRun ? "[SIM] BTC Purchased" : "BTC Purchased";
           var pushBody = $"{purchase.Quantity.Value:F5} BTC at ${purchase.Price.Value:N2} ({purchase.Multiplier.Value:F1}x)";
           var data = new Dictionary<string, string>
           {
               ["type"] = "purchase_completed",
               ["route"] = "/history"
           };
           await fcmService.SendToAllDevicesAsync(pushTitle, pushBody, data, cancellationToken);
       }
       catch (Exception fcmEx)
       {
           logger.LogError(fcmEx, "Error sending FCM notification for completed purchase");
       }
       ```
       The FCM try/catch is separate from the Telegram try/catch so one failure does not block the other. Both are inside the outer try/catch.

    **PurchaseFailedHandler.cs:**

    1. Add `FcmNotificationService fcmService` to the primary constructor parameters (after `telegramService`).

    2. After the existing `await telegramService.SendMessageAsync(message, cancellationToken);` line, add:
       ```csharp
       // Send FCM push notification
       try
       {
           var pushTitle = "Purchase Failed";
           var pushBody = $"Error: {errorMessage}";
           var data = new Dictionary<string, string>
           {
               ["type"] = "purchase_failed",
               ["route"] = "/home"
           };
           await fcmService.SendToAllDevicesAsync(pushTitle, pushBody, data, cancellationToken);
       }
       catch (Exception fcmEx)
       {
           logger.LogError(fcmEx, "Error sending FCM notification for failed purchase");
       }
       ```

    3. Add `using TradingBot.ApiService.Infrastructure.Firebase;` to both files.

    4. Verify: `dotnet build TradingBot.slnx` succeeds and `dotnet test` passes.
  </action>
  <verify>
    `dotnet build TradingBot.slnx` succeeds. `dotnet test` passes all 62 tests. Both handlers have FcmNotificationService injected and call SendToAllDevicesAsync.
  </verify>
  <done>
    PurchaseCompletedHandler sends FCM push with title "BTC Purchased", body showing quantity/price/multiplier, and data {type: "purchase_completed", route: "/history"}. PurchaseFailedHandler sends FCM push with title "Purchase Failed", body showing error reason, and data {type: "purchase_failed", route: "/home"}. Build and tests green.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add FCM notification to MissedPurchaseVerificationService with 36-hour threshold</name>
  <files>
    TradingBot.ApiService/Application/BackgroundJobs/MissedPurchaseVerificationService.cs
  </files>
  <action>
    The existing MissedPurchaseVerificationService checks ~40 minutes after daily buy time for a missed purchase. For PUSH-02 (no purchase in >36 hours), we enhance this service to also check the 36-hour gap condition.

    1. Add `using TradingBot.ApiService.Infrastructure.Firebase;` import.

    2. In the `ProcessAsync` method, after the existing Telegram alert `await telegramService.SendMessageAsync(message, cancellationToken);`:
       - Resolve `FcmNotificationService` from the service scope:
         ```csharp
         var fcmService = scope.ServiceProvider.GetRequiredService<FcmNotificationService>();
         ```

    3. After the existing Telegram send, add FCM notification:
       ```csharp
       // Send FCM push notification for missed purchase
       try
       {
           var pushTitle = "Missed Purchase Alert";
           var pushBody = "No BTC purchase recorded today. Check bot status.";
           var data = new Dictionary<string, string>
           {
               ["type"] = "missed_purchase",
               ["route"] = "/home"
           };
           await fcmService.SendToAllDevicesAsync(pushTitle, pushBody, data, cancellationToken);
       }
       catch (Exception fcmEx)
       {
           logger.LogError(fcmEx, "Error sending FCM notification for missed purchase");
       }
       ```

    4. Additionally, add a 36-hour gap check at the beginning of ProcessAsync (before the daily verification logic). This handles the PUSH-02 requirement for >36h with no purchase:
       - Query the most recent successful purchase:
         ```csharp
         var lastPurchase = await dbContext.Purchases
             .Where(p => p.Status == PurchaseStatus.Filled || p.Status == PurchaseStatus.PartiallyFilled)
             .Where(p => !p.IsDryRun)
             .OrderByDescending(p => p.ExecutedAt)
             .FirstOrDefaultAsync(cancellationToken);
         ```
       - If `lastPurchase != null && (now - lastPurchase.ExecutedAt) > TimeSpan.FromHours(36)`:
         - Check a new field `_lastGapAlertDate` (DateOnly, similar to `_lastAlertSent`) to avoid duplicate gap alerts on the same day
         - If not already alerted today, send Telegram + FCM with title "No Purchase in 36+ Hours" and body showing time since last purchase
         - Set `_lastGapAlertDate = today`
       - This check runs independently of and before the daily verification window check, so it catches gaps even on weekends or when the daily window has already passed.

    5. Verify: `dotnet build TradingBot.slnx` succeeds and `dotnet test` passes.
  </action>
  <verify>
    `dotnet build TradingBot.slnx` succeeds. `dotnet test` passes all 62 tests. MissedPurchaseVerificationService sends FCM push for both daily missed purchase and 36-hour gap scenarios.
  </verify>
  <done>
    MissedPurchaseVerificationService sends FCM push notification alongside Telegram for missed daily purchases. Additionally, a 36-hour gap check alerts the user if no purchase has been recorded in over 36 hours. Both alerts include data payload with type and route for deep-linking. Build and tests green.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.slnx` succeeds
2. `dotnet test` passes all existing tests
3. PurchaseCompletedHandler sends FCM with type "purchase_completed" and route "/history"
4. PurchaseFailedHandler sends FCM with type "purchase_failed" and route "/home"
5. MissedPurchaseVerificationService sends FCM with type "missed_purchase" and route "/home"
6. All FCM sends have separate try/catch from Telegram sends (one failure does not block the other)
7. All push notification data payloads include "type" and "route" keys
</verification>

<success_criteria>
- Three notification trigger points (purchase completed, purchase failed, missed purchase) all send FCM push notifications
- Push notification bodies are concise and show key information (amount, price, multiplier for completed; error for failed; time since last purchase for missed)
- Deep-link data payloads are included for Flutter to route to the correct screen
- 36-hour gap detection is implemented alongside existing daily missed purchase check
- Telegram notifications continue to work unchanged alongside FCM
- All 62 existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/24-push-notifications/24-02-SUMMARY.md`
</output>
