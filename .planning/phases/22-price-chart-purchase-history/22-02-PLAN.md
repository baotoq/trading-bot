---
phase: 22-price-chart-purchase-history
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.Mobile/lib/features/history/data/models/purchase_history_response.dart
  - TradingBot.Mobile/lib/features/history/data/history_repository.dart
  - TradingBot.Mobile/lib/features/history/data/history_providers.dart
  - TradingBot.Mobile/lib/features/history/data/history_providers.g.dart
  - TradingBot.Mobile/lib/features/history/presentation/history_screen.dart
  - TradingBot.Mobile/lib/features/history/presentation/widgets/purchase_list_item.dart
  - TradingBot.Mobile/lib/features/history/presentation/widgets/filter_bottom_sheet.dart
autonomous: true
requirements:
  - CHART-05
  - CHART-06

must_haves:
  truths:
    - "User can scroll through the full purchase history and new pages load automatically as they scroll near the bottom"
    - "User can open a bottom sheet to filter purchase history by date range and multiplier tier, and applying the filter resets the list"
    - "Each purchase list item shows date, price, BTC amount, cost, multiplier tier badge, and drop percentage"
    - "A loading indicator appears at the bottom of the list while the next page loads"
  artifacts:
    - path: "TradingBot.Mobile/lib/features/history/data/models/purchase_history_response.dart"
      provides: "PurchaseHistoryResponse and PurchaseDto Dart models matching backend DTOs"
      contains: "PurchaseHistoryResponse"
    - path: "TradingBot.Mobile/lib/features/history/data/history_repository.dart"
      provides: "HistoryRepository with fetchPurchases(cursor, startDate, endDate, tier, pageSize)"
      contains: "fetchPurchases"
    - path: "TradingBot.Mobile/lib/features/history/data/history_providers.dart"
      provides: "PurchaseHistory AsyncNotifier with loadNextPage() and applyFilter() methods"
      contains: "PurchaseHistory"
    - path: "TradingBot.Mobile/lib/features/history/presentation/widgets/purchase_list_item.dart"
      provides: "PurchaseListItem widget displaying purchase details"
      contains: "PurchaseListItem"
    - path: "TradingBot.Mobile/lib/features/history/presentation/widgets/filter_bottom_sheet.dart"
      provides: "FilterBottomSheet StatefulWidget with date range picker and tier chip selection"
      contains: "FilterBottomSheet"
    - path: "TradingBot.Mobile/lib/features/history/presentation/history_screen.dart"
      provides: "HistoryScreen with infinite scroll list and filter FAB"
      contains: "HistoryScreen"
  key_links:
    - from: "TradingBot.Mobile/lib/features/history/presentation/history_screen.dart"
      to: "purchaseHistoryProvider"
      via: "ref.watch + ref.read(purchaseHistoryProvider.notifier).loadNextPage()"
      pattern: "purchaseHistoryProvider"
    - from: "TradingBot.Mobile/lib/features/history/data/history_providers.dart"
      to: "/api/dashboard/purchases"
      via: "HistoryRepository.fetchPurchases with cursor param"
      pattern: "fetchPurchases"
    - from: "TradingBot.Mobile/lib/features/history/presentation/widgets/filter_bottom_sheet.dart"
      to: "purchaseHistoryProvider"
      via: "onApply callback calling provider.applyFilter()"
      pattern: "applyFilter"
---

<objective>
Implement the purchase history screen with infinite scroll using cursor pagination, purchase list items with full details, and a filter bottom sheet for date range and multiplier tier filtering.

Purpose: Allow users to browse their complete purchase history efficiently and filter by relevant criteria.
Output: Fully functional history screen with data layer (models, repository, AsyncNotifier provider) and presentation layer (list items, filter sheet, assembled screen with infinite scroll).
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-price-chart-purchase-history/22-RESEARCH.md

@TradingBot.Mobile/lib/features/home/data/home_providers.dart
@TradingBot.Mobile/lib/features/home/data/home_repository.dart
@TradingBot.Mobile/lib/features/home/data/models/portfolio_response.dart
@TradingBot.Mobile/lib/app/theme.dart
@TradingBot.Mobile/lib/core/api/api_client.dart
@TradingBot.Mobile/lib/core/widgets/error_snackbar.dart
@TradingBot.Mobile/lib/core/widgets/retry_widget.dart
@TradingBot.ApiService/Endpoints/DashboardDtos.cs
@TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: History data layer (models, repository, AsyncNotifier with cursor pagination)</name>
  <files>
    TradingBot.Mobile/lib/features/history/data/models/purchase_history_response.dart
    TradingBot.Mobile/lib/features/history/data/history_repository.dart
    TradingBot.Mobile/lib/features/history/data/history_providers.dart
  </files>
  <action>
1. Create `purchase_history_response.dart` with manual fromJson (matching Phase 21 pattern):
   - `PurchaseHistoryResponse` with fields: `List<PurchaseDto> items`, `String? nextCursor`, `bool hasMore`.
     - `factory fromJson(Map<String, dynamic> json)` — parse `items` as `(json['items'] as List).map((e) => PurchaseDto.fromJson(e as Map<String, dynamic>)).toList()`, `nextCursor` as `json['nextCursor'] as String?`, `hasMore` as `json['hasMore'] as bool`.
   - `PurchaseDto` with fields: `String id`, `DateTime executedAt`, `double price`, `double cost`, `double quantity`, `String multiplierTier`, `double multiplier`, `double dropPercentage`.
     - `factory fromJson(Map<String, dynamic> json)`:
       - `id`: `json['id'] as String`
       - `executedAt`: `DateTime.parse(json['executedAt'] as String)`
       - `price`: `(json['price'] as num).toDouble()`
       - `cost`: `(json['cost'] as num).toDouble()`
       - `quantity`: `(json['quantity'] as num).toDouble()`
       - `multiplierTier`: `json['multiplierTier'] as String`
       - `multiplier`: `(json['multiplier'] as num).toDouble()`
       - `dropPercentage`: `(json['dropPercentage'] as num).toDouble()`

2. Create `history_repository.dart`:
   - `HistoryRepository` taking `Dio _dio` in constructor.
   - Method: `Future<PurchaseHistoryResponse> fetchPurchases({String? cursor, DateTime? startDate, DateTime? endDate, String? tier, int pageSize = 20})`.
   - Build query parameters map: `{'pageSize': pageSize}`. Conditionally add `cursor`, `startDate` (formatted as `DateFormat('yyyy-MM-dd').format(startDate)` using intl), `endDate` (same format), `tier` (only if not null and not empty).
   - Call `_dio.get('/api/dashboard/purchases', queryParameters: params)`.
   - Return `PurchaseHistoryResponse.fromJson(response.data)`.

3. Create `history_providers.dart`:
   - Add `part 'history_providers.g.dart';` directive.
   - `@riverpod HistoryRepository historyRepository(Ref ref)` — returns `HistoryRepository(ref.watch(dioProvider))`.
   - `@riverpod class PurchaseHistory extends _$PurchaseHistory`:
     - Private fields: `String? _nextCursor`, `bool _hasMore = true`, `DateTimeRange? _dateRange`, `String? _tierFilter`.
     - Public getter: `bool get hasMore => _hasMore`.
     - `@override Future<List<PurchaseDto>> build() async` — reset `_nextCursor = null`, `_hasMore = true`, call `_fetchPage(cursor: null)` and return result.
     - `Future<void> loadNextPage() async` — guard: `if (!_hasMore || state.isLoading) return;`. Get `current = state.requireValue`. Set `state = const AsyncLoading<List<PurchaseDto>>().copyWithPrevious(AsyncData(current))`. Then `state = await AsyncValue.guard(() async { final page = await _fetchPage(cursor: _nextCursor); return [...current, ...page]; })`.
     - `void applyFilter({DateTimeRange? dateRange, String? tier})` — set `_dateRange = dateRange`, `_tierFilter = tier`, call `ref.invalidateSelf()` to re-trigger `build()` which resets cursor.
     - `void clearFilters()` — set `_dateRange = null`, `_tierFilter = null`, call `ref.invalidateSelf()`.
     - Private helper: `Future<List<PurchaseDto>> _fetchPage({String? cursor}) async` — `final repo = ref.read(historyRepositoryProvider)`, call `repo.fetchPurchases(cursor: cursor, startDate: _dateRange?.start, endDate: _dateRange?.end, tier: _tierFilter)`, update `_nextCursor` and `_hasMore` from response, return `response.items`.

4. Run `dart run build_runner build --delete-conflicting-outputs` from TradingBot.Mobile/ to generate `history_providers.g.dart`.
  </action>
  <verify>
    Run `dart run build_runner build --delete-conflicting-outputs` from TradingBot.Mobile/ — must complete with no errors. Run `dart analyze lib/features/history/` — zero errors.
  </verify>
  <done>
    PurchaseHistoryResponse and PurchaseDto models exist with fromJson. HistoryRepository calls /api/dashboard/purchases with cursor and filter params. PurchaseHistory AsyncNotifier supports loadNextPage(), applyFilter(), clearFilters() with correct cursor/hasMore state management. All generated and lint-clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: History UI (purchase list item, filter bottom sheet, HistoryScreen with infinite scroll)</name>
  <files>
    TradingBot.Mobile/lib/features/history/presentation/widgets/purchase_list_item.dart
    TradingBot.Mobile/lib/features/history/presentation/widgets/filter_bottom_sheet.dart
    TradingBot.Mobile/lib/features/history/presentation/history_screen.dart
  </files>
  <action>
1. Create `purchase_list_item.dart`:
   - `PurchaseListItem` StatelessWidget taking `PurchaseDto purchase`.
   - Renders a `Card` (or `Container` with subtle border) with a `Column` or `Row`-based layout:
     - **Top row**: Date formatted via `DateFormat('MMM d, yyyy').format(purchase.executedAt)` on the left, relative time via `timeago.format(purchase.executedAt)` on the right (dimmed).
     - **Middle row**: Price (`$XX,XXX` using `NumberFormat.currency(symbol: '\$', decimalDigits: 0)`) prominent on left. BTC amount (`0.00XXXXX BTC` using `NumberFormat('0.00000000')`) on right.
     - **Bottom row**: Cost (`$XX.XX` using `NumberFormat.currency(symbol: '\$', decimalDigits: 2)`) on left. Multiplier tier as a small `Container` badge (text color based on tier: Base=AppTheme.bitcoinOrange, 2x=Colors.amber, 3x=Colors.orange, 4x=AppTheme.lossRed) with the tier label (e.g., "2x"). Drop percentage formatted as e.g., "-5.2%" if > 0, or "--" if dropPercentage is 0.
   - Use `const` constructors where possible. Padding 12-16dp. Card background: slightly lighter than scaffold (e.g., `Color(0xFF1E1E1E)`).

2. Create `filter_bottom_sheet.dart`:
   - `FilterBottomSheet` StatefulWidget taking `void Function(DateTimeRange? dateRange, String? tier) onApply`, and optional `DateTimeRange? initialDateRange` and `String? initialTier` for pre-populating current filters.
   - State fields: `DateTimeRange? _selectedRange`, `String? _selectedTier`. Initialize from initial params in `initState`.
   - **Date range section**: A row with label "Date Range" and a tappable `TextButton` showing selected range (e.g., "Jan 1 - Jun 30") or "Any". Tapping opens `showDateRangePicker(context: context, firstDate: DateTime(2020), lastDate: DateTime.now(), initialDateRange: _selectedRange)`. On result, `setState` to update `_selectedRange`. Include a clear (X) icon button to reset to null.
   - **Tier section**: A row of `ChoiceChip` widgets for tiers: `['All', 'Base', '2x', '3x', '4x']`. "All" maps to `null` tier filter. Selected chip highlighted with `AppTheme.bitcoinOrange`.
   - **Action row**: "Clear All" text button (resets both filters to null) and "Apply" filled button. Apply calls `onApply(_selectedRange, _selectedTier == 'All' ? null : _selectedTier)` and `Navigator.pop(context)`.
   - Wrap in `Padding` with 16dp all around. Use `DraggableScrollableSheet` or just simple `Column` inside the bottom sheet. Set `isScrollControlled: true` on the parent `showModalBottomSheet`.

3. Update `history_screen.dart` (replace existing placeholder):
   - Make it a `ConsumerStatefulWidget` (needs StatefulWidget for scroll controller lifecycle).
   - In state: `late final ScrollController _scrollController`. In `initState`, create controller. In `dispose`, dispose controller.
   - Add scroll listener in `initState`: `_scrollController.addListener(() { if (_scrollController.position.pixels >= _scrollController.position.maxScrollExtent - 200) { ref.read(purchaseHistoryProvider.notifier).loadNextPage(); } })`.
   - `build()`: Watch `purchaseHistoryProvider`. Extract `cachedValue` before switch for stale cache pattern.
   - Layout: `Scaffold` with `floatingActionButton: FloatingActionButton.small(onPressed: _openFilter, backgroundColor: AppTheme.bitcoinOrange, child: Icon(CupertinoIcons.slider_horizontal_3))`.
   - Body: `RefreshIndicator(onRefresh: () { ref.invalidate(purchaseHistoryProvider); return ref.read(purchaseHistoryProvider.future); })` wrapping the main content.
   - AsyncValue switch:
     - `AsyncData` (or cached): `ListView.builder(controller: _scrollController, itemCount: items.length + (hasMore ? 1 : 0), itemBuilder: ...)`. For `index == items.length` (loading more indicator): `Center(child: Padding(padding: 16, child: CircularProgressIndicator()))`. Otherwise: `PurchaseListItem(purchase: items[index])`.
     - `AsyncLoading` (no cached): `Center(child: CircularProgressIndicator())`.
     - `AsyncError` (no cached): `RetryWidget(onRetry: () => ref.invalidate(purchaseHistoryProvider))`.
   - Use `ref.listen` for error snackbar on background errors while stale data shown.
   - `_openFilter` method: `showModalBottomSheet(context: context, isScrollControlled: true, builder: (_) => FilterBottomSheet(onApply: (dateRange, tier) { ref.read(purchaseHistoryProvider.notifier).applyFilter(dateRange: dateRange, tier: tier); }, initialDateRange: /* current filter from notifier if accessible, or null */, initialTier: /* current tier from notifier if accessible, or null */))`.
   - Note: To access current filter state from the notifier, either expose getters on the PurchaseHistory notifier or track filter state locally in the screen. Prefer tracking locally in ConsumerStatefulWidget state (simpler, avoids exposing notifier internals).
   - When no purchases and no filters, show an empty state message: "No purchases yet".
  </action>
  <verify>
    Run `dart analyze lib/features/history/` from TradingBot.Mobile/ — zero errors. Run `flutter build ios --no-codesign --dart-define=API_BASE_URL=http://localhost --dart-define=API_KEY=test` — must compile without errors.
  </verify>
  <done>
    HistoryScreen renders a ListView.builder with infinite scroll that loads more pages as user scrolls near bottom. Each PurchaseListItem shows date, price, BTC amount, cost, tier badge, and drop percentage. Filter FAB opens FilterBottomSheet with date range picker and tier chips. Applying filter resets list via applyFilter(). Pull-to-refresh reloads from page 1. Loading indicator appears at list bottom during page loads.
  </done>
</task>

</tasks>

<verification>
1. `dart analyze lib/features/history/` — zero errors, zero warnings.
2. `flutter build ios --no-codesign --dart-define=API_BASE_URL=http://localhost --dart-define=API_KEY=test` — compiles clean.
3. `dart run build_runner build --delete-conflicting-outputs` — generates history_providers.g.dart without conflicts.
4. History screen is reachable via the existing /history route in go_router (already wired in Phase 20).
</verification>

<success_criteria>
- PurchaseHistoryResponse and PurchaseDto models match backend DTO fields
- HistoryRepository calls /api/dashboard/purchases with cursor, startDate, endDate, tier query params
- PurchaseHistory AsyncNotifier correctly accumulates pages via loadNextPage() with cursor state
- applyFilter() resets cursor and re-fetches via ref.invalidateSelf()
- PurchaseListItem shows all purchase details (date, price, BTC, cost, tier badge, drop %)
- FilterBottomSheet has date range picker and tier chip selection with Apply/Clear
- HistoryScreen uses ScrollController with scroll-end detection for automatic page loading
- Loading indicator visible at bottom of list during page loads
- Pull-to-refresh resets to first page
- All dart analyze passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/22-price-chart-purchase-history/22-02-SUMMARY.md`
</output>
