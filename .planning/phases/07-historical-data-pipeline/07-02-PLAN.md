---
phase: 07-historical-data-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - TradingBot.ApiService/Program.cs
  - TradingBot.ApiService/Application/Services/HistoricalData/Models/DataStatusResponse.cs
  - TradingBot.ApiService/Application/Services/HistoricalData/Models/IngestResponse.cs
  - TradingBot.ApiService/Application/Services/HistoricalData/Models/JobStatusResponse.cs
  - TradingBot.ApiService/Endpoints/DataEndpoints.cs
  - TradingBot.ApiService/appsettings.json
autonomous: true

must_haves:
  truths:
    - "POST /api/backtest/data/ingest creates an ingestion job and returns job ID + estimated completion time"
    - "POST /api/backtest/data/ingest rejects requests if a job is already running (409 Conflict)"
    - "POST /api/backtest/data/ingest supports force=true query parameter to re-fetch existing dates"
    - "GET /api/backtest/data/status returns date range, total days, gap count, gap dates, coverage %, freshness, last ingestion info"
    - "GET /api/backtest/data/status returns helpful message when no data exists"
    - "GET /api/backtest/data/ingest/{jobId} returns job status, progress, timestamps, records fetched, gaps detected"
    - "All services are registered in DI container and background service starts on app launch"
  artifacts:
    - path: "TradingBot.ApiService/Endpoints/DataEndpoints.cs"
      provides: "All three API endpoints mapped via minimal API extension method"
    - path: "TradingBot.ApiService/Application/Services/HistoricalData/Models/DataStatusResponse.cs"
      provides: "Rich response DTO for GET /data/status"
    - path: "TradingBot.ApiService/Application/Services/HistoricalData/Models/IngestResponse.cs"
      provides: "Response DTO for POST /data/ingest with job ID and estimated time"
    - path: "TradingBot.ApiService/Application/Services/HistoricalData/Models/JobStatusResponse.cs"
      provides: "Response DTO for GET /data/ingest/{jobId} with progress"
    - path: "TradingBot.ApiService/Program.cs"
      provides: "DI registration for CoinGecko, HistoricalData services, and endpoint mapping"
  key_links:
    - from: "DataEndpoints POST /ingest"
      to: "IngestionJobQueue.TryEnqueueAsync"
      via: "Creates IngestionJob in DB then enqueues job ID"
    - from: "DataEndpoints GET /status"
      to: "GapDetectionService.GetCoverageStatsAsync"
      via: "Queries coverage stats and last ingestion job"
    - from: "DataEndpoints GET /ingest/{jobId}"
      to: "TradingBotDbContext.IngestionJobs"
      via: "Loads job by ID and returns status DTO"
    - from: "Program.cs"
      to: "ServiceCollectionExtensions.AddCoinGecko"
      via: "DI registration"
    - from: "Program.cs"
      to: "DataEndpoints.MapDataEndpoints"
      via: "Minimal API endpoint mapping"
---

<objective>
Create the API endpoints (POST /ingest, GET /status, GET /ingest/{jobId}), response DTOs, DI registration in Program.cs, and configuration to expose the historical data pipeline via HTTP.

Purpose: This plan connects the backend infrastructure from Plan 01 to the outside world via three minimal API endpoints. Users can trigger data ingestion, check data status/completeness, and poll job progress. All services are wired into the DI container and the background service starts automatically.

Output: DataEndpoints with 3 routes, response DTOs, DI wiring in Program.cs, appsettings.json configuration section.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-historical-data-pipeline/07-CONTEXT.md
@.planning/phases/07-historical-data-pipeline/07-RESEARCH.md
@.planning/phases/07-historical-data-pipeline/07-01-SUMMARY.md

# Key source files from Plan 01
@TradingBot.ApiService/Models/IngestionJob.cs
@TradingBot.ApiService/Infrastructure/CoinGecko/ServiceCollectionExtensions.cs
@TradingBot.ApiService/Application/Services/HistoricalData/GapDetectionService.cs
@TradingBot.ApiService/Application/Services/HistoricalData/DataIngestionService.cs
@TradingBot.ApiService/Application/Services/HistoricalData/IngestionJobQueue.cs
@TradingBot.ApiService/Application/Services/HistoricalData/DataIngestionBackgroundService.cs
@TradingBot.ApiService/Application/Services/HistoricalData/Models/IngestionJobStatus.cs
@TradingBot.ApiService/Application/Services/HistoricalData/Models/DataCoverageStats.cs
@TradingBot.ApiService/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create response DTOs, DataEndpoints with all three routes, and DI wiring</name>
  <files>
    TradingBot.ApiService/Application/Services/HistoricalData/Models/DataStatusResponse.cs
    TradingBot.ApiService/Application/Services/HistoricalData/Models/IngestResponse.cs
    TradingBot.ApiService/Application/Services/HistoricalData/Models/JobStatusResponse.cs
    TradingBot.ApiService/Endpoints/DataEndpoints.cs
    TradingBot.ApiService/Program.cs
    TradingBot.ApiService/appsettings.json
  </files>
  <action>
    **1. Create DataStatusResponse record** at `Application/Services/HistoricalData/Models/DataStatusResponse.cs`:
    Per locked decision -- rich info including: date range, total days, gaps, coverage, freshness, last ingestion.
    ```csharp
    public record DataStatusResponse
    {
        public required string Symbol { get; init; }
        public bool HasData { get; init; }
        public DateOnly? StartDate { get; init; }
        public DateOnly? EndDate { get; init; }
        public int TotalDaysStored { get; init; }
        public int GapCount { get; init; }
        public List<DateOnly> GapDates { get; init; } = [];  // First 20 gaps
        public decimal CoveragePercent { get; init; }
        public string Freshness { get; init; } = "";  // "Fresh" / "Recent" / "Stale"
        public int DaysSinceLastData { get; init; }
        public IngestionJobSummary? LastIngestion { get; init; }
        public string DataSource { get; init; } = "CoinGecko Free API";
        public required string Message { get; init; }
    }

    public record IngestionJobSummary
    {
        public Guid JobId { get; init; }
        public required string Status { get; init; }
        public DateTimeOffset? CompletedAt { get; init; }
        public int RecordsFetched { get; init; }
        public int GapsDetected { get; init; }
        public string? ErrorMessage { get; init; }
    }
    ```

    **2. Create IngestResponse record** at `Application/Services/HistoricalData/Models/IngestResponse.cs`:
    Per locked decision -- returns job ID + estimated completion time.
    ```csharp
    public record IngestResponse(Guid JobId, DateTimeOffset EstimatedCompletion, string Message);
    ```

    **3. Create JobStatusResponse record** at `Application/Services/HistoricalData/Models/JobStatusResponse.cs`:
    For dedicated polling endpoint (Claude's discretion: dedicated endpoint for cleaner separation).
    ```csharp
    public record JobStatusResponse
    {
        public Guid JobId { get; init; }
        public required string Status { get; init; }
        public DateTimeOffset CreatedAt { get; init; }
        public DateTimeOffset? StartedAt { get; init; }
        public DateTimeOffset? CompletedAt { get; init; }
        public DateOnly StartDate { get; init; }
        public DateOnly EndDate { get; init; }
        public bool Force { get; init; }
        public int RecordsFetched { get; init; }
        public int GapsDetected { get; init; }
        public string? ErrorMessage { get; init; }
        public int ProgressPercent { get; init; }  // 0-100
    }
    ```

    **4. Create DataEndpoints** at `Endpoints/DataEndpoints.cs`:
    Use minimal API extension method pattern.

    ```csharp
    public static class DataEndpoints
    {
        public static WebApplication MapDataEndpoints(this WebApplication app)
        {
            var group = app.MapGroup("/api/backtest/data");
            group.MapPost("/ingest", IngestAsync);
            group.MapGet("/status", GetStatusAsync);
            group.MapGet("/ingest/{jobId:guid}", GetJobStatusAsync);
            return app;
        }
    }
    ```

    **POST /api/backtest/data/ingest** handler (`IngestAsync`):
    - Accept query parameter `bool force = false`
    - Resolve `TradingBotDbContext` and `IngestionJobQueue` from DI
    - Check for running job: query IngestionJobs where Status == Running or Pending. If found, return `Results.Conflict(new { error = "Ingestion already running", jobId = existingJob.Id })`
    - Create new IngestionJob: StartDate = DateOnly.FromDateTime(DateTime.UtcNow.AddYears(-4)), EndDate = DateOnly.FromDateTime(DateTime.UtcNow), Force = force, Status = Pending
    - Save to DB
    - Enqueue job ID via `jobQueue.TryEnqueueAsync(job.Id)`. If TryEnqueue returns false, set job to Failed and return Conflict (queue full -- defensive, shouldn't happen given DB check)
    - Calculate estimated completion: 4 years = ~1460 days, 90-day chunks = ~17 API calls, 2.5s per call = ~43 seconds for API calls + processing overhead. Round to ~2 minutes estimated.
    - Return `Results.Accepted($"/api/backtest/data/ingest/{job.Id}", new IngestResponse(job.Id, estimatedCompletion, "Ingestion job created. Poll GET /api/backtest/data/ingest/{job.Id} for status."))`

    **GET /api/backtest/data/status** handler (`GetStatusAsync`):
    - Resolve `TradingBotDbContext` and `GapDetectionService`
    - Query min/max Date from DailyPrices where Symbol == "BTC"
    - If no data: return `Results.Ok(new DataStatusResponse { Symbol = "BTC", HasData = false, Message = "No data available. Run POST /api/backtest/data/ingest to fetch historical data." })`
    - If data exists:
      - Get coverage stats via `gapDetection.GetCoverageStatsAsync(minDate, maxDate, "BTC", ct)`
      - Get last ingestion job (OrderByDescending CreatedAt, FirstOrDefault)
      - Calculate freshness: daysSinceLastData = (today - maxDate).Days
        - <= 2 days: "Fresh"
        - <= 7 days: "Recent"
        - > 7 days: "Stale"
      - Build DataStatusResponse with all fields:
        - GapDates limited to first 20 (`.Take(20).ToList()`)
        - Message: if gaps > 0, warn about gaps; otherwise "Data is complete and ready for backtesting."
        - LastIngestion: mapped from job entity to IngestionJobSummary

    **GET /api/backtest/data/ingest/{jobId}** handler (`GetJobStatusAsync`):
    - Resolve `TradingBotDbContext`
    - Load IngestionJob by jobId. If not found, return `Results.NotFound(new { error = "Job not found" })`
    - Calculate ProgressPercent:
      - Failed: 0
      - Completed/CompletedWithGaps: 100
      - Pending: 0
      - Running: estimate based on elapsed time. If StartedAt is set, calculate rough progress:
        - Total days in range = (EndDate - StartDate).Days
        - Total chunks = Math.Ceiling(totalDays / 90.0)
        - Estimated total seconds = totalChunks * 2.5 (API call delay)
        - Elapsed seconds = (now - StartedAt).TotalSeconds
        - Progress = Math.Min((int)(elapsed / estimatedTotal * 100), 99) -- cap at 99 until actually done
    - Return JobStatusResponse with all fields

    **5. Update Program.cs** -- add DI registrations and endpoint mapping:

    Add after existing service registrations (after `builder.Services.AddHostedService<MissedPurchaseVerificationService>()`):
    ```csharp
    // CoinGecko API client for historical price data
    builder.Services.AddCoinGecko(builder.Configuration);

    // Historical data pipeline
    builder.Services.AddSingleton<IngestionJobQueue>();
    builder.Services.AddScoped<GapDetectionService>();
    builder.Services.AddScoped<DataIngestionService>();
    builder.Services.AddHostedService<DataIngestionBackgroundService>();
    ```

    Add endpoint mapping after `app.MapDefaultEndpoints()`:
    ```csharp
    app.MapDataEndpoints();
    ```

    Add required using statements at top of Program.cs:
    ```csharp
    using TradingBot.ApiService.Application.Services.HistoricalData;
    using TradingBot.ApiService.Infrastructure.CoinGecko;
    ```

    **6. Add CoinGecko configuration section** to `appsettings.json`:
    ```json
    "CoinGecko": {
      "ApiKey": ""
    }
    ```
    (Empty string = free tier. Optional key for paid tier in future.)

    **7. Verify build and endpoint mapping:**
    Run `dotnet build TradingBot.ApiService` and fix any compilation errors. Verify all three endpoints are defined in DataEndpoints.cs.
  </action>
  <verify>
    1. `dotnet build TradingBot.ApiService` compiles with zero errors
    2. All response DTO files exist in Application/Services/HistoricalData/Models/
    3. Endpoints/DataEndpoints.cs contains all three route handlers
    4. Program.cs registers CoinGecko services, HistoricalData services, and maps endpoints
    5. appsettings.json has CoinGecko section
    6. `dotnet test` -- all existing 53 tests still pass (no regressions)
  </verify>
  <done>
    Three API endpoints are functional: POST /api/backtest/data/ingest (creates job, returns ID + ETA), GET /api/backtest/data/status (rich data coverage info), GET /api/backtest/data/ingest/{jobId} (job polling with progress). All services registered in DI. Background service starts on app launch. Existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.ApiService` -- zero errors
2. `dotnet test` -- all 53 existing tests pass (no regressions)
3. All endpoint response DTOs exist:
   - Application/Services/HistoricalData/Models/DataStatusResponse.cs
   - Application/Services/HistoricalData/Models/IngestResponse.cs
   - Application/Services/HistoricalData/Models/JobStatusResponse.cs
4. Endpoints/DataEndpoints.cs has 3 routes: POST /ingest, GET /status, GET /ingest/{jobId}
5. Program.cs has:
   - `builder.Services.AddCoinGecko(builder.Configuration)`
   - `builder.Services.AddSingleton<IngestionJobQueue>()`
   - `builder.Services.AddScoped<GapDetectionService>()`
   - `builder.Services.AddScoped<DataIngestionService>()`
   - `builder.Services.AddHostedService<DataIngestionBackgroundService>()`
   - `app.MapDataEndpoints()`
6. appsettings.json has CoinGecko configuration section
</verification>

<success_criteria>
- POST /api/backtest/data/ingest creates a job, enqueues it, and returns job ID with estimated completion time
- POST /api/backtest/data/ingest returns 409 Conflict if a job is already running or pending
- POST /api/backtest/data/ingest supports force=true to re-fetch existing data
- GET /api/backtest/data/status returns rich data coverage info (date range, gaps, coverage %, freshness, last ingestion)
- GET /api/backtest/data/status returns helpful empty state message when no data exists
- GET /api/backtest/data/ingest/{jobId} returns job progress with estimated completion percentage
- All services are registered in DI and BackgroundService starts automatically
- All existing 53 tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/07-historical-data-pipeline/07-02-SUMMARY.md`
</output>
