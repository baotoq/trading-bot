---
phase: 17-domain-event-dispatch
plan: 02
type: execute
wave: 2
depends_on:
  - 17-01
files_modified:
  - TradingBot.ApiService/BuildingBlocks/Pubsub/Dapr/ServiceCollectionExtensions.cs
  - TradingBot.ApiService/BuildingBlocks/Pubsub/Dapr/WebApplicationExtensions.cs
  - TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/IDomainEventPublisher.cs
  - TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/DomainEventPublisher.cs
  - TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/DeadLetterMessage.cs
  - TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/OutboxMessageProcessor.cs
  - TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/EfCore/EfCoreOutboxStore.cs
  - TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/Abstraction/IOutboxStore.cs
  - TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/ServiceCollectionExtensions.cs
  - TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
  - TradingBot.ApiService/Program.cs
autonomous: true
requirements:
  - DE-03

must_haves:
  truths:
    - "PubSubRegistry accepts domain event types (not just IntegrationEvent) via relaxed generic constraint"
    - "AddDaprPubSub() and AddOutboxPublishingWithEfCore() are wired in Program.cs"
    - "MapPubSub deserializes domain events by Type (not just IntegrationEvent cast)"
    - "IDomainEventPublisher.PublishDirectAsync creates OutboxMessage for non-aggregate events"
    - "Failed outbox messages (3+ retries) move to DeadLetterMessage table"
  artifacts:
    - path: "TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/IDomainEventPublisher.cs"
      provides: "Interface for publishing non-aggregate domain events to outbox"
      contains: "PublishDirectAsync"
    - path: "TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/DomainEventPublisher.cs"
      provides: "Implementation that creates OutboxMessage and saves"
      contains: "class DomainEventPublisher"
    - path: "TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/DeadLetterMessage.cs"
      provides: "Dead-letter entity for failed outbox messages"
      contains: "class DeadLetterMessage"
  key_links:
    - from: "TradingBot.ApiService/BuildingBlocks/Pubsub/Dapr/WebApplicationExtensions.cs"
      to: "TradingBot.ApiService/BuildingBlocks/IDomainEvent.cs"
      via: "Deserialization by sub.EventType instead of IntegrationEvent cast"
      pattern: "Deserialize.*sub.EventType"
    - from: "TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/OutboxMessageProcessor.cs"
      to: "TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/DeadLetterMessage.cs"
      via: "Move to dead-letter on RetryCount >= 3"
      pattern: "DeadLetterMessage"
    - from: "TradingBot.ApiService/Program.cs"
      to: "TradingBot.ApiService/BuildingBlocks/Pubsub/Dapr/ServiceCollectionExtensions.cs"
      via: "AddDaprPubSub + AddOutboxPublishingWithEfCore registration"
      pattern: "AddDaprPubSub|AddOutboxPublishingWithEfCore"
---

<objective>
Wire the Dapr pub-sub and outbox infrastructure in Program.cs, generalize PubSubRegistry to accept domain events, create the direct event publisher for non-aggregate events, and add dead-letter support.

Purpose: Completes the event dispatch pipeline -- domain events in the outbox get published via Dapr to subscriber endpoints. Non-aggregate events (PurchaseSkippedEvent) can be published directly. Failed messages land in a dead-letter table for inspection.

Output: Wired Dapr+outbox in Program.cs, generalized PubSubRegistry, IDomainEventPublisher, DeadLetterMessage entity, updated OutboxMessageProcessor
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-domain-event-dispatch/17-RESEARCH.md
@.planning/phases/17-domain-event-dispatch/17-01-SUMMARY.md

@TradingBot.ApiService/BuildingBlocks/Pubsub/Dapr/ServiceCollectionExtensions.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Dapr/WebApplicationExtensions.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/OutboxMessage.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/OutboxMessageProcessor.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/OutboxMessageBackgroundService.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/ServiceCollectionExtensions.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/OutboxEventPublisher.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/EfCore/EfCoreOutboxStore.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/EfCore/EfCoreOutboxMessageModelBuilderExtensions.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/Abstraction/IOutboxStore.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/Abstraction/IOutboxMessageProcessor.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Abstraction/IntegrationEvent.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Abstraction/IEventPublisher.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Abstraction/IMessageBroker.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Dapr/DaprMessageBroker.cs
@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
@TradingBot.ApiService/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generalize PubSubRegistry and wire Dapr+outbox in Program.cs</name>
  <files>
    TradingBot.ApiService/BuildingBlocks/Pubsub/Dapr/ServiceCollectionExtensions.cs
    TradingBot.ApiService/BuildingBlocks/Pubsub/Dapr/WebApplicationExtensions.cs
    TradingBot.ApiService/Program.cs
  </files>
  <action>
    1. **Relax PubSubRegistry type constraint** in `BuildingBlocks/Pubsub/Dapr/WebApplicationExtensions.cs`:
       - Change `PubSubRegistry.Add<TEvent>()` constraint from `where TEvent : IntegrationEvent` to `where TEvent : class`
       - This allows domain event types (which implement `IDomainEvent`, not `IntegrationEvent`) to be registered

    2. **Relax Subscribe extension** in `BuildingBlocks/Pubsub/Dapr/ServiceCollectionExtensions.cs`:
       - Change `Subscribe<TEvent>()` constraint from `where TEvent : IntegrationEvent` to `where TEvent : class`
       - This allows `registry.Subscribe<PurchaseCompletedEvent>()` etc.

    3. **Update MapPubSub deserialization** in `WebApplicationExtensions.cs`:
       - The current code does: `JsonSerializer.Deserialize(daprEvent.Data, sub.EventType, jsonOptions) is not IntegrationEvent message`
       - Change to: `JsonSerializer.Deserialize(daprEvent.Data, sub.EventType, jsonOptions) is not INotification message`
       - Reason: Domain events implement `IDomainEvent : INotification`. The `mediator.Publish(message)` call needs an `INotification`. Using `INotification` as the type check works for both `IntegrationEvent` (which also implements `INotification`) and `IDomainEvent` types.
       - Alternative: cast to `object` and use `mediator.Publish(message)` since MediatR `Publish(object)` does runtime dispatch. Check if MediatR IMediator.Publish accepts `object`. If so, just check for `null` instead of type casting:
         ```csharp
         var message = JsonSerializer.Deserialize(daprEvent.Data, sub.EventType, jsonOptions);
         if (message is null) { ... return BadRequest; }
         await mediator.Publish(message);
         ```
       - This is cleaner and works for any type implementing `INotification`.

    4. **Wire AddDaprPubSub() in Program.cs** -- currently NOT called. Add after the existing service registrations (before `var app = builder.Build()`):
       ```csharp
       // Dapr pub-sub + outbox infrastructure
       var pubSubRegistry = builder.Services.AddDaprPubSub();
       builder.Services.AddOutboxPublishingWithEfCore<TradingBotDbContext>();
       ```
       - IMPORTANT: `AddOutboxPublishingWithEfCore` registers its own `JsonSerializerOptions` as singleton. The interceptor from Plan 01 may have its own. Consolidate: remove the inline `JsonSerializerOptions` from the interceptor registration (Plan 01), and instead resolve from DI. OR accept both registrations (the last one wins for DI resolution). The cleanest approach: have the interceptor also resolve `JsonSerializerOptions` from DI. Adjust interceptor registration from Plan 01 if needed -- register interceptor as a singleton that takes `JsonSerializerOptions` from the service provider.
       - The `AddOutboxPublishingWithEfCore` also registers `IOutboxStore`, `IEventPublisher`, `IOutboxMessageProcessor`, and `OutboxMessageBackgroundService`. These were previously NOT wired.
       - NOTE: `AddDaprPubSub` registers `IMessageBroker` as `DaprMessageBroker`. This requires Dapr sidecar. In development without Dapr, outbox messages will stay Pending (acceptable -- the outbox processor logs and retries).

    5. **Domain event subscriptions will be wired in Plan 03** (this plan only sets up the infrastructure).
  </action>
  <verify>
    Run `dotnet build TradingBot.sln` -- should compile without errors.
    Verify `PubSubRegistry.Add<TEvent>()` has `where TEvent : class` constraint.
    Verify `MapPubSub` no longer casts to `IntegrationEvent`.
    Verify `AddDaprPubSub()` and `AddOutboxPublishingWithEfCore()` are called in Program.cs.
  </verify>
  <done>
    PubSubRegistry accepts any class type (not just IntegrationEvent). MapPubSub deserializes by runtime Type and publishes via MediatR without IntegrationEvent cast. Dapr pub-sub and outbox infrastructure wired in Program.cs. Solution builds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IDomainEventPublisher, DeadLetterMessage entity, and dead-letter processor logic</name>
  <files>
    TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/IDomainEventPublisher.cs
    TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/DomainEventPublisher.cs
    TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/DeadLetterMessage.cs
    TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/OutboxMessageProcessor.cs
    TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/EfCore/EfCoreOutboxStore.cs
    TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/Abstraction/IOutboxStore.cs
    TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/ServiceCollectionExtensions.cs
    TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
  </files>
  <action>
    **Part A: IDomainEventPublisher for non-aggregate events**

    1. Create `IDomainEventPublisher` interface in `BuildingBlocks/Pubsub/Outbox/IDomainEventPublisher.cs`:
       ```csharp
       public interface IDomainEventPublisher
       {
           Task PublishDirectAsync(IDomainEvent domainEvent, CancellationToken ct = default);
       }
       ```

    2. Create `DomainEventPublisher` in `BuildingBlocks/Pubsub/Outbox/DomainEventPublisher.cs`:
       - Takes `TradingBotDbContext` (or `DbContext`) and `JsonSerializerOptions` via constructor
       - `PublishDirectAsync` does:
         a. Create an `OutboxMessage` with `EventName = domainEvent.GetType().Name`, `Payload = JsonSerializer.Serialize(domainEvent, domainEvent.GetType(), jsonOptions)`, `ProcessingStatus = Pending`
         b. Add to `dbContext.Set<OutboxMessage>()`
         c. Call `await dbContext.SaveChangesAsync(ct)` -- standalone save because non-aggregate events don't have a surrounding SaveChanges call. The interceptor will run but find no aggregate domain events (the DomainEventPublisher doesn't track aggregates).
       - IMPORTANT: This is for events NOT raised by aggregates (e.g., PurchaseSkippedEvent). The service calls `PublishDirectAsync` and the helper persists immediately.

    3. Register `IDomainEventPublisher` as scoped in `ServiceCollectionExtensions.cs` (the outbox one), inside `AddOutboxPublishingWithEfCore`:
       ```csharp
       services.AddScoped<IDomainEventPublisher, DomainEventPublisher>();
       ```

    **Part B: DeadLetterMessage entity and processor update**

    4. Create `DeadLetterMessage` entity in `BuildingBlocks/Pubsub/Outbox/DeadLetterMessage.cs`:
       ```csharp
       public class DeadLetterMessage : AuditedEntity
       {
           public Guid Id { get; init; }
           public required string EventName { get; init; }
           public required string Payload { get; init; }
           public DateTimeOffset FailedAt { get; init; }
           public string? LastError { get; set; }
           public int RetryCount { get; init; }

           public DeadLetterMessage()
           {
               Id = Guid.CreateVersion7(DateTimeOffset.UtcNow);
           }
       }
       ```

    5. Configure `DeadLetterMessage` entity in `TradingBotDbContext.OnModelCreating`:
       ```csharp
       modelBuilder.Entity<DeadLetterMessage>(entity =>
       {
           entity.ToTable("DeadLetterMessages");
           entity.HasKey(e => e.Id);
           entity.HasIndex(e => e.EventName);
           entity.HasIndex(e => e.FailedAt);
       });
       ```

    6. Add `MoveToDeadLetterAsync` method to `IOutboxStore`:
       ```csharp
       Task MoveToDeadLetterAsync(OutboxMessage message, string? lastError, CancellationToken ct = default);
       ```

    7. Implement in `EfCoreOutboxStore`:
       ```csharp
       public async Task MoveToDeadLetterAsync(OutboxMessage message, string? lastError, CancellationToken ct = default)
       {
           var deadLetter = new DeadLetterMessage
           {
               EventName = message.EventName,
               Payload = message.Payload,
               FailedAt = DateTimeOffset.UtcNow,
               LastError = lastError,
               RetryCount = message.RetryCount
           };
           await dbContext.Set<DeadLetterMessage>().AddAsync(deadLetter, ct);
           dbContext.Set<OutboxMessage>().Remove(message);
           await dbContext.SaveChangesAsync(ct);
       }
       ```

    8. Update `OutboxMessageProcessor.ProcessOutboxMessagesAsync`:
       - When `message.RetryCount >= 3`, instead of just marking Failed, call `outboxStore.MoveToDeadLetterAsync(message, null, cancellationToken)` and log a warning
       - In the catch block, after `IncrementRetryAsync`, check if `message.RetryCount + 1 >= 3` and if so, call `MoveToDeadLetterAsync` with `ex.Message` as lastError
       - Actually, simpler: keep the retry count increment on failure. The NEXT time the processor picks up the message (RetryCount >= 3), it moves to dead-letter. This avoids complexity in the catch block.
       - So the change is: replace `await outboxStore.MarkAsAsync(message.Id, ProcessingStatus.Failed, cancellationToken)` with `await outboxStore.MoveToDeadLetterAsync(message, null, cancellationToken)` in the RetryCount >= 3 path.

    9. **Add EF migration** for DeadLetterMessage table:
       ```bash
       cd TradingBot.ApiService && dotnet ef migrations add AddDeadLetterMessage
       ```
  </action>
  <verify>
    Run `dotnet build TradingBot.sln` -- should compile without errors.
    Run `cd TradingBot.ApiService && dotnet ef migrations list` -- should show AddDeadLetterMessage migration.
    Verify `IDomainEventPublisher` interface exists with `PublishDirectAsync`.
    Verify `DeadLetterMessage` entity exists with `EventName`, `Payload`, `FailedAt`, `LastError`, `RetryCount`.
    Verify `OutboxMessageProcessor` moves failed messages to dead-letter table after 3 retries.
  </verify>
  <done>
    IDomainEventPublisher created for non-aggregate event publishing (saves OutboxMessage + calls SaveChangesAsync). DeadLetterMessage entity added with EF migration. OutboxMessageProcessor moves exhausted messages (3+ retries) to dead-letter table. IOutboxStore extended with MoveToDeadLetterAsync. All registered in DI. Solution builds.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` compiles without errors
2. `PubSubRegistry.Add<TEvent>()` constraint is `where TEvent : class` (not `IntegrationEvent`)
3. `MapPubSub` deserializes by `sub.EventType` and does not cast to `IntegrationEvent`
4. `AddDaprPubSub()` and `AddOutboxPublishingWithEfCore<TradingBotDbContext>()` called in Program.cs
5. `IDomainEventPublisher.PublishDirectAsync` exists and creates OutboxMessage + saves
6. `DeadLetterMessage` table exists in migration
7. `OutboxMessageProcessor` calls `MoveToDeadLetterAsync` when RetryCount >= 3
</verification>

<success_criteria>
- Solution builds without errors
- Dapr pub-sub and outbox infrastructure fully wired in Program.cs
- PubSubRegistry generalized to accept any class type (domain events supported)
- MapPubSub handles domain event deserialization without IntegrationEvent dependency
- IDomainEventPublisher provides standalone outbox publishing for non-aggregate events
- Dead-letter table captures failed outbox messages after retry exhaustion
- EF migration created for DeadLetterMessage table
</success_criteria>

<output>
After completion, create `.planning/phases/17-domain-event-dispatch/17-02-SUMMARY.md`
</output>
