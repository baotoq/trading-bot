---
phase: 09-infrastructure-aspire-integration
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - dashboard/nuxt.config.ts
  - dashboard/server/utils/auth.ts
  - dashboard/server/api/portfolio.get.ts
  - TradingBot.AppHost/AppHost.cs
  - TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
  - TradingBot.ApiService/Program.cs
autonomous: true

must_haves:
  truths:
    - "Frontend can call backend API through proxy without CORS issues"
    - "API requests with valid API key receive 200 response"
    - "API requests with missing or invalid API key receive 403 response"
    - "Aspire passes API key and API endpoint as environment variables to Nuxt"
  artifacts:
    - path: "dashboard/nuxt.config.ts"
      provides: "runtimeConfig and routeRules for API proxy"
      contains: "runtimeConfig"
    - path: "dashboard/server/utils/auth.ts"
      provides: "API key validation utility function"
      contains: "requireApiKey"
    - path: "dashboard/server/api/portfolio.get.ts"
      provides: "Example protected API endpoint demonstrating auth pattern"
      contains: "requireApiKey"
    - path: "TradingBot.AppHost/AppHost.cs"
      provides: "API key parameter and environment injection"
      contains: "dashboardApiKey"
    - path: "TradingBot.ApiService/Endpoints/DashboardEndpoints.cs"
      provides: "Dashboard-specific API endpoints with API key auth"
      contains: "x-api-key"
    - path: "TradingBot.ApiService/Program.cs"
      provides: "Dashboard endpoint registration and API key config"
      contains: "MapDashboardEndpoints"
  key_links:
    - from: "dashboard/server/api/portfolio.get.ts"
      to: "dashboard/server/utils/auth.ts"
      via: "requireApiKey import"
      pattern: "requireApiKey"
    - from: "dashboard/nuxt.config.ts"
      to: "TradingBot.ApiService"
      via: "routeRules proxy"
      pattern: "proxy.*api"
    - from: "TradingBot.AppHost/AppHost.cs"
      to: "dashboard"
      via: "WithEnvironment for API key and endpoint"
      pattern: "NUXT_API_KEY"
    - from: "TradingBot.ApiService/Endpoints/DashboardEndpoints.cs"
      to: "TradingBot.ApiService/Program.cs"
      via: "MapDashboardEndpoints registration"
      pattern: "MapDashboardEndpoints"
---

<objective>
Configure API proxy for CORS-free development and implement API key authentication on both the .NET backend and Nuxt server layer.

Purpose: Enables secure frontend-to-backend communication (INFR-03) and protects dashboard API endpoints with API key authentication (INFR-04).
Output: Working API proxy and authentication flow where valid API key returns data, missing/invalid key returns 403.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-infrastructure-aspire-integration/09-RESEARCH.md
@.planning/phases/09-infrastructure-aspire-integration/09-01-SUMMARY.md
@TradingBot.AppHost/AppHost.cs
@TradingBot.ApiService/Program.cs
@TradingBot.ApiService/Endpoints/BacktestEndpoints.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add API key auth to .NET backend and create dashboard endpoints</name>
  <files>
    TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
    TradingBot.ApiService/Program.cs
    TradingBot.AppHost/AppHost.cs
  </files>
  <action>
Create dashboard-specific API endpoints on the .NET backend that validate an API key header, and configure Aspire to pass the API key as an environment variable.

1. Create `TradingBot.ApiService/Endpoints/DashboardEndpoints.cs`:

   ```csharp
   namespace TradingBot.ApiService.Endpoints;

   public static class DashboardEndpoints
   {
       public static WebApplication MapDashboardEndpoints(this WebApplication app)
       {
           var group = app.MapGroup("/api/dashboard")
               .AddEndpointFilter<ApiKeyEndpointFilter>();

           group.MapGet("/portfolio", GetPortfolioAsync);

           return app;
       }

       private static async Task<IResult> GetPortfolioAsync(
           Infrastructure.Data.TradingBotDbContext db,
           ILogger<Program> logger,
           CancellationToken ct)
       {
           // Placeholder portfolio endpoint -- real implementation in Phase 10
           var totalPurchases = await db.Purchases
               .Where(p => !p.IsDryRun && (p.Status == Models.PurchaseStatus.Filled || p.Status == Models.PurchaseStatus.PartiallyFilled))
               .CountAsync(ct);

           return Results.Ok(new
           {
               totalPurchases,
               message = "Portfolio endpoint ready. Full implementation in Phase 10."
           });
       }
   }

   public class ApiKeyEndpointFilter : IEndpointFilter
   {
       private readonly IConfiguration _configuration;
       private readonly ILogger<ApiKeyEndpointFilter> _logger;

       public ApiKeyEndpointFilter(IConfiguration configuration, ILogger<ApiKeyEndpointFilter> logger)
       {
           _configuration = configuration;
           _logger = logger;
       }

       public async ValueTask<object?> InvokeAsync(EndpointFilterInvocationContext context, EndpointFilterDelegate next)
       {
           var httpContext = context.HttpContext;
           var apiKey = httpContext.Request.Headers["x-api-key"].FirstOrDefault();
           var expectedKey = _configuration["Dashboard:ApiKey"];

           if (string.IsNullOrEmpty(expectedKey))
           {
               _logger.LogWarning("Dashboard API key not configured. Set Dashboard:ApiKey in configuration or user-secrets");
               return Results.Problem(
                   statusCode: 500,
                   title: "API key not configured");
           }

           if (string.IsNullOrEmpty(apiKey))
           {
               _logger.LogWarning("Dashboard API request missing x-api-key header");
               return Results.Problem(
                   statusCode: 401,
                   title: "Unauthorized",
                   detail: "API key required. Include x-api-key header.");
           }

           if (!string.Equals(apiKey, expectedKey, StringComparison.Ordinal))
           {
               _logger.LogWarning("Dashboard API request with invalid API key");
               return Results.Problem(
                   statusCode: 403,
                   title: "Forbidden",
                   detail: "Invalid API key");
           }

           return await next(context);
       }
   }
   ```

   Add necessary usings at the top: `using Microsoft.EntityFrameworkCore;`

2. Register the dashboard endpoints in `TradingBot.ApiService/Program.cs`:
   Add `app.MapDashboardEndpoints();` after the existing `app.MapBacktestEndpoints();` line.

3. Update `TradingBot.AppHost/AppHost.cs` to add the API key parameter and pass it to both services. Add this BEFORE the dashboard variable:

   ```csharp
   var dashboardApiKey = builder.AddParameter("dashboardApiKey", secret: true);
   ```

   Then update the dashboard resource to include environment variables:
   ```csharp
   var dashboard = builder.AddNpmApp("dashboard", "../dashboard", "dev")
       .WithHttpEndpoint(port: 3000, env: "PORT")
       .WithExternalHttpEndpoints()
       .WithEnvironment("NUXT_PUBLIC_API_ENDPOINT", apiService.GetEndpoint("http"))
       .WithEnvironment("NUXT_API_KEY", dashboardApiKey)
       .WithReference(apiService)
       .WaitFor(apiService);
   ```

   Also pass the API key to the API service by chaining onto the existing apiService definition:
   ```csharp
   apiService.WithEnvironment("Dashboard__ApiKey", dashboardApiKey);
   ```

   Note: `Dashboard__ApiKey` maps to `Dashboard:ApiKey` in .NET configuration (double underscore = colon separator).

4. Set a development API key in AppHost user secrets:
   ```bash
   cd TradingBot.AppHost && dotnet user-secrets set "Parameters:dashboardApiKey" "dev-dashboard-key-change-in-production"
   ```
  </action>
  <verify>
    Run `dotnet build /Users/baotoq/Work/trading-bot/TradingBot.ApiService` -- should compile without errors.
    Run `dotnet build /Users/baotoq/Work/trading-bot/TradingBot.AppHost` -- should compile without errors.
    Grep `DashboardEndpoints.cs` for `x-api-key` -- should find API key validation.
    Grep `Program.cs` for `MapDashboardEndpoints` -- should find registration.
    Grep `AppHost.cs` for `dashboardApiKey` -- should find parameter and environment injection.
  </verify>
  <done>
    .NET backend has `/api/dashboard/portfolio` endpoint protected by API key validation via endpoint filter. Aspire AppHost passes API key as secret parameter to both Nuxt (NUXT_API_KEY) and .NET API (Dashboard:ApiKey). Missing key returns 401, invalid key returns 403, valid key returns portfolio data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure Nuxt API proxy and server-side API key validation</name>
  <files>
    dashboard/nuxt.config.ts
    dashboard/server/utils/auth.ts
    dashboard/server/api/portfolio.get.ts
  </files>
  <action>
Configure the Nuxt frontend to proxy API requests to the .NET backend and create server-side API key validation for Nuxt server routes.

1. Update `dashboard/nuxt.config.ts` to add runtimeConfig and routeRules:

   ```typescript
   export default defineNuxtConfig({
     modules: ['@nuxt/ui'],

     css: ['~/assets/css/main.css'],

     runtimeConfig: {
       // Server-side only (never exposed to client)
       apiKey: process.env.NUXT_API_KEY || '',

       // Public variables (exposed to client via useRuntimeConfig)
       public: {
         apiEndpoint: process.env.NUXT_PUBLIC_API_ENDPOINT || 'http://localhost:5000'
       }
     },

     routeRules: {
       // Proxy /proxy/api/** to backend API to avoid CORS in development
       '/proxy/api/**': {
         proxy: `${process.env.NUXT_PUBLIC_API_ENDPOINT || 'http://localhost:5000'}/api/**`
       }
     },

     devtools: { enabled: true },

     typescript: {
       strict: true,
       typeCheck: false
     },

     compatibilityDate: '2024-11-01'
   })
   ```

   Note: Using `/proxy/api/**` prefix to avoid conflict with Nuxt's own `server/api/` routes (which are served at `/api/`). Frontend calls `/proxy/api/dashboard/portfolio` which gets proxied to backend's `/api/dashboard/portfolio`.

2. Create `dashboard/server/utils/auth.ts` for API key validation utility:

   ```typescript
   import type { H3Event } from 'h3'

   export function requireApiKey(event: H3Event): void {
     const config = useRuntimeConfig(event)
     const authHeader = getHeader(event, 'x-api-key')

     if (!authHeader) {
       throw createError({
         status: 401,
         statusText: 'Unauthorized',
         data: { reason: 'API key required' }
       })
     }

     if (authHeader !== config.apiKey) {
       throw createError({
         status: 403,
         statusText: 'Forbidden',
         data: { reason: 'Invalid API key' }
       })
     }
   }
   ```

3. Create `dashboard/server/api/portfolio.get.ts` as an example protected endpoint that fetches from the .NET backend:

   ```typescript
   export default defineEventHandler(async (event) => {
     const config = useRuntimeConfig(event)

     try {
       const data = await $fetch(`${config.public.apiEndpoint}/api/dashboard/portfolio`, {
         headers: {
           'x-api-key': config.apiKey
         }
       })

       return data
     } catch (error: any) {
       const statusCode = error?.response?.status || 502
       throw createError({
         status: statusCode,
         statusText: statusCode === 502 ? 'Bad Gateway' : error?.response?.statusText || 'Error',
         data: { reason: 'Failed to fetch portfolio from backend API' }
       })
     }
   })
   ```

   Note: This Nuxt server route does NOT use `requireApiKey` because it's a server-side route called by the Nuxt frontend. The API key is used server-to-server when calling the .NET backend. The Nuxt server is trusted since it's running on the same machine. Direct browser access to `/api/portfolio` will work without API key because the Nuxt server handles the auth with the backend.

4. Verify TypeScript types resolve:
   ```bash
   cd dashboard && npx nuxi prepare
   ```
  </action>
  <verify>
    Run `cd /Users/baotoq/Work/trading-bot/dashboard && npx nuxi prepare` -- should complete without type errors.
    Verify `dashboard/nuxt.config.ts` contains `runtimeConfig` with `apiKey` and `public.apiEndpoint`.
    Verify `dashboard/nuxt.config.ts` contains `routeRules` with proxy configuration.
    Verify `dashboard/server/utils/auth.ts` exports `requireApiKey` function.
    Verify `dashboard/server/api/portfolio.get.ts` calls backend with API key header.
  </verify>
  <done>
    Nuxt config has API proxy via routeRules (CORS-free development), runtimeConfig with server-only API key and public API endpoint. Auth utility at `server/utils/auth.ts` provides reusable `requireApiKey` function. Example portfolio server route demonstrates the server-to-server auth pattern: Nuxt server calls .NET backend with API key from env, proxying data to the browser client.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.AppHost` compiles with JavaScript hosting package
2. `dotnet build TradingBot.ApiService` compiles with DashboardEndpoints
3. `dashboard/nuxt.config.ts` has runtimeConfig with apiKey (server-only) and public.apiEndpoint
4. `dashboard/nuxt.config.ts` has routeRules proxy for `/proxy/api/**`
5. `dashboard/server/utils/auth.ts` exports requireApiKey that throws 401/403
6. `dashboard/server/api/portfolio.get.ts` calls .NET backend with x-api-key header
7. `TradingBot.ApiService/Endpoints/DashboardEndpoints.cs` validates x-api-key via endpoint filter
8. `TradingBot.AppHost/AppHost.cs` passes NUXT_API_KEY and NUXT_PUBLIC_API_ENDPOINT env vars
9. `TradingBot.AppHost/AppHost.cs` passes Dashboard__ApiKey to API service
</verification>

<success_criteria>
- Frontend proxy routes API calls to backend without CORS issues
- .NET dashboard endpoints reject requests without valid API key (401 missing, 403 invalid)
- Nuxt server routes call .NET backend with API key from environment
- Aspire injects API key and endpoint URL as environment variables
- Auth pattern is reusable for all future dashboard endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/09-infrastructure-aspire-integration/09-02-SUMMARY.md`
</output>
