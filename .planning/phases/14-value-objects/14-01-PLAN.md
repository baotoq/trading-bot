---
phase: 14-value-objects
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Models/Values/Price.cs
  - TradingBot.ApiService/Models/Values/UsdAmount.cs
  - TradingBot.ApiService/Models/Values/Quantity.cs
  - TradingBot.ApiService/Models/Values/Multiplier.cs
  - TradingBot.ApiService/Models/Values/Percentage.cs
  - TradingBot.ApiService/Models/Values/Symbol.cs
  - TradingBot.ApiService/Models/Purchase.cs
  - TradingBot.ApiService/Models/DcaConfiguration.cs
  - TradingBot.ApiService/Models/DailyPrice.cs
  - TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
  - TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
  - TradingBot.ApiService/Endpoints/DashboardDtos.cs
  - TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
  - TradingBot.Dashboard/app/types/dashboard.ts
autonomous: true
requirements:
  - TS-02
  - TS-03
  - TS-04

must_haves:
  truths:
    - "Price.From(-1) throws ValueObjectValidationException (rejects negative)"
    - "UsdAmount.From(0) throws ValueObjectValidationException (rejects zero)"
    - "Quantity.From(-1) throws ValueObjectValidationException but Quantity.From(0) succeeds (allows zero)"
    - "Multiplier.From(25) throws ValueObjectValidationException (exceeds 20x cap)"
    - "Percentage.From(1.5m) throws ValueObjectValidationException (exceeds 1.0 limit)"
    - "Symbol.From(\"\") throws ValueObjectValidationException (rejects empty)"
    - "Purchase entity persists and loads with value object fields via EF Core (no schema migration)"
    - "DailyPrice entity persists and loads with Price fields and Symbol value object via EF Core composite key"
    - "PurchaseCompletedEvent carries typed value objects (except RemainingUsdc, High30Day, Ma200Day which stay decimal)"
    - "Dashboard DTO fields use value objects; Vogen STJ converters serialize them as raw JSON primitives"
    - "DashboardEndpoints uses Symbol.Btc instead of string literal \"BTC\""
  artifacts:
    - path: "TradingBot.ApiService/Models/Values/Price.cs"
      provides: "Price value object with validation and comparison operators"
      contains: "[ValueObject<decimal>]"
    - path: "TradingBot.ApiService/Models/Values/UsdAmount.cs"
      provides: "UsdAmount value object with cross-type arithmetic"
      contains: "[ValueObject<decimal>]"
    - path: "TradingBot.ApiService/Models/Values/Quantity.cs"
      provides: "Quantity value object allowing zero"
      contains: "[ValueObject<decimal>]"
    - path: "TradingBot.ApiService/Models/Values/Multiplier.cs"
      provides: "Multiplier value object with 20x upper bound"
      contains: "[ValueObject<decimal>]"
    - path: "TradingBot.ApiService/Models/Values/Percentage.cs"
      provides: "Percentage value object in 0-1 format"
      contains: "[ValueObject<decimal>]"
    - path: "TradingBot.ApiService/Models/Values/Symbol.cs"
      provides: "Symbol string wrapper with well-known constants"
      contains: "[ValueObject<string>]"
    - path: "TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs"
      provides: "EF Core converter registrations for all value objects"
      contains: "Properties<Price>()"
  key_links:
    - from: "TradingBot.ApiService/Models/Purchase.cs"
      to: "TradingBot.ApiService/Models/Values/Price.cs"
      via: "Property type reference"
      pattern: "Price Price"
    - from: "TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs"
      to: "TradingBot.ApiService/Models/Values/Price.cs"
      via: "ConfigureConventions EF Core converter"
      pattern: "Properties<Price>.*HaveConversion"
    - from: "TradingBot.ApiService/Models/DailyPrice.cs"
      to: "TradingBot.ApiService/Models/Values/Symbol.cs"
      via: "Composite key property type"
      pattern: "Symbol Symbol"
    - from: "TradingBot.ApiService/Endpoints/DashboardEndpoints.cs"
      to: "TradingBot.ApiService/Models/Values/Symbol.cs"
      via: "LINQ query filter using Symbol constant"
      pattern: "Symbol.Btc"
    - from: "TradingBot.ApiService/Endpoints/DashboardDtos.cs"
      to: "TradingBot.ApiService/Models/Values/Price.cs"
      via: "DTO fields use value object types"
      pattern: "Price Price"
---

<objective>
Define all 6 value object types (Price, UsdAmount, Quantity, Multiplier, Percentage, Symbol) with validation and operators, apply them to entity properties, register EF Core converters, update domain events, and add dashboard branded types.

Purpose: Establish domain primitive types so invalid values (negative prices, negative quantities, out-of-range percentages) cannot exist at runtime. Entity fields become self-documenting: `Price Price` vs `decimal Price`.

Output: Value object type definitions in `Models/Values/`, updated entities, EF Core converters, updated events, dashboard TypeScript types.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-value-objects/14-RESEARCH.md

@TradingBot.ApiService/Models/Ids/VogenGlobalConfig.cs
@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/Models/DcaConfiguration.cs
@TradingBot.ApiService/Models/DailyPrice.cs
@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
@TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
@TradingBot.ApiService/Endpoints/DashboardDtos.cs
@TradingBot.Dashboard/app/types/dashboard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define value object types with validation, comparison, and cross-type arithmetic</name>
  <files>
    TradingBot.ApiService/Models/Values/Price.cs
    TradingBot.ApiService/Models/Values/UsdAmount.cs
    TradingBot.ApiService/Models/Values/Quantity.cs
    TradingBot.ApiService/Models/Values/Multiplier.cs
    TradingBot.ApiService/Models/Values/Percentage.cs
    TradingBot.ApiService/Models/Values/Symbol.cs
  </files>
  <action>
    Create `Models/Values/` directory (mirrors `Models/Ids/` from Phase 13).

    Create 6 value object files. Each numeric type (`[ValueObject<decimal>]`) needs:
    1. `private static Validation Validate(decimal value)` method with type-specific rules
    2. Four hand-written comparison operators: `<`, `>`, `<=`, `>=` (Vogen does NOT generate these)
    3. Cross-type arithmetic operators where domain-meaningful

    **IMPORTANT**: Do NOT modify `VogenGlobalConfig.cs`. Per-type `[ValueObject<decimal>]` overrides the global Guid default automatically. The global config stays as-is from Phase 13.

    **Price.cs** (`[ValueObject<decimal>]`):
    - Validation: `value > 0` (strictly positive, reject zero and negative)
    - Comparison operators: `<`, `>`, `<=`, `>=`
    - No cross-type operators here (those go on UsdAmount and Quantity)

    **UsdAmount.cs** (`[ValueObject<decimal>]`):
    - Validation: `value > 0` (strictly positive)
    - Comparison operators: `<`, `>`, `<=`, `>=`
    - Cross-type: `UsdAmount + UsdAmount = UsdAmount` (accumulation)
    - Cross-type: `UsdAmount * Multiplier = UsdAmount` (applying DCA boost)
    - Cross-type: `UsdAmount / Price = Quantity` (how much BTC can I buy?)

    **Quantity.cs** (`[ValueObject<decimal>]`):
    - Validation: `value >= 0` (allow zero -- Purchase records start at 0 before fill)
    - Comparison operators: `<`, `>`, `<=`, `>=`
    - Cross-type: `Quantity * Price = UsdAmount` (calculating cost)
    - Cross-type: `Quantity + Quantity = Quantity` (accumulation)

    **Multiplier.cs** (`[ValueObject<decimal>]`):
    - Validation: `value > 0 && value <= 20m` (upper bound 20x -- generous sanity cap per research recommendation)
    - Comparison operators: `<`, `>`, `<=`, `>=`
    - Cross-type: `Multiplier + Multiplier = Multiplier` (additive bear boost: tierMultiplier + bearBoost)
    - Note: The `MaxReasonableMultiplier` constant should be `20m`

    **Percentage.cs** (`[ValueObject<decimal>]`):
    - Validation: `value >= 0 && value <= 1` (0-1 format, 0.05 = 5%)
    - Comparison operators: `<`, `>`, `<=`, `>=`
    - No cross-type operators needed

    **Symbol.cs** (`[ValueObject<string>]`):
    - Validation: `!string.IsNullOrWhiteSpace(value) && value.Length <= 20`
    - Well-known constants: `public static readonly Symbol Btc = From("BTC");` and `public static readonly Symbol BtcUsdc = From("BTC/USDC");`
    - No comparison operators (string comparison has no domain meaning)

    All types are in namespace `TradingBot.ApiService.Models.Values`.
  </action>
  <verify>
    `dotnet build TradingBot.sln` compiles successfully. Verify the 6 files exist in `Models/Values/`.
  </verify>
  <done>
    All 6 value object types defined with correct validation rules, comparison operators, and cross-type arithmetic. Vogen source generator produces `From()`, `TryFrom()`, `==`, `!=`, `CompareTo`, `EfCoreValueConverter`, `EfCoreValueComparer`, and `JsonConverter` for each.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply value objects to entities, register EF Core converters, update events and DTOs</name>
  <files>
    TradingBot.ApiService/Models/Purchase.cs
    TradingBot.ApiService/Models/DcaConfiguration.cs
    TradingBot.ApiService/Models/DailyPrice.cs
    TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
    TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
    TradingBot.ApiService/Endpoints/DashboardDtos.cs
    TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
    TradingBot.Dashboard/app/types/dashboard.ts
  </files>
  <action>
    **Purchase.cs** -- Replace decimal fields with value objects:
    - `decimal Price` -> `Price Price` (using `TradingBot.ApiService.Models.Values`)
    - `decimal Quantity` -> `Quantity Quantity`
    - `decimal Cost` -> `UsdAmount Cost`
    - `decimal Multiplier` -> `Multiplier Multiplier`
    - `decimal DropPercentage` -> `Percentage DropPercentage`
    - `decimal High30Day` -- **KEEP as `decimal`** (uses 0 as sentinel for "data unavailable"; Price rejects 0)
    - `decimal Ma200Day` -- **KEEP as `decimal`** (uses 0 as sentinel for "data unavailable"; Price rejects 0)
    - Add `using TradingBot.ApiService.Models.Values;`
    - **NOTE on Cost**: `Purchase.Cost` is initialized to `0` in DcaExecutionService before being overwritten on fill. Since `UsdAmount` rejects 0, the initializer must set a valid positive value. Set `Cost = UsdAmount.From(usdAmount)` (the intended spend) at Purchase creation time instead of 0. Plan 02 Task 2 (DcaExecutionService) will implement this fix.

    **DcaConfiguration.cs** -- Replace decimal fields:
    - `decimal BaseDailyAmount` -> `UsdAmount BaseDailyAmount`
    - `decimal BearBoostFactor` -> `Multiplier BearBoostFactor`
    - `decimal MaxMultiplierCap` -> `Multiplier MaxMultiplierCap`
    - Keep `MultiplierTierData` as `record(decimal DropPercentage, decimal Multiplier)` -- stored as jsonb, keep raw decimals per research Pitfall 3 recommendation
    - Add `using TradingBot.ApiService.Models.Values;`

    **DailyPrice.cs** -- Replace fields:
    - `string Symbol` -> `Symbol Symbol` (with default `= Symbol.Btc` instead of `= "BTC"`)
    - `decimal Open` -> `Price Open`
    - `decimal High` -> `Price High`
    - `decimal Low` -> `Price Low`
    - `decimal Close` -> `Price Close`
    - `decimal Volume` stays as `decimal` (no domain semantics beyond "number of units")
    - Add `using TradingBot.ApiService.Models.Values;`

    **TradingBotDbContext.cs** -- Add value object converter registrations in `ConfigureConventions` (after Phase 13 typed ID registrations):
    ```csharp
    // Phase 14 (value objects)
    configurationBuilder.Properties<Price>()
        .HaveConversion<Price.EfCoreValueConverter, Price.EfCoreValueComparer>();
    configurationBuilder.Properties<UsdAmount>()
        .HaveConversion<UsdAmount.EfCoreValueConverter, UsdAmount.EfCoreValueComparer>();
    configurationBuilder.Properties<Quantity>()
        .HaveConversion<Quantity.EfCoreValueConverter, Quantity.EfCoreValueComparer>();
    configurationBuilder.Properties<Multiplier>()
        .HaveConversion<Multiplier.EfCoreValueConverter, Multiplier.EfCoreValueComparer>();
    configurationBuilder.Properties<Percentage>()
        .HaveConversion<Percentage.EfCoreValueConverter, Percentage.EfCoreValueComparer>();
    configurationBuilder.Properties<Symbol>()
        .HaveConversion<Symbol.EfCoreValueConverter, Symbol.EfCoreValueComparer>();
    ```
    - Add `using TradingBot.ApiService.Models.Values;`
    - Keep ALL existing `HasPrecision` annotations in `OnModelCreating` -- they apply to the underlying DB column regardless of value converter (per research Pitfall 6)

    **PurchaseCompletedEvent.cs** -- Replace decimal fields (selectively):
    - `decimal BtcAmount` -> `Quantity BtcAmount`
    - `decimal Price` -> `Price Price`
    - `decimal UsdSpent` -> `UsdAmount UsdSpent` (always positive when a purchase completes)
    - `decimal RemainingUsdc` -- **KEEP as `decimal`** (balance can legitimately be 0 when depleted; UsdAmount rejects 0)
    - `decimal CurrentBtcBalance` -> `Quantity CurrentBtcBalance`
    - `decimal Multiplier` -> `Multiplier Multiplier`
    - `decimal DropPercentage` -> `Percentage DropPercentage`
    - `decimal High30Day` -- **KEEP as `decimal`** (uses 0 sentinel for "data unavailable")
    - `decimal Ma200Day` -- **KEEP as `decimal`** (uses 0 sentinel for "data unavailable")
    - Add `using TradingBot.ApiService.Models.Values;`
    - NOTE: This event is serialized via System.Text.Json for the outbox pattern. Vogen's generated STJ converters handle serialization as raw numbers. This is safe.

    **DashboardDtos.cs** -- Update DTO fields to use value objects. Per CONTEXT.md locked decision: "DTOs use value objects directly (not raw decimal/string) -- Vogen JSON converters handle serialization transparently." Vogen's STJ converters serialize value objects as raw JSON numbers/strings, so the API surface is unchanged.
    - `PurchaseDto`: `Price` -> `Price`, `Cost` -> `UsdAmount`, `Quantity` -> `Quantity`, `Multiplier` -> `Multiplier`, `DropPercentage` -> `Percentage`. Keep `Id` as `Guid` (Phase 13 typed ID pattern uses Guid in DTOs).
    - `PortfolioResponse`: `TotalBtc` -> `Quantity`, `TotalCost` -> `UsdAmount`, `AverageCostBasis` -> `Price`, `CurrentPrice` -> `Price`, `UnrealizedPnl` -> keep `decimal` (can be negative, no value object fits), `UnrealizedPnlPercent` -> keep `decimal` (can be negative)
    - `LiveStatusResponse`: `LastPurchasePrice` -> `Price?`, `LastPurchaseBtc` -> `Quantity?`
    - `PricePointDto`: `Price` -> `Price`
    - `PurchaseMarkerDto`: `Price` -> `Price`, `BtcAmount` -> `Quantity`
    - `PriceChartResponse`: `AverageCostBasis` -> `Price`
    - `DcaConfigResponse`: `BaseDailyAmount` -> `UsdAmount`, `BearBoostFactor` -> `Multiplier`, `MaxMultiplierCap` -> `Multiplier`
    - `MultiplierTierDto`: `DropPercentage` -> `Percentage`, `Multiplier` -> `Multiplier`
    - `ConfigResponse`: `BaseDailyAmount` -> `UsdAmount`, `BearBoostFactor` -> `Multiplier`, `MaxMultiplierCap` -> `Multiplier`
    - `UpdateConfigRequest`: `BaseDailyAmount` -> `UsdAmount`, `BearBoostFactor` -> `Multiplier`, `MaxMultiplierCap` -> `Multiplier`
    - Add `using TradingBot.ApiService.Models.Values;`

    **DashboardEndpoints.cs** -- Update string literal `dp.Symbol == "BTC"` in `GetPriceChartAsync` to use `dp.Symbol == Symbol.Btc`. Add `using TradingBot.ApiService.Models.Values;`. The EF Core value converter handles the comparison in the generated SQL query.

    **Dashboard TypeScript (dashboard.ts)** -- Add branded types matching Phase 13 pattern:
    ```typescript
    // Branded types for type-safe value objects (mirrors backend domain primitives)
    export type Price = number & { readonly __brand: 'Price' }
    export type UsdAmount = number & { readonly __brand: 'UsdAmount' }
    export type Quantity = number & { readonly __brand: 'Quantity' }
    export type BtcMultiplier = number & { readonly __brand: 'Multiplier' }
    export type Percentage = number & { readonly __brand: 'Percentage' }
    export type TradingSymbol = string & { readonly __brand: 'Symbol' }
    ```
    Note: Use `BtcMultiplier` and `TradingSymbol` to avoid conflicts with built-in TypeScript types.
    Update `PurchaseDto` interface fields to use branded types:
    - `price: Price`, `cost: UsdAmount`, `quantity: Quantity`, `multiplier: BtcMultiplier`, `dropPercentage: Percentage`
    Also update `PortfolioResponse`, `LiveStatusResponse`, `PurchaseMarkerDto`, `PricePointDto` fields to use branded types where applicable.

    **IMPORTANT**: After applying value objects to entities, the code will NOT compile yet because services (DcaExecutionService, PriceDataService, etc.) still use raw decimals. This is expected -- Plan 02 handles services. To ensure this plan compiles, the implicit toPrimitiveCasting from VogenGlobalConfig allows the existing service code to continue compiling (value objects implicitly convert to decimal). Verify this by building.
  </action>
  <verify>
    `dotnet build TradingBot.sln` compiles successfully. No EF Core migration needed (column types unchanged). Verify entities reference value object types in their properties.
  </verify>
  <done>
    Entity properties use value objects instead of raw decimals. EF Core converters registered globally. PurchaseCompletedEvent carries typed fields. Dashboard TypeScript has branded types. Solution compiles (implicit casts allow existing service code to keep working until Plan 02 updates signatures).
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` -- solution compiles with zero errors
2. `dotnet test` -- all 53 existing tests pass (value objects' implicit casts maintain backward compatibility)
3. Verify no EF Core migration is generated: `cd TradingBot.ApiService && dotnet ef migrations has-pending-model-changes` should show no pending changes (value converters don't change schema)
4. Manual spot-check: `Price.From(-1)` should throw, `Price.From(100)` should succeed
</verification>

<success_criteria>
- All 6 value objects defined with validation, operators, and cross-type arithmetic
- Purchase, DcaConfiguration, DailyPrice entities use value objects for domain fields
- EF Core converters registered in ConfigureConventions for all value object types
- PurchaseCompletedEvent uses typed fields (RemainingUsdc, High30Day, Ma200Day stay decimal)
- Dashboard DTOs use value objects per CONTEXT.md locked decision
- DashboardEndpoints uses Symbol.Btc instead of "BTC" string literal
- Dashboard TypeScript has branded types for value objects
- Solution compiles and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-value-objects/14-01-SUMMARY.md`
</output>
