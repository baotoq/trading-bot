---
phase: 14-value-objects
plan: 02
type: execute
wave: 2
depends_on:
  - 14-01
files_modified:
  - TradingBot.ApiService/Models/Ids/VogenGlobalConfig.cs
  - TradingBot.ApiService/Configuration/DcaOptions.cs
  - TradingBot.ApiService/Application/Services/MultiplierCalculator.cs
  - TradingBot.ApiService/Application/Services/BacktestSimulator.cs
  - TradingBot.ApiService/Application/Services/Backtest/BacktestConfig.cs
  - TradingBot.ApiService/Application/Services/Backtest/DailyPriceData.cs
  - TradingBot.ApiService/Application/Services/Backtest/PurchaseLogEntry.cs
  - TradingBot.ApiService/Application/Services/Backtest/BacktestResult.cs
  - TradingBot.ApiService/Application/Services/DcaExecutionService.cs
  - TradingBot.ApiService/Application/Services/PriceDataService.cs
  - TradingBot.ApiService/Application/Services/ConfigurationService.cs
  - TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
  - TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
autonomous: true
requirements:
  - TS-02
  - TS-03
  - TS-04

must_haves:
  truths:
    - "DcaOptions binds from appsettings.json with value object fields (BaseDailyAmount as UsdAmount, BearBoostFactor as Multiplier)"
    - "MultiplierCalculator.Calculate accepts and returns value objects (Price, UsdAmount, Multiplier, Percentage)"
    - "BacktestSimulator.Run works with value object types and produces correct results"
    - "DcaExecutionService orchestrates purchases using value objects throughout the flow"
    - "PriceDataService returns decimal (raw) but callers wrap in Price/value objects"
    - "All 53 tests pass (snapshot tests updated if needed)"
    - "DcaOptionsValidator removes redundant bounds checks that value objects now enforce"
  artifacts:
    - path: "TradingBot.ApiService/Configuration/DcaOptions.cs"
      provides: "DcaOptions with value object fields and updated validator"
      contains: "UsdAmount BaseDailyAmount"
    - path: "TradingBot.ApiService/Application/Services/MultiplierCalculator.cs"
      provides: "MultiplierCalculator with typed signature"
      contains: "Price currentPrice"
    - path: "TradingBot.ApiService/Application/Services/BacktestSimulator.cs"
      provides: "BacktestSimulator using value objects internally"
      contains: "MultiplierCalculator.Calculate"
  key_links:
    - from: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      to: "TradingBot.ApiService/Application/Services/MultiplierCalculator.cs"
      via: "MultiplierCalculator.Calculate call with value object arguments"
      pattern: "MultiplierCalculator.Calculate"
    - from: "TradingBot.ApiService/Application/Services/BacktestSimulator.cs"
      to: "TradingBot.ApiService/Application/Services/MultiplierCalculator.cs"
      via: "MultiplierCalculator.Calculate call with value object arguments"
      pattern: "MultiplierCalculator.Calculate"
    - from: "TradingBot.ApiService/Configuration/DcaOptions.cs"
      to: "TradingBot.ApiService/Models/Values/UsdAmount.cs"
      via: "Config binding with TypeConverter"
      pattern: "UsdAmount BaseDailyAmount"
---

<objective>
Apply value objects to DcaOptions configuration, MultiplierCalculator, BacktestSimulator, DcaExecutionService, PriceDataService, ConfigurationService, and notification handlers. Update DcaOptionsValidator to remove redundant validation. Refresh snapshot tests.

Purpose: Complete the value object adoption across the entire application layer. Configuration binding, business logic, and backtest simulation all use domain-typed parameters for compile-time safety.

Output: Updated service signatures, config binding with TypeConverter, updated backtest models, refreshed snapshot tests.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-value-objects/14-RESEARCH.md
@.planning/phases/14-value-objects/14-01-SUMMARY.md

@TradingBot.ApiService/Models/Ids/VogenGlobalConfig.cs
@TradingBot.ApiService/Configuration/DcaOptions.cs
@TradingBot.ApiService/Application/Services/MultiplierCalculator.cs
@TradingBot.ApiService/Application/Services/BacktestSimulator.cs
@TradingBot.ApiService/Application/Services/Backtest/BacktestConfig.cs
@TradingBot.ApiService/Application/Services/Backtest/DailyPriceData.cs
@TradingBot.ApiService/Application/Services/Backtest/PurchaseLogEntry.cs
@TradingBot.ApiService/Application/Services/Backtest/BacktestResult.cs
@TradingBot.ApiService/Application/Services/DcaExecutionService.cs
@TradingBot.ApiService/Application/Services/PriceDataService.cs
@TradingBot.ApiService/Application/Services/ConfigurationService.cs
@TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
@TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update VogenGlobalConfig, DcaOptions, DcaOptionsValidator, and ConfigurationService</name>
  <files>
    TradingBot.ApiService/Models/Ids/VogenGlobalConfig.cs
    TradingBot.ApiService/Configuration/DcaOptions.cs
    TradingBot.ApiService/Application/Services/ConfigurationService.cs
  </files>
  <action>
    **VogenGlobalConfig.cs** -- Add `Conversions.TypeConverter` to the global conversions flag. This is required for ASP.NET Core configuration binding to convert config strings ("10.0") to value objects. Update the conversions line:
    ```csharp
    conversions: Conversions.EfCoreValueConverter | Conversions.SystemTextJson | Conversions.TypeConverter,
    ```
    This applies to all Vogen types (both typed IDs and value objects). TypeConverter for Guids is standard and harmless. This approach is simpler than per-type overrides (research Option B).

    **DcaOptions.cs** -- Replace decimal fields with value objects:
    - `decimal BaseDailyAmount` -> `UsdAmount BaseDailyAmount`
    - `decimal BearBoostFactor` -> `Multiplier BearBoostFactor` (default `= Multiplier.From(1.5m)`)
    - `decimal MaxMultiplierCap` -> `Multiplier MaxMultiplierCap` (default `= Multiplier.From(4.5m)`)
    - Add `using TradingBot.ApiService.Models.Values;`

    **MultiplierTier class** in DcaOptions.cs -- Replace fields:
    - `decimal DropPercentage` -> `Percentage DropPercentage`
    - `decimal Multiplier` -> `Multiplier Multiplier`

    **DcaOptionsValidator** -- Remove redundant validation that value objects now enforce at construction:
    - REMOVE: `BaseDailyAmount <= 0` check (UsdAmount rejects <= 0)
    - REMOVE: `BearBoostFactor <= 0` check (Multiplier rejects <= 0)
    - REMOVE: `MaxMultiplierCap <= 0` check (Multiplier rejects <= 0)
    - KEEP: `MaxMultiplierCap < 1` check (cross-field business rule: cap shouldn't reduce)
    - KEEP: `DailyBuyHour`, `DailyBuyMinute` checks (int fields, no value object)
    - KEEP: `HighLookbackDays`, `BearMarketMaPeriod` checks (int fields, no value object)
    - KEEP: MultiplierTiers validation (ordering, positive values) -- these are now cross-field rules
    - Update MultiplierTier comparisons to use value object operators (e.g., `t.Multiplier <= Multiplier.From(0)` or leverage that Multiplier already rejects <= 0 at construction)
    - For tier validation: if config binding creates `Multiplier.From(0)`, it will throw during binding, so the validator check for `Multiplier <= 0` becomes unreachable. REMOVE it. Keep the ascending sort check.
    - Update `MultiplierTierComparer` to compare value objects (use `.Value` for explicit decimal comparison if needed, or rely on `==`/`!=` operators)

    **ConfigurationService.cs** -- Update mapping methods:
    - `MapToOptions`: Map from `DcaConfiguration` entity (which has value object fields from Plan 01) to `DcaOptions` (which now also has value object fields). The mapping becomes trivial: `BaseDailyAmount = entity.BaseDailyAmount` etc.
    - `MapFromOptions`: Reverse mapping. Same simplification.
    - `MultiplierTierData` in DcaConfiguration stays as raw `decimal` (jsonb). So the tier mapping must convert: `new MultiplierTier { DropPercentage = Percentage.From(t.DropPercentage), Multiplier = Multiplier.From(t.Multiplier) }` and reverse: `new MultiplierTierData(t.DropPercentage.Value, t.Multiplier.Value)`.
    - `GetDefaultsAsync` creates a new `DcaOptions()` and binds from config -- this will work because of the TypeConverter addition to VogenGlobalConfig.
  </action>
  <verify>
    `dotnet build TradingBot.sln` compiles. Verify DcaOptions fields are value objects. Verify DcaOptionsValidator has fewer but still meaningful validations.
  </verify>
  <done>
    DcaOptions uses value objects for all numeric domain fields. Configuration binding works via TypeConverter. DcaOptionsValidator is simplified to cross-field business rules only. ConfigurationService maps correctly between entities, config, and DTOs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update MultiplierCalculator, BacktestSimulator, services, handlers, and refresh tests</name>
  <files>
    TradingBot.ApiService/Application/Services/MultiplierCalculator.cs
    TradingBot.ApiService/Application/Services/BacktestSimulator.cs
    TradingBot.ApiService/Application/Services/Backtest/BacktestConfig.cs
    TradingBot.ApiService/Application/Services/Backtest/DailyPriceData.cs
    TradingBot.ApiService/Application/Services/Backtest/PurchaseLogEntry.cs
    TradingBot.ApiService/Application/Services/Backtest/BacktestResult.cs
    TradingBot.ApiService/Application/Services/DcaExecutionService.cs
    TradingBot.ApiService/Application/Services/PriceDataService.cs
    TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
    TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
  </files>
  <action>
    **MultiplierCalculator.cs** -- Update signature and internals:
    - Parameters: `Price currentPrice`, `UsdAmount baseAmount`, `Price high30Day`, `Price ma200Day`, `IReadOnlyList<MultiplierTier> tiers`, `Multiplier bearBoostFactor`, `Multiplier maxCap`
    - Internal arithmetic uses `.Value` to extract decimals for calculations that don't map cleanly to cross-type operators, OR use cross-type operators where applicable
    - `dropPercentage` calculation: `(high30Day.Value - currentPrice.Value) / high30Day.Value * 100m` -- note this produces a percentage in 0-100 format (for tier matching). The MultiplierCalculator currently uses 0-100 format internally (e.g., `>= 5%` means >= 5.0). This is different from the `Percentage` value object which stores 0-1 format. **Decision: Keep MultiplierCalculator using raw decimal for dropPercentage internally (0-100 format). Only wrap in Percentage(0-1 format) for the output.** The `dropPercentage` in MultiplierResult should be the raw percentage (0-100 format) as a `decimal`, not a `Percentage` value object, because MultiplierTier.DropPercentage from config is also in 0-100 format. OR: standardize everything to 0-1 format. **CRITICAL: Check what format DcaOptions MultiplierTier.DropPercentage uses.** Looking at appsettings.json and current code: `dropPercentage >= t.DropPercentage` where `dropPercentage = (high-current)/high * 100`. So tiers use 0-100 format. The context decision says "Percentage: stored as 0-1 format (0.05 = 5%)". This means we need to convert: tier thresholds in config become 0-1 format (e.g., 0.05 instead of 5). Update `MultiplierCalculator` to work in 0-1 format throughout: `dropPercentage = (high30Day.Value - currentPrice.Value) / high30Day.Value` (no * 100). Tier matching: `dropPercentage >= t.DropPercentage.Value`. Tier label: `$">= {t.DropPercentage.Value * 100:F1}%"`.
    - `MultiplierResult` record: update fields to value objects where appropriate:
      - `Multiplier` -> `Multiplier Multiplier`
      - `DropPercentage` -> `Percentage DropPercentage`
      - `High30Day` -> `Price High30Day`
      - `Ma200Day` -> `Price Ma200Day`
      - `FinalAmount` -> `UsdAmount FinalAmount`
      - `BearBoostApplied` -> keep as `decimal` (it's an additive amount, not a standalone multiplier -- it can be 0)
      - `Tier` -> stays `string`
      - `IsBearMarket` -> stays `bool`
    - Add `using TradingBot.ApiService.Models.Values;` and `using TradingBot.ApiService.Configuration;`
    - Use value object arithmetic where it reads naturally: `baseAmount * finalMultiplier` for `FinalAmount`
    - For `uncappedMultiplier = tierMultiplier + bearBoostApplied`: since bearBoostApplied can be 0 and Multiplier rejects 0, handle this differently. Use raw decimal arithmetic: `var uncapped = tierMultiplier.Value + bearBoostApplied; var final = Math.Min(uncapped, maxCap.Value); var finalMultiplier = Multiplier.From(final);`

    **BacktestConfig.cs** -- Update record fields:
    - `decimal BaseDailyAmount` -> `UsdAmount BaseDailyAmount`
    - `decimal BearBoostFactor` -> `Multiplier BearBoostFactor`
    - `decimal MaxMultiplierCap` -> `Multiplier MaxMultiplierCap`
    - `MultiplierTierConfig` stays as `record(decimal DropPercentage, decimal Multiplier)` -- this is a backtest-internal DTO. BUT since MultiplierTier now uses value objects, the conversion in BacktestSimulator needs updating. Consider: either update MultiplierTierConfig to use value objects too, or convert at the boundary.
    - **Decision**: Update `MultiplierTierConfig` to use value objects: `record MultiplierTierConfig(Percentage DropPercentage, Multiplier Multiplier)`. This keeps the backtest config type-safe and matches DcaOptions.MultiplierTier.

    **DailyPriceData.cs** -- Keep as raw decimals. This is a backtest input record that comes from historical data queries. Using value objects here would require wrapping every row from the database, adding overhead. BacktestSimulator will wrap in value objects at the calculation boundary (when calling MultiplierCalculator).

    **PurchaseLogEntry.cs** -- Keep as raw decimals. This is a snapshot-tested output record. Changing to value objects would break snapshots AND add serialization complexity. The implicit cast from value objects to decimals handles the assignment in BacktestSimulator.

    **BacktestResult.cs** -- Keep `DcaMetrics`, `ComparisonMetrics`, `TierBreakdownEntry` as raw decimals. These are API response DTOs serialized to JSON. Raw decimals serialize as numbers directly.

    **BacktestSimulator.cs** -- Update to work with typed BacktestConfig:
    - Convert `MultiplierTierConfig` to `MultiplierTier` for `MultiplierCalculator` call: `new MultiplierTier { DropPercentage = t.DropPercentage, Multiplier = t.Multiplier }` (now both are value objects, direct assignment)
    - Wrap price data in value objects at `MultiplierCalculator.Calculate` call site: `Price.From(day.Close)`, `UsdAmount.From(config.BaseDailyAmount.Value)` -- wait, `config.BaseDailyAmount` IS already `UsdAmount`. And `day.Close` is raw decimal from `DailyPriceData`. So: `Price.From(day.Close)`, `config.BaseDailyAmount`, `Price.From(high30Day)`, `Price.From(ma200Day)`, etc.
    - Extract results back to raw decimals for `DayData` and `PurchaseLogEntry`: `multiplierResult.Multiplier.Value`, `multiplierResult.FinalAmount.Value`, etc.
    - `DayData` private record stays as raw decimals (internal to BacktestSimulator)
    - The tier breakdown calculation needs update: `d.AmountUsd - config.BaseDailyAmount.Value` (extract decimal from UsdAmount)

    **DcaExecutionService.cs** -- Update to work with value objects:
    - `currentPrice` from `GetSpotPriceAsync` is `decimal` -- wrap: `Price.From(currentPrice)` or keep raw and pass to MultiplierCalculator wrapped
    - `CalculateMultiplierAsync` internal method: pass value objects to `MultiplierCalculator.Calculate`
    - Purchase entity creation: fields are already value objects from Plan 01, so `Price = Price.From(currentPrice)`, `Quantity = Quantity.From(0)`, `Cost = UsdAmount.From(0)` -- wait, UsdAmount rejects 0! **IMPORTANT**: For pending purchases, Cost starts at 0 and Quantity starts at 0. Quantity allows zero. But UsdAmount does NOT allow zero. Solution: use a small epsilon or restructure. Better solution: make initial values nullable or use a "pending" pattern. Actually, looking at the code: `Cost = 0` is set initially, then updated to `filledQty * avgPrice`. Since UsdAmount rejects 0, we need to handle this differently. Options:
      1. Don't set Cost until filled (make it nullable) -- but this changes the entity schema
      2. Allow zero in UsdAmount -- but context says "strictly positive (> 0)"
      3. Set Cost to a dummy value initially and update on fill -- hacky
      4. **Best option**: Keep Cost as `UsdAmount` but create the Purchase with a valid Cost from the start. For pending: `Cost = UsdAmount.From(usdAmount)` (the intended spend amount). On fill, update to actual. For dry-run: `Cost = UsdAmount.From(roundedQuantity * currentPrice)` which is already positive.
    - Actually, re-reading the code: the initial `Cost = 0` is immediately overwritten in both dry-run and real-order paths before the purchase is persisted. The `0` is never saved to DB. BUT it's set in the initializer. To avoid the validation exception, set `Cost = UsdAmount.From(usdAmount)` as the initial value (the intended spend). Same for `Quantity = Quantity.From(0)` which IS allowed (zero quantity ok).
    - Similarly, `Price = currentPrice` at creation becomes `Price = Price.From(currentPrice)` which is valid (positive).
    - On fill update: `purchase.Quantity = Quantity.From(filledQty)`, `purchase.Price = Price.From(avgPrice)`, `purchase.Cost = UsdAmount.From(filledQty * avgPrice)`.
    - `multipliedAmount = options.BaseDailyAmount * multiplierResult.Multiplier` -- this is `UsdAmount * Multiplier = UsdAmount` (cross-type operator from Plan 01). But `multiplierResult.Multiplier` is now the value object type. This should work with the operator defined in UsdAmount.
    - `usdAmount = Math.Min(usdcBalance, multipliedAmount)` -- `usdcBalance` is `decimal`, `multipliedAmount` is `UsdAmount`. Use: `UsdAmount.From(Math.Min(usdcBalance, multipliedAmount.Value))`
    - `btcQuantity = usdAmount / currentPrice` -- if `usdAmount` is `UsdAmount` and `currentPrice` is `decimal`, use: `var btcQuantity = usdAmount.Value / currentPrice` (raw arithmetic for rounding), or wrap: `Quantity btcQty = usdAmount / Price.From(currentPrice)`.
    - For balance check: `if (usdcBalance < MinimumBalance)` stays as raw decimal comparison
    - For order amount check: `if (usdAmount < MinimumOrderValue)` -- `usdAmount` is now `UsdAmount`, so either `usdAmount.Value < MinimumOrderValue` or define MinimumOrderValue as UsdAmount
    - Fallback `MultiplierCalculator.Calculate` call with `0m` for high30Day/ma200Day: `Price.From(0)` would FAIL validation (Price rejects 0). **IMPORTANT**: Need to handle sentinel 0 values. Options: (a) Use `Price.From(0.0000001m)` -- hacky, (b) Change fallback to not call MultiplierCalculator at all, return a default result, (c) Allow sentinel 0 for Price. Since the context says "strictly positive", we cannot allow 0. **Best approach**: Create the fallback `MultiplierResult` directly without calling `MultiplierCalculator.Calculate`:
    ```csharp
    return new MultiplierResult(
        Multiplier: Multiplier.From(1.0m),
        Tier: "Base",
        IsBearMarket: false,
        BearBoostApplied: 0m,
        DropPercentage: Percentage.From(0m),
        High30Day: Price.From(currentPrice), // use current price as fallback
        Ma200Day: Price.From(currentPrice),
        FinalAmount: baseAmount);
    ```
    And in MultiplierCalculator.Calculate, the `high30Day > 0` sentinel check becomes checking a nullable or a bool flag. **Simplest approach**: Make `high30Day` and `ma200Day` parameters `decimal` in MultiplierCalculator (they come from PriceDataService which returns `decimal` including 0 sentinel). Then wrap in Price only for the result. This avoids the Price(0) validation issue. **Even better**: Change MultiplierCalculator parameters to use nullable Price? for high30Day/ma200Day. If null, no multiplier calculation. This is more explicit than the 0 sentinel. **Recommended approach**: Keep `high30Day` and `ma200Day` as `decimal` parameters in MultiplierCalculator (since PriceDataService returns decimal with 0 sentinel). Only wrap the result values in Price. This is the least disruptive change and avoids the Price(0) issue entirely. Update MultiplierResult to keep High30Day/Ma200Day as `decimal` (not Price) since they can be 0.

    **REVISED MultiplierCalculator decision**: Keep `high30Day` and `ma200Day` as `decimal` parameters (sentinel 0 = unavailable). Keep `MultiplierResult.High30Day` and `MultiplierResult.Ma200Day` as `decimal` (can be 0). Only apply value objects to: `currentPrice` (Price), `baseAmount` (UsdAmount), `bearBoostFactor` (Multiplier), `maxCap` (Multiplier), `tiers` (MultiplierTier with value objects), and results `Multiplier` (Multiplier), `DropPercentage` (decimal -- stays 0-100 format to avoid config format migration), `FinalAmount` (UsdAmount). Actually, since we decided Percentage is 0-1 format and tiers now use Percentage, the dropPercentage calculation MUST use 0-1 format: `dropPercentage = (high30Day - currentPrice) / high30Day`. Tier matching: `dropPercentage >= t.DropPercentage.Value`. Tier label needs `* 100` for display. The `MultiplierResult.DropPercentage` should be `decimal` in 0-1 format (raw decimal, not Percentage, since it can be negative if price > high which shouldn't happen but defensive coding). Or use Percentage if always 0-1. If high30Day is 0 (sentinel), dropPercentage stays 0. `Percentage.From(0)` IS valid (>= 0). So use Percentage for the result field.

    **FINAL MultiplierCalculator approach**:
    - Params: `Price currentPrice, UsdAmount baseAmount, decimal high30Day, decimal ma200Day, IReadOnlyList<MultiplierTier> tiers, Multiplier bearBoostFactor, Multiplier maxCap`
    - Internal: work with `.Value` extractions and raw decimals for arithmetic
    - Drop percentage: `decimal drop = high30Day > 0 ? (high30Day - currentPrice.Value) / high30Day : 0m;` (0-1 format)
    - Tier matching: `drop >= t.DropPercentage.Value` (both 0-1 format now)
    - Tier label: `$">= {t.DropPercentage.Value * 100:F1}%"`
    - Bear check: `ma200Day > 0 && currentPrice.Value < ma200Day`
    - Result: `Multiplier.From(finalMult)`, `Percentage.From(Math.Clamp(drop, 0, 1))`, `UsdAmount.From(baseAmount.Value * finalMult)`
    - Keep `High30Day` and `Ma200Day` as `decimal` in MultiplierResult (can be 0 sentinel)

    **PriceDataService.cs** -- Keep return types as `decimal` for `Get30DayHighAsync` and `Get200DaySmaAsync`. These return 0 as a sentinel for "data unavailable". Callers (DcaExecutionService, BacktestSimulator) pass the raw decimal to MultiplierCalculator which handles the 0 sentinel. The service parameters `string symbol` could become `Symbol symbol` but this creates unnecessary churn -- the LINQ queries use `p.Symbol == symbol` which works with implicit cast. **Decision**: Change parameter to `Symbol symbol` for type safety (callers already use `Symbol.Btc` after Plan 01 updates DailyPrice). The LINQ `p.Symbol == symbol` works because EF Core uses the registered value converter. But actually, `PriceDataService` is called with `"BTC"` string. After value objects, callers should use `Symbol.Btc`. Update PriceDataService method signatures to accept `Symbol symbol` and update call sites to pass `Symbol.Btc`. Also update `BootstrapHistoricalDataAsync` and `FetchAndStoreDailyCandleAsync` to take `Symbol`.

    **PurchaseCompletedHandler.cs** -- Update to use value objects from PurchaseCompletedEvent:
    - `notification.Price` is now `Price`, format with `.Value` for string interpolation: `${notification.Price.Value:N2}`
    - `notification.BtcAmount` is now `Quantity`: `{notification.BtcAmount.Value:F5}`
    - `notification.UsdSpent` is now `UsdAmount`: `${notification.UsdSpent.Value:F2}`
    - Similarly for all other typed fields
    - `BuildMultiplierReasoning`: comparisons like `e.Multiplier == 1.0m` need update. Since Multiplier has implicit to-decimal cast, `e.Multiplier == Multiplier.From(1.0m)` or use `e.Multiplier.Value == 1.0m`. The implicit cast means `e.Multiplier == 1.0m` might work but is ambiguous. Use `.Value` for clarity: `e.Multiplier.Value == 1.0m`.
    - `e.DropPercentage > 0` becomes `e.DropPercentage.Value > 0` or `e.DropPercentage > Percentage.From(0)`
    - `e.High30Day > 0` -- High30Day is now `decimal` in MultiplierResult, but in PurchaseCompletedEvent it's `Price`. If we kept it as Price, `Price.From(0)` would fail. **IMPORTANT**: Purchase entity has `Price High30Day` which can store 0 from legacy data. This is a problem -- Price rejects 0. **Resolution**: Purchase.High30Day and Purchase.Ma200Day CAN be 0 (sentinel for "not available"). Since Price rejects 0, we need to either: (a) make them nullable `Price?`, (b) use decimal for these fields, or (c) relax Price validation to allow 0. **Best approach**: Make `Purchase.High30Day` and `Purchase.Ma200Day` nullable `Price?` on the entity, and `PurchaseCompletedEvent.High30Day`/`Ma200Day` as `decimal` (keeping the sentinel pattern). This requires updating Plan 01's entity changes.
    - **ALTERNATIVE simpler approach**: Keep `High30Day` and `Ma200Day` as `decimal` on the Purchase entity (don't wrap them in Price). They're metadata/audit fields that can be 0 (sentinel), not core domain values. This is pragmatic: only wrap fields where Price semantics are guaranteed (Purchase.Price is always positive when filled). Update Plan 01's entity: revert High30Day and Ma200Day to `decimal`. Similarly in PurchaseCompletedEvent.
    - **FINAL DECISION for this plan**: High30Day and Ma200Day stay as `decimal` on Purchase entity and PurchaseCompletedEvent (not wrapped in Price). They use 0 as sentinel for "unavailable". Only `Purchase.Price` (the actual trade price) becomes `Price` value object.

    **DashboardEndpoints.cs** -- The endpoint code reads from entities with value objects and maps to DTO records with raw decimals. Implicit casts from value objects to decimals handle this. Verify compilation. Update any explicit conversions if needed. The LINQ projections like `Price = p.Price` where source is `Price` (value object) and target is `decimal` work via implicit cast.

    **Tests** -- After all changes:
    1. Run `dotnet test` -- if MultiplierCalculator tests fail due to signature changes, update test files to pass value objects
    2. If BacktestSimulator snapshot tests fail, run `UPDATE_SNAPSHOTS=true dotnet test` to regenerate snapshots, then re-run `dotnet test` to verify they pass
    3. Ensure all 53 tests pass

    **IMPORTANT NOTE ON PERCENTAGE FORMAT MIGRATION**: The current appsettings.json likely has MultiplierTier DropPercentage values in 0-100 format (e.g., `5` for 5%). After this change, Percentage uses 0-1 format (e.g., `0.05` for 5%). You MUST update `appsettings.json` (and any test data) to use 0-1 format for DropPercentage values. Check `appsettings.json` for the current values and convert them. Also update any test data in `MultiplierCalculatorTests` and `BacktestSimulatorTests` to use 0-1 format.
  </action>
  <verify>
    `dotnet build TradingBot.sln` compiles with zero errors. `dotnet test` passes all 53 tests (with snapshot refresh if needed). Verify MultiplierCalculator signature accepts value objects. Verify DcaOptions binds correctly by checking that the application starts without configuration binding errors.
  </verify>
  <done>
    All services, config, and backtest code use value objects. MultiplierCalculator has typed signature. DcaOptions binds from config with TypeConverter. DcaOptionsValidator simplified. All tests pass. Percentage format standardized to 0-1.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` -- zero compilation errors
2. `dotnet test` -- all tests pass (53 expected, may change if snapshot format changes)
3. Verify DcaOptions config binding: check that `appsettings.json` values (updated to 0-1 format for percentages) bind correctly
4. Verify MultiplierCalculator tests still validate correct behavior with value object inputs
5. Verify BacktestSimulator snapshot tests are current (regenerated if format changed)
</verification>

<success_criteria>
- DcaOptions uses UsdAmount, Multiplier, Percentage value objects with config binding
- MultiplierCalculator.Calculate accepts typed parameters
- BacktestSimulator works with typed BacktestConfig
- DcaExecutionService creates purchases with value objects
- PriceDataService accepts Symbol parameter
- All 53+ tests pass
- DcaOptionsValidator simplified to cross-field rules only
- Percentage format standardized to 0-1 throughout
</success_criteria>

<output>
After completion, create `.planning/phases/14-value-objects/14-02-SUMMARY.md`
</output>
