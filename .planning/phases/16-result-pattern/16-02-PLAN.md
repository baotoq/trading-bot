---
phase: 16-result-pattern
plan: 02
type: execute
wave: 2
depends_on: [16-01]
files_modified:
  - TradingBot.ApiService/Application/Services/ConfigurationService.cs
  - TradingBot.ApiService/Endpoints/ConfigurationEndpoints.cs
autonomous: true
requirements: [EH-02, EH-03]

must_haves:
  truths:
    - "ConfigurationService.UpdateAsync returns ErrorOr<Updated> and does not use try/catch for domain validation"
    - "ConfigurationEndpoints.UpdateConfigAsync uses ToHttpResult() to map ErrorOr to RFC 7807 Problem Details"
    - "Validation failures from DcaConfiguration behavior methods propagate as ErrorOr errors through service to endpoint"
    - "All 53 existing tests pass without regression"
  artifacts:
    - path: "TradingBot.ApiService/Application/Services/ConfigurationService.cs"
      provides: "ConfigurationService using ErrorOr pattern for orchestration"
      contains: "ErrorOr<Updated>"
    - path: "TradingBot.ApiService/Endpoints/ConfigurationEndpoints.cs"
      provides: "Configuration endpoint mapping ErrorOr to HTTP responses"
      contains: "ToHttpResult"
  key_links:
    - from: "TradingBot.ApiService/Endpoints/ConfigurationEndpoints.cs"
      to: "TradingBot.ApiService/BuildingBlocks/ErrorOrExtensions.cs"
      via: "ToHttpResult() call on service result"
      pattern: "ToHttpResult"
    - from: "TradingBot.ApiService/Application/Services/ConfigurationService.cs"
      to: "TradingBot.ApiService/Models/DcaConfiguration.cs"
      via: "Calling behavior methods and checking .IsError"
      pattern: "\\.IsError"
---

<objective>
Update ConfigurationService to return ErrorOr<Updated> from UpdateAsync (replacing try/catch with result propagation), update ConfigurationEndpoints to use ToHttpResult() extension, and verify all 53 tests pass.

Purpose: Complete the end-to-end ErrorOr flow from aggregate -> service -> endpoint, proving the result pattern works in practice. Removes exception-based error handling from the domain/application boundary.
Output: ConfigurationService returns ErrorOr, endpoint maps to Problem Details, full test suite green.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-result-pattern/16-CONTEXT.md
@.planning/phases/16-result-pattern/16-01-SUMMARY.md
@TradingBot.ApiService/Application/Services/ConfigurationService.cs
@TradingBot.ApiService/Endpoints/ConfigurationEndpoints.cs
@TradingBot.ApiService/BuildingBlocks/ErrorOrExtensions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ConfigurationService to return ErrorOr and propagate domain errors</name>
  <files>
    TradingBot.ApiService/Application/Services/ConfigurationService.cs
  </files>
  <action>
1. Add `using ErrorOr;` import.

2. Change `IConfigurationService.UpdateAsync` signature:
   ```csharp
   Task<ErrorOr<Updated>> UpdateAsync(DcaOptions options, CancellationToken ct = default);
   ```

3. Update `ConfigurationService.UpdateAsync` implementation:

   a. Keep DcaOptionsValidator call at the top as defense-in-depth (per locked decision). But change its failure handling from `throw new ValidationException(...)` to returning `ErrorOr` errors:
   ```csharp
   var validationResult = validator.Validate(Options.DefaultName, options);
   if (validationResult.Failed)
   {
       return Error.Validation("ConfigValidationFailed",
           string.Join("; ", validationResult.Failures ?? []));
   }
   ```

   b. For the UPDATE path (entity != null), call behavior methods and CHECK their ErrorOr results. If any returns an error, propagate it immediately:
   ```csharp
   // UpdateDailyAmount is void (no ErrorOr needed)
   entity.UpdateDailyAmount(options.BaseDailyAmount);

   var scheduleResult = entity.UpdateSchedule(options.DailyBuyHour, options.DailyBuyMinute);
   if (scheduleResult.IsError) return scheduleResult.Errors;

   var tiersResult = entity.UpdateTiers(options.MultiplierTiers
       .Select(t => new MultiplierTierData(t.DropPercentage.Value, t.Multiplier.Value))
       .ToList());
   if (tiersResult.IsError) return tiersResult.Errors;

   var bearResult = entity.UpdateBearMarket(options.BearMarketMaPeriod, options.BearBoostFactor);
   if (bearResult.IsError) return bearResult.Errors;

   var settingsResult = entity.UpdateSettings(options.HighLookbackDays, options.DryRun, options.MaxMultiplierCap);
   if (settingsResult.IsError) return settingsResult.Errors;
   ```

   c. For the CREATE path (entity == null), `DcaConfiguration.Create()` still throws per locked decision -- this is fine for expected valid input (validator already passed). Keep the Create call as-is.

   d. After SaveChanges and cache invalidation, return success:
   ```csharp
   return Result.Updated;
   ```

4. Remove the `using System.ComponentModel.DataAnnotations;` import if no longer needed (ValidationException is no longer thrown from this service).
  </action>
  <verify>
    `dotnet build TradingBot.sln` compiles with 0 errors. ConfigurationService.UpdateAsync returns ErrorOr&lt;Updated&gt;. No try/catch for domain validation remains.
  </verify>
  <done>
    ConfigurationService returns ErrorOr&lt;Updated&gt; from UpdateAsync. Domain validation errors from DcaConfiguration behavior methods propagate as ErrorOr errors. DcaOptionsValidator error converted to ErrorOr. No exception-based domain error handling remains in service.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ConfigurationEndpoints to use ToHttpResult and verify all tests pass</name>
  <files>
    TradingBot.ApiService/Endpoints/ConfigurationEndpoints.cs
  </files>
  <action>
1. Add `using TradingBot.ApiService.BuildingBlocks;` import (for ErrorOrExtensions).

2. Update `UpdateConfigAsync` endpoint:

   a. Remove the try/catch block wrapping the configService.UpdateAsync call.

   b. Call configService.UpdateAsync and use ToHttpResult():
   ```csharp
   private static async Task<IResult> UpdateConfigAsync(
       UpdateConfigRequest request,
       IConfigurationService configService,
       ILogger<Program> logger,
       CancellationToken ct)
   {
       var options = new DcaOptions
       {
           BaseDailyAmount = request.BaseDailyAmount,
           // ... same property mapping as before
       };

       var result = await configService.UpdateAsync(options, ct);

       if (result.IsError)
       {
           logger.LogWarning("Configuration update failed: {Errors}",
               string.Join(", ", result.Errors.Select(e => e.Code)));
           return result.ToHttpResult();
       }

       logger.LogInformation(
           "DCA configuration updated: BaseDailyAmount={BaseDailyAmount}, DailyBuyTime={Hour}:{Minute}, DryRun={DryRun}",
           options.BaseDailyAmount,
           options.DailyBuyHour,
           options.DailyBuyMinute,
           options.DryRun);

       return Results.Ok(new { message = "Configuration updated successfully" });
   }
   ```

   c. Remove `using System.ComponentModel.DataAnnotations;` import (ValidationException catch removed).

3. Run full test suite: `dotnet test TradingBot.sln`
   - All 53 tests must pass (24 MultiplierCalculator + 28 BacktestSimulator + 1 integration)
   - Tests do NOT directly test ConfigurationService or endpoints, so they should pass without modification
   - If any test fails, investigate and fix

4. Run `dotnet build TradingBot.sln` to confirm zero errors and zero warnings related to ErrorOr changes.
  </action>
  <verify>
    `dotnet test TradingBot.sln` passes all 53 tests. `dotnet build TradingBot.sln` compiles with 0 errors. ConfigurationEndpoints uses ToHttpResult() with no try/catch for ValidationException. Validation errors return RFC 7807 Problem Details with 400 status.
  </verify>
  <done>
    ConfigurationEndpoints maps ErrorOr results to RFC 7807 Problem Details via ToHttpResult(). No exception-based error handling at endpoint level for domain/validation errors. Full test suite (53 tests) passes green. End-to-end ErrorOr flow: aggregate -> service -> endpoint complete.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` -- 0 errors
2. `dotnet test TradingBot.sln` -- 53 tests pass
3. ConfigurationService.UpdateAsync returns ErrorOr&lt;Updated&gt; (no try/catch for domain logic)
4. ConfigurationEndpoints uses ToHttpResult() (no catch(ValidationException))
5. Invalid schedule/tier/bear-market/settings inputs return 400 Problem Details (not 500 exception)
</verification>

<success_criteria>
- ConfigurationService orchestrates with ErrorOr pattern (EH-03)
- ConfigurationEndpoints maps ErrorOr to HTTP status codes via ToHttpResult (EH-02)
- No try/catch for domain validation in service or endpoint layers
- All 53 tests pass without regression
- Full build succeeds with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-result-pattern/16-02-SUMMARY.md`
</output>
