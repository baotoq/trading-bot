---
phase: 06-backtest-simulation-engine
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Application/Services/Backtest/BacktestConfig.cs
  - TradingBot.ApiService/Application/Services/Backtest/BacktestResult.cs
  - TradingBot.ApiService/Application/Services/Backtest/DailyPriceData.cs
  - TradingBot.ApiService/Application/Services/Backtest/PurchaseLogEntry.cs
  - TradingBot.ApiService/Application/Services/BacktestSimulator.cs
  - tests/TradingBot.ApiService.Tests/Application/Services/BacktestSimulatorTests.cs
autonomous: true

must_haves:
  truths:
    - "BacktestSimulator.Run() accepts a BacktestConfig and price array and returns a BacktestResult"
    - "Smart DCA purchases use MultiplierCalculator.Calculate() for each day's multiplier"
    - "Same-base fixed DCA buys config.BaseDailyAmount every day regardless of price movement"
    - "Sliding windows compute 30-day high from available data with warmup for insufficient days"
    - "MA200 returns 0 when insufficient data (conservative: no bear detection during warmup)"
    - "Running totals (cumulative USD, cumulative BTC, running cost basis) accumulate correctly across all days"
    - "Same inputs always produce identical outputs (deterministic)"
  artifacts:
    - path: "TradingBot.ApiService/Application/Services/Backtest/BacktestConfig.cs"
      provides: "Backtest-specific configuration record"
      contains: "record BacktestConfig"
    - path: "TradingBot.ApiService/Application/Services/Backtest/BacktestResult.cs"
      provides: "Nested result structure with all metric sections"
      contains: "record BacktestResult"
    - path: "TradingBot.ApiService/Application/Services/Backtest/DailyPriceData.cs"
      provides: "Input price data record for simulation"
      contains: "record DailyPriceData"
    - path: "TradingBot.ApiService/Application/Services/Backtest/PurchaseLogEntry.cs"
      provides: "Day-by-day purchase log with smart + fixed DCA side-by-side"
      contains: "record PurchaseLogEntry"
    - path: "TradingBot.ApiService/Application/Services/BacktestSimulator.cs"
      provides: "Pure static simulation engine"
      contains: "static class BacktestSimulator"
    - path: "tests/TradingBot.ApiService.Tests/Application/Services/BacktestSimulatorTests.cs"
      provides: "Core simulation TDD tests"
      contains: "class BacktestSimulatorTests"
  key_links:
    - from: "BacktestSimulator.cs"
      to: "MultiplierCalculator.cs"
      via: "MultiplierCalculator.Calculate() static call"
      pattern: "MultiplierCalculator\\.Calculate"
    - from: "BacktestSimulator.cs"
      to: "BacktestConfig.cs"
      via: "Config parameter provides tiers, base amount, lookback periods"
      pattern: "BacktestConfig config"
    - from: "BacktestSimulatorTests.cs"
      to: "BacktestSimulator.cs"
      via: "Tests call BacktestSimulator.Run() and assert on BacktestResult"
      pattern: "BacktestSimulator\\.Run"
---

<objective>
Build the core BacktestSimulator with all DTOs, smart DCA simulation loop, same-base fixed DCA baseline, and sliding window calculations using TDD.

Purpose: Establish the simulation engine foundation that replays a smart DCA strategy day-by-day against historical prices, computing multipliers via the existing MultiplierCalculator, and tracks running totals for both smart and same-base fixed DCA.

Output: Pure static BacktestSimulator with partial results (smart DCA + same-base metrics + purchase log), verified by TDD tests. Plan 02 adds match-total, comparison metrics, tier breakdown, and max drawdown.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-backtest-simulation-engine/06-RESEARCH.md
@.planning/phases/06-backtest-simulation-engine/06-CONTEXT.md
@.planning/phases/05-multiplier-calculator-extraction/05-01-SUMMARY.md
@TradingBot.ApiService/Application/Services/MultiplierCalculator.cs
@TradingBot.ApiService/Configuration/DcaOptions.cs
@TradingBot.ApiService/Models/DailyPrice.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Create DTOs and write failing tests for core simulation</name>
  <files>
    TradingBot.ApiService/Application/Services/Backtest/BacktestConfig.cs
    TradingBot.ApiService/Application/Services/Backtest/BacktestResult.cs
    TradingBot.ApiService/Application/Services/Backtest/DailyPriceData.cs
    TradingBot.ApiService/Application/Services/Backtest/PurchaseLogEntry.cs
    TradingBot.ApiService/Application/Services/BacktestSimulator.cs
    tests/TradingBot.ApiService.Tests/Application/Services/BacktestSimulatorTests.cs
  </files>
  <action>
    **Create all record types in `Application/Services/Backtest/` namespace `TradingBot.ApiService.Application.Services.Backtest`:**

    1. **DailyPriceData.cs** - Input record for simulation:
       ```csharp
       public record DailyPriceData(DateOnly Date, decimal Open, decimal High, decimal Low, decimal Close, decimal Volume);
       ```

    2. **BacktestConfig.cs** - Backtest-specific configuration (mirrors DcaOptions multiplier fields, omits schedule fields):
       ```csharp
       public record BacktestConfig(
           decimal BaseDailyAmount,
           int HighLookbackDays,
           int BearMarketMaPeriod,
           decimal BearBoostFactor,
           decimal MaxMultiplierCap,
           IReadOnlyList<MultiplierTierConfig> Tiers);
       public record MultiplierTierConfig(decimal DropPercentage, decimal Multiplier);
       ```
       Reference `TradingBot.ApiService.Configuration.MultiplierTier` -- create a new `MultiplierTierConfig` record in the Backtest namespace to avoid coupling backtest DTOs to mutable configuration classes. BacktestSimulator will convert to `MultiplierTier` when calling MultiplierCalculator.

    3. **PurchaseLogEntry.cs** - Single day's full detail with ALL three strategies side-by-side:
       ```csharp
       public record PurchaseLogEntry(
           DateOnly Date,
           decimal Price,
           // Smart DCA
           decimal SmartMultiplier,
           string SmartTier,
           decimal SmartAmountUsd,
           decimal SmartBtcBought,
           decimal SmartCumulativeUsd,
           decimal SmartCumulativeBtc,
           decimal SmartRunningCostBasis,
           // Fixed DCA (same-base)
           decimal FixedSameBaseAmountUsd,
           decimal FixedSameBaseBtcBought,
           decimal FixedSameBaseCumulativeUsd,
           decimal FixedSameBaseCumulativeBtc,
           decimal FixedSameBaseRunningCostBasis,
           // Fixed DCA (match-total) -- populated in Plan 02, default 0m for now
           decimal FixedMatchTotalAmountUsd,
           decimal FixedMatchTotalBtcBought,
           decimal FixedMatchTotalCumulativeUsd,
           decimal FixedMatchTotalCumulativeBtc,
           decimal FixedMatchTotalRunningCostBasis,
           // Window values for transparency
           decimal High30Day,
           decimal Ma200Day);
       ```

    4. **BacktestResult.cs** - Full nested result structure:
       ```csharp
       public record BacktestResult(
           DcaMetrics SmartDca,
           DcaMetrics FixedDcaSameBase,
           DcaMetrics FixedDcaMatchTotal,
           ComparisonMetrics Comparison,
           IReadOnlyList<TierBreakdownEntry> TierBreakdown,
           IReadOnlyList<PurchaseLogEntry> PurchaseLog);

       public record DcaMetrics(
           decimal TotalInvested,
           decimal TotalBtc,
           decimal AvgCostBasis,
           decimal PortfolioValue,
           decimal ReturnPercent,
           decimal MaxDrawdown);

       public record ComparisonMetrics(
           decimal CostBasisDeltaSameBase,     // Smart avg cost - SameBase avg cost (negative = smart is cheaper)
           decimal CostBasisDeltaMatchTotal,   // Smart avg cost - MatchTotal avg cost
           decimal ExtraBtcPercentSameBase,    // (Smart BTC - SameBase BTC) / SameBase BTC * 100
           decimal ExtraBtcPercentMatchTotal,  // (Smart BTC - MatchTotal BTC) / MatchTotal BTC * 100
           decimal EfficiencyRatio);           // Smart return % / SameBase return %

       public record TierBreakdownEntry(
           string TierName,
           int TriggerCount,
           decimal ExtraUsdSpent,
           decimal ExtraBtcAcquired);
       ```
       Use `DcaMetrics` (not separate SmartDcaMetrics/FixedDcaMetrics) since both contain the same fields including MaxDrawdown.

    5. **BacktestSimulator.cs** - STUB only (returns dummy result for compilation):
       ```csharp
       public static class BacktestSimulator
       {
           public static BacktestResult Run(BacktestConfig config, IReadOnlyList<DailyPriceData> priceData)
           {
               throw new NotImplementedException();
           }
       }
       ```

    **Write failing tests in BacktestSimulatorTests.cs:**

    Create a test helper that builds a standard BacktestConfig (BaseDailyAmount=10, HighLookbackDays=30, BearMarketMaPeriod=200, BearBoostFactor=1.5, MaxMultiplierCap=4.5, Tiers=[5%->1.5x, 10%->2.0x, 20%->3.0x]).

    Create a helper that generates price data: `CreatePriceData(params decimal[] closePrices)` that creates DailyPriceData records with sequential dates starting from 2024-01-01, High=Close*1.01, Low=Close*0.99, Open=Close, Volume=100.

    Tests to write (all should FAIL since Run() throws NotImplementedException):

    a. **Run_ReturnsCorrectDayCount** - 30 days of price data -> PurchaseLog.Count == 30
    b. **Run_SmartDca_NoDrop_UsesBaseAmount** - Flat prices (all same) -> each SmartAmountUsd == BaseDailyAmount, SmartMultiplier == 1.0
    c. **Run_SmartDca_WithDrop_AppliesMultiplier** - Price drops 10% from high -> SmartMultiplier should be 2.0x
    d. **Run_FixedSameBase_AlwaysUsesBaseAmount** - Regardless of price movement, FixedSameBaseAmountUsd == BaseDailyAmount every day
    e. **Run_RunningTotals_AccumulateCorrectly** - After N days at price P with base amount B: SmartCumulativeUsd == N*B (for flat prices), SmartCumulativeBtc == N*B/P
    f. **Run_CostBasis_IsWeightedAverage** - Two days at different prices -> verify cost basis = totalUsd / totalBtc
    g. **Run_SlidingWindow_High30Day_UsesPartialWindowDuringWarmup** - Day 0 has High30Day == its own high, Day 5 has High30Day == max of days 0-5
    h. **Run_SlidingWindow_Ma200_ReturnsZeroDuringWarmup** - Day 50 has Ma200Day == 0 (insufficient data)
    i. **Run_SlidingWindow_Ma200_ComputesAfterWarmup** - 200+ days of data -> Ma200Day at day 200 is average of first 200 closing prices
    j. **Run_IsDeterministic** - Run twice with same inputs -> results are identical (BeEquivalentTo)
    k. **Run_EmptyPriceData_ThrowsArgumentException** - Empty array throws
    l. **Run_PurchaseLog_IncludesWindowValues** - Each entry has non-zero High30Day, correct Ma200Day

    Run `dotnet test` -- all tests should FAIL (NotImplementedException). Commit: `test(06-01): add failing tests for BacktestSimulator core`
  </action>
  <verify>
    `dotnet build TradingBot.sln` succeeds with 0 errors.
    `dotnet test --filter "FullyQualifiedName~BacktestSimulatorTests"` -- all tests fail with NotImplementedException (RED phase).
  </verify>
  <done>All record types compile. 12+ tests exist and all fail. RED phase complete.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement BacktestSimulator core loop with smart DCA and same-base fixed DCA</name>
  <files>
    TradingBot.ApiService/Application/Services/BacktestSimulator.cs
  </files>
  <action>
    **Implement BacktestSimulator.Run() in full:**

    1. **Input validation:**
       - `ArgumentNullException.ThrowIfNull(config)` and `ArgumentNullException.ThrowIfNull(priceData)`
       - If `priceData.Count == 0` throw `ArgumentException("Price data cannot be empty", nameof(priceData))`

    2. **Convert MultiplierTierConfig to MultiplierTier** for MultiplierCalculator compatibility:
       ```csharp
       var multiplierTiers = config.Tiers
           .Select(t => new MultiplierTier { DropPercentage = t.DropPercentage, Multiplier = t.Multiplier })
           .ToList();
       ```

    3. **Main simulation loop (single pass for smart DCA + same-base):**
       - Running totals: `smartCumulativeUsd`, `smartCumulativeBtc`, `fixedSameBaseCumulativeUsd`, `fixedSameBaseCumulativeBtc`
       - For each day i in priceData:
         - Compute `high30Day` = max of Close prices in window [max(0, i-lookback+1) .. i]. During warmup (i < lookback-1), use all available days [0..i]. Use High field (not Close) for the high computation per DailyPrice.High field.
         - Compute `ma200Day` = if i < maPeriod-1 then 0m, else average of Close prices in window [i-maPeriod+1 .. i]
         - Call `MultiplierCalculator.Calculate(currentPrice: priceData[i].Close, baseAmount: config.BaseDailyAmount, high30Day, ma200Day, multiplierTiers, config.BearBoostFactor, config.MaxMultiplierCap)`
         - Smart DCA: `smartAmountUsd = result.FinalAmount`, `smartBtcBought = smartAmountUsd / priceData[i].Close`
         - Same-base: `fixedSameBaseAmountUsd = config.BaseDailyAmount`, `fixedSameBaseBtcBought = fixedSameBaseAmountUsd / priceData[i].Close`
         - Update running totals, compute running cost basis = cumulativeUsd / cumulativeBtc
         - Create PurchaseLogEntry with all smart + same-base fields, match-total fields as 0m for now, window values (high30Day, ma200Day)

    4. **Match-total second pass:**
       - `matchTotalDailyAmount = smartCumulativeUsd / priceData.Count`
       - Loop through priceData again, computing match-total running totals
       - Update PurchaseLogEntry match-total fields. Since records are immutable, either:
         (a) Build match-total entries in parallel array and merge when constructing final PurchaseLogEntry, OR
         (b) Use a mutable intermediate type and convert to records at the end
       - Recommendation: Build all three strategies' data in arrays during their respective passes, then zip into final PurchaseLogEntry records.

    5. **Metrics computation:**
       - Final price = `priceData[^1].Close` (last day's closing price per research recommendation)
       - For each strategy (smart, sameBase, matchTotal): compute TotalInvested, TotalBtc, AvgCostBasis, PortfolioValue (totalBtc * finalPrice), ReturnPercent ((portfolioValue - totalInvested) / totalInvested * 100), MaxDrawdown (0m placeholder -- Plan 02 will implement)
       - Guard all divisions against zero

    6. **Comparison metrics:**
       - CostBasisDeltaSameBase = smartAvgCost - sameBaseAvgCost
       - CostBasisDeltaMatchTotal = smartAvgCost - matchTotalAvgCost
       - ExtraBtcPercentSameBase = (smartBtc - sameBaseBtc) / sameBaseBtc * 100 (guard zero)
       - ExtraBtcPercentMatchTotal = (smartBtc - matchTotalBtc) / matchTotalBtc * 100 (guard zero)
       - EfficiencyRatio = smartReturnPercent / sameBaseReturnPercent (guard zero)

    7. **Tier breakdown:**
       - Group purchase log by SmartTier (excluding "Base")
       - For each tier: TriggerCount, ExtraUsdSpent (sum of SmartAmountUsd - BaseDailyAmount), ExtraBtcAcquired (sum of SmartBtcBought - BaseDailyAmount/Price)

    8. **Return BacktestResult** with all sections assembled.

    **Key implementation decisions (Claude's discretion from CONTEXT.md):**
    - Sliding windows: index-based in-loop computation (not pre-computed) for clarity
    - Warmup: partial window for high, zero for MA200
    - Gap handling: skip nothing, treat price array as-is (each entry = one purchase day)
    - Portfolio valuation: last day's closing price
    - Fixed DCA buys on same days as smart DCA (every day in price array)

    Run `dotnet test --filter "FullyQualifiedName~BacktestSimulatorTests"` -- all tests should PASS.

    Commit: `feat(06-01): implement BacktestSimulator core with smart DCA and fixed baselines`
  </action>
  <verify>
    `dotnet build TradingBot.sln` succeeds with 0 errors.
    `dotnet test --filter "FullyQualifiedName~BacktestSimulatorTests"` -- all 12+ tests pass (GREEN phase).
    `dotnet test` -- all tests pass (including Phase 5 MultiplierCalculator tests, no regressions).
  </verify>
  <done>BacktestSimulator.Run() produces correct smart DCA, same-base, and match-total results. All running totals accumulate correctly. Sliding windows compute correctly with warmup. All tests pass.</done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` -- zero errors
2. `dotnet test` -- all tests pass (Phase 5 + Phase 6 Plan 01)
3. `dotnet test --filter "FullyQualifiedName~BacktestSimulatorTests"` -- 12+ tests pass
4. BacktestSimulator is a pure static class with no async, no DI, no database access
5. Smart DCA uses MultiplierCalculator.Calculate() for multiplier logic
6. Same-base fixed DCA uses BaseDailyAmount every day
7. Match-total fixed DCA spreads smart DCA's total spend equally across all days
8. Purchase log includes all three strategies side-by-side with window values
</verification>

<success_criteria>
- BacktestSimulator.Run() is pure, static, synchronous, and deterministic
- All record types compile and serialize cleanly
- Smart DCA loop correctly delegates to MultiplierCalculator
- Same-base and match-total baselines computed correctly
- Sliding windows handle warmup gracefully
- Running totals and cost basis accumulate correctly
- 12+ TDD tests pass
- Zero regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/06-backtest-simulation-engine/06-01-SUMMARY.md`
</output>
