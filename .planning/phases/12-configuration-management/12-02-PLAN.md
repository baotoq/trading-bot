---
phase: 12-configuration-management
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - TradingBot.Dashboard/app/types/config.ts
  - TradingBot.Dashboard/app/composables/useConfig.ts
  - TradingBot.Dashboard/server/api/config/index.get.ts
  - TradingBot.Dashboard/server/api/config/index.put.ts
  - TradingBot.Dashboard/server/api/config/defaults.get.ts
  - TradingBot.Dashboard/app/components/config/ConfigPanel.vue
  - TradingBot.Dashboard/app/components/config/MultiplierTiersTable.vue
  - TradingBot.Dashboard/app/app.vue
autonomous: false

must_haves:
  truths:
    - "User can see current DCA configuration on a Config tab of the dashboard page"
    - "Config displays 3 sections: Core DCA, Multiplier Tiers, Bear Market"
    - "Config shows as read-only by default with an Edit button"
    - "User can click Edit to enable fields, then Save or Cancel"
    - "User can edit base daily amount, schedule time, lookback days, dry run toggle"
    - "User can edit multiplier tiers with add/remove rows, auto-sorted by drop %"
    - "User can edit bear market settings"
    - "User sees real-time inline validation errors on invalid input"
    - "User sees confirmation dialog when changing critical fields (BaseDailyAmount, schedule, DryRun)"
    - "User sees toast notification on successful save"
    - "User can reset to defaults from appsettings.json"
    - "Maximum 5 tiers enforced in UI"
  artifacts:
    - path: "TradingBot.Dashboard/app/types/config.ts"
      provides: "ConfigResponse and UpdateConfigRequest TypeScript interfaces"
    - path: "TradingBot.Dashboard/app/composables/useConfig.ts"
      provides: "useConfig composable for config CRUD"
      exports: ["useConfig"]
    - path: "TradingBot.Dashboard/app/components/config/ConfigPanel.vue"
      provides: "Full configuration form with 3 sections, view/edit toggle, save/cancel"
    - path: "TradingBot.Dashboard/app/components/config/MultiplierTiersTable.vue"
      provides: "Editable tier table with add/remove, auto-sort, max 5"
    - path: "TradingBot.Dashboard/app/app.vue"
      provides: "Config tab added to dashboard page"
  key_links:
    - from: "ConfigPanel.vue"
      to: "/api/config"
      via: "useConfig composable $fetch calls"
      pattern: "\\$fetch.*api/config"
    - from: "useConfig.ts"
      to: "server/api/config/index.put.ts"
      via: "$fetch PUT for save"
      pattern: "method.*PUT"
    - from: "server/api/config/index.get.ts"
      to: ".NET backend /api/config"
      via: "server-to-server proxy with API key"
      pattern: "config\\.public\\.apiEndpoint.*api/config"
    - from: "app.vue"
      to: "ConfigPanel.vue"
      via: "UTabs slot rendering"
      pattern: "ConfigPanel"
---

<objective>
Frontend configuration management UI: TypeScript types, composable, Nuxt server proxy routes, and config panel component with view/edit mode, inline validation, multiplier tiers table, and save/reset functionality.

Purpose: Provides the user-facing configuration management experience. Users can view all DCA settings on a new Config tab, switch to edit mode, modify settings with real-time validation, and save changes that take effect immediately.

Output: Working Config tab on dashboard with full CRUD for all DCA configuration fields.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-configuration-management/12-CONTEXT.md
@.planning/phases/12-configuration-management/12-RESEARCH.md
@.planning/phases/12-configuration-management/12-01-SUMMARY.md

@TradingBot.Dashboard/app/app.vue
@TradingBot.Dashboard/app/pages/backtest.vue
@TradingBot.Dashboard/app/composables/useBacktest.ts
@TradingBot.Dashboard/app/composables/useDashboard.ts
@TradingBot.Dashboard/app/types/dashboard.ts
@TradingBot.Dashboard/app/types/backtest.ts
@TradingBot.Dashboard/server/api/dashboard/config.get.ts
@TradingBot.Dashboard/server/utils/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TypeScript types, composable, and Nuxt server proxy routes</name>
  <files>
    TradingBot.Dashboard/app/types/config.ts
    TradingBot.Dashboard/app/composables/useConfig.ts
    TradingBot.Dashboard/server/api/config/index.get.ts
    TradingBot.Dashboard/server/api/config/index.put.ts
    TradingBot.Dashboard/server/api/config/defaults.get.ts
  </files>
  <action>
    **TypeScript types (app/types/config.ts):**

    Create interfaces matching backend ConfigResponse/UpdateConfigRequest DTOs:

    ```typescript
    export interface ConfigResponse {
      baseDailyAmount: number
      dailyBuyHour: number
      dailyBuyMinute: number
      highLookbackDays: number
      dryRun: boolean
      bearMarketMaPeriod: number
      bearBoostFactor: number
      maxMultiplierCap: number
      tiers: MultiplierTierDto[]
    }

    export interface MultiplierTierDto {
      dropPercentage: number
      multiplier: number
    }

    // Same shape for update request
    export type UpdateConfigRequest = ConfigResponse
    ```

    **Nuxt server proxy routes:**

    Follow the existing pattern from `server/api/dashboard/config.get.ts`:

    1. `server/api/config/index.get.ts` - Proxy GET to `${apiEndpoint}/api/config` with API key header
    2. `server/api/config/index.put.ts` - Proxy PUT to `${apiEndpoint}/api/config` with API key header. Read body from event with `readBody(event)` and forward it. Handle error responses (400 validation errors) by passing through the status code and body.
    3. `server/api/config/defaults.get.ts` - Proxy GET to `${apiEndpoint}/api/config/defaults` with API key header

    All routes use `useRuntimeConfig(event)` to get apiEndpoint and apiKey. Use try/catch with `createError` for error propagation.

    **useConfig composable (app/composables/useConfig.ts):**

    Follow the pattern from useBacktest.ts. Create composable with:

    State:
    - `config: ref<ConfigResponse | null>(null)` - Current config from server
    - `defaults: ref<ConfigResponse | null>(null)` - Default config from server
    - `isLoading: ref(false)` - Loading state
    - `isSaving: ref(false)` - Save in progress
    - `error: ref<string | null>(null)` - Error message

    Methods:
    - `loadConfig()` - Fetch current config via `$fetch<ConfigResponse>('/api/config')`
    - `loadDefaults()` - Fetch defaults via `$fetch<ConfigResponse>('/api/config/defaults')`
    - `saveConfig(request: UpdateConfigRequest)` - PUT via `$fetch('/api/config', { method: 'PUT', body: request })`. On success, reload config and return true. On error, parse validation errors from response body `err.data?.errors` and set error ref. Return false.
    - `resetToDefaults()` - Load defaults and return them (does not save â€” caller decides)

    Return all state and methods from composable.
  </action>
  <verify>
    `cd TradingBot.Dashboard && npx nuxi typecheck` passes (or at minimum, no errors in new files). Proxy routes follow the same pattern as existing dashboard proxy routes.
  </verify>
  <done>TypeScript types match backend DTOs. Composable provides config CRUD with loading/saving states and error handling. Three server proxy routes forward requests to .NET backend with API key auth.</done>
</task>

<task type="auto">
  <name>Task 2: Config panel component with form, tiers table, and dashboard integration</name>
  <files>
    TradingBot.Dashboard/app/components/config/ConfigPanel.vue
    TradingBot.Dashboard/app/components/config/MultiplierTiersTable.vue
    TradingBot.Dashboard/app/app.vue
  </files>
  <action>
    **MultiplierTiersTable.vue (app/components/config/MultiplierTiersTable.vue):**

    Editable table component for multiplier tiers per user decision:
    - Props: `modelValue: MultiplierTierDto[]`, `disabled: boolean` (read-only when not editing)
    - Emits: `update:modelValue`
    - Display table with columns: Drop %, Multiplier, and action column (remove button)
    - Each cell uses UInput with `type="number"`, `:disabled="disabled"`, `step="0.1"`
    - Add Tier button (UButton with plus icon): disabled when `disabled` or tiers.length >= 5
    - Remove button per row (UButton with trash icon): disabled when `disabled`
    - Auto-sort by dropPercentage ascending on any value change (sort the array and emit update)
    - Show helper text: "Maximum 5 tiers. Tiers are auto-sorted by drop percentage."
    - Inline validation: if duplicate dropPercentage values exist, show red border/text on duplicates. If negative values, show red border.
    - Use Tailwind table styling with dark mode support matching existing dashboard components

    **ConfigPanel.vue (app/components/config/ConfigPanel.vue):**

    Full configuration panel implementing ALL locked decisions:

    1. **Structure:** Three UCard sections on a single scrollable view:
       - Core DCA Settings (BaseDailyAmount, DailyBuyHour + DailyBuyMinute, HighLookbackDays, DryRun)
       - Multiplier Tiers (MultiplierTiersTable component)
       - Bear Market Settings (BearMarketMaPeriod, BearBoostFactor, MaxMultiplierCap)

    2. **View/Edit pattern:**
       - `isEditing` ref, default false
       - Top-right Edit button (shown when NOT editing) triggers `isEditing = true` and clones config to formState
       - All form fields use `:disabled="!isEditing"`
       - When editing: show Save, Cancel, Reset to Defaults buttons at bottom

    3. **Form state:** Use a local `formState` ref cloned from `config` when entering edit mode. This prevents direct mutation of loaded config.

    4. **Zod validation schema** matching DcaOptionsValidator rules:
       - baseDailyAmount: positive number
       - dailyBuyHour: int 0-23
       - dailyBuyMinute: int 0-59
       - highLookbackDays: positive int
       - dryRun: boolean
       - bearMarketMaPeriod: positive int
       - bearBoostFactor: positive number
       - maxMultiplierCap: min 1.0
       - tiers: array max 5, each with nonneg dropPercentage and positive multiplier, sorted ascending by dropPercentage

    5. **Use UForm wrapping the entire form** with `:schema="configSchema"` and `:state="formState"` for real-time inline validation. Use UFormField for each field with `name` matching schema keys and `help` text for inline descriptions:
       - BaseDailyAmount: "Amount in USD to invest daily"
       - DailyBuyHour/Minute: "Hour (0-23) and minute (0-59) in UTC for daily purchase"
       - HighLookbackDays: "Number of days to look back for all-time high calculation"
       - DryRun: "When enabled, simulates purchases without placing real orders"
       - BearMarketMaPeriod: "Number of days for the moving average used to detect bear markets"
       - BearBoostFactor: "Multiplier boost applied during bear market conditions"
       - MaxMultiplierCap: "Maximum allowed multiplier (caps tier * bear boost product)"

    6. **Field components per user discretion:**
       - BaseDailyAmount: UInput type="number" step="0.01"
       - DailyBuyHour: UInput type="number" (0-23)
       - DailyBuyMinute: UInput type="number" (0-59)
       - HighLookbackDays: UInput type="number"
       - DryRun: USwitch
       - BearMarketMaPeriod: UInput type="number"
       - BearBoostFactor: UInput type="number" step="0.01"
       - MaxMultiplierCap: UInput type="number" step="0.1"

    7. **Save flow:**
       - On form submit, sort tiers by dropPercentage ascending before sending
       - Check if critical fields changed (BaseDailyAmount, DailyBuyHour, DailyBuyMinute, DryRun) by comparing formState to original config
       - If critical fields changed: show browser `confirm()` dialog with message "You are changing settings that affect live trading (daily amount, schedule, or dry run mode). Apply changes?"
       - If confirmed (or no critical changes): call `saveConfig(formState)` from useConfig composable
       - On success: show toast "Configuration saved successfully" (green, auto-dismiss), exit edit mode
       - On error: show toast with error message (red), stay in edit mode

    8. **Cancel:** Reset formState to original config, set isEditing = false

    9. **Reset to Defaults:** Call `loadDefaults()` from composable, replace formState with returned defaults (stay in edit mode so user can review before saving)

    10. **Loading state:** Show skeleton/spinner while config is loading. Show error alert if load fails.

    **app.vue updates:**

    Add Config as a new tab on the dashboard page per user decision ("config is a new tab on existing dashboard page"). Modify app.vue to add UTabs with two tabs:
    - Tab 1 "Dashboard" (slot: dashboard) - Contains the existing dashboard content (PortfolioStats, PriceChart, LiveStatus, PurchaseHistory)
    - Tab 2 "Configuration" (slot: config) - Contains `<ConfigPanel />`

    Move the existing main content into the "dashboard" tab slot. Add config tab. Import ConfigPanel component.

    Keep the header (BTC Smart DCA Dashboard title, Backtest link, connection status) outside the tabs so it's always visible. The tab bar goes below the header, above the content.

    Load config on mount in app.vue (or let ConfigPanel load on its own mount).
  </action>
  <verify>
    `cd TradingBot.Dashboard && npm run build` succeeds (or `npx nuxi build`). Start the full app with `cd TradingBot.AppHost && dotnet run`. Navigate to dashboard, verify:
    1. Two tabs visible: Dashboard and Configuration
    2. Dashboard tab shows existing content unchanged
    3. Configuration tab shows 3 sections with current config values
    4. Config is read-only by default
    5. Click Edit enables all fields
    6. Can modify values and see inline validation errors
    7. Can add/remove tiers (max 5 enforced)
    8. Save shows confirmation for critical fields, then saves
    9. Toast appears on success
    10. Cancel reverts changes
    11. Reset to Defaults loads appsettings.json values
  </verify>
  <done>Config tab on dashboard shows all DCA settings in 3 sections. View/edit toggle works. Inline validation with zod. Tier table with add/remove and auto-sort. Confirmation dialog for critical fields. Toast on save. Reset to defaults. All locked decisions implemented.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify configuration management end-to-end</name>
  <files>n/a</files>
  <action>
    Human verification of the complete configuration management feature. No automated work in this task - all implementation is done in Tasks 1-2. This checkpoint pauses for the user to test the full end-to-end flow.
  </action>
  <verify>
    Start the app: `cd TradingBot.AppHost && dotnet run`
    Open the dashboard in a browser.

    1. **Tab navigation:** Verify two tabs exist (Dashboard, Configuration). Switch between them. Dashboard tab shows existing content normally.

    2. **Read-only view:** On Config tab, verify all 3 sections display: Core DCA, Multiplier Tiers, Bear Market. All fields show current values. Fields are disabled/read-only. Edit button is visible.

    3. **Edit mode:** Click Edit. All fields become editable. Save, Cancel, Reset to Defaults buttons appear at bottom.

    4. **Inline validation:** Try entering invalid values:
       - Set BaseDailyAmount to -1 (should show error)
       - Set DailyBuyHour to 25 (should show error)
       - Set MaxMultiplierCap to 0.5 (should show error)

    5. **Tiers editing:** Add a tier (click Add Tier). Remove a tier. Try adding more than 5 (Add button should disable). Enter a duplicate drop percentage (should show validation error).

    6. **Cancel:** Make some changes then click Cancel. Verify values revert to original.

    7. **Save with confirmation:** Enter edit mode. Change BaseDailyAmount to a different value. Click Save. Confirm dialog should appear. Cancel the dialog (changes not saved). Click Save again, confirm. Toast should appear saying "Configuration saved successfully".

    8. **Persistence:** Refresh the page. Config tab should show the updated values (not the old ones).

    9. **Reset to defaults:** Enter edit mode. Click Reset to Defaults. Values should change to appsettings.json defaults. Save to apply.

    10. **Backend validation:** Use browser DevTools to send a PUT with invalid data. Verify 400 response with error messages.
  </verify>
  <done>User confirms all 10 verification steps pass. Configuration management feature is complete and working end-to-end.</done>
</task>

</tasks>

<verification>
1. Dashboard shows two tabs: Dashboard and Configuration
2. Configuration tab displays all DCA options in 3 sections per locked decision
3. View-then-edit pattern works (read-only default, Edit button enables fields)
4. Inline validation matches DcaOptionsValidator rules
5. Multiplier tiers table supports add/remove/edit with auto-sort and max 5
6. Confirmation dialog appears for BaseDailyAmount, schedule time, and DryRun changes
7. Toast notification on successful save
8. Reset to defaults loads appsettings.json values
9. Config persists to PostgreSQL and takes effect immediately
10. Existing dashboard content unaffected
</verification>

<success_criteria>
- User can view all DCA configuration on Config tab (CONF-01)
- User can edit base amount and schedule from dashboard (CONF-02)
- User can edit multiplier tiers from dashboard (CONF-03)
- Config changes validated server-side with clear error display (CONF-04)
- User sees confirmation on save and understands no restart needed (CONF-05 equivalent)
- All locked decisions from CONTEXT.md are implemented
</success_criteria>

<output>
After completion, create `.planning/phases/12-configuration-management/12-02-SUMMARY.md`
</output>
