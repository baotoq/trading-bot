---
phase: 27-price-feed-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Infrastructure/PriceFeeds/PriceFeedEntry.cs
  - TradingBot.ApiService/Infrastructure/PriceFeeds/PriceFeedResult.cs
  - TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/ICryptoPriceProvider.cs
  - TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/CoinGeckoPriceProvider.cs
  - TradingBot.ApiService/Infrastructure/PriceFeeds/Etf/IEtfPriceProvider.cs
  - TradingBot.ApiService/Infrastructure/PriceFeeds/ExchangeRate/IExchangeRateProvider.cs
autonomous: true
requirements: [PRICE-01, PRICE-04]

must_haves:
  truths:
    - "Crypto prices for any CoinGecko-listed coin can be fetched and returned with a FetchedAt timestamp"
    - "Fetched crypto prices are cached in Redis with 5-minute freshness and 30-day physical TTL"
    - "Subsequent requests within the 5-minute window return the cached value without calling CoinGecko"
    - "If cache is stale and CoinGecko is reachable, a fresh price is fetched and cached"
    - "If cache is stale and CoinGecko is unreachable, the stale cached value is returned with IsStale=true"
    - "If cache is empty and CoinGecko is unreachable, an exception is thrown"
    - "Multiple coin IDs can be batch-fetched in a single CoinGecko API call"
  artifacts:
    - path: "TradingBot.ApiService/Infrastructure/PriceFeeds/PriceFeedEntry.cs"
      provides: "MessagePack-serializable cache record with Price and FetchedAtUnixSeconds"
      contains: "MessagePackObject"
    - path: "TradingBot.ApiService/Infrastructure/PriceFeeds/PriceFeedResult.cs"
      provides: "Return type with Price, FetchedAt, IsStale, Currency"
      contains: "PriceFeedResult"
    - path: "TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/ICryptoPriceProvider.cs"
      provides: "Interface for crypto price fetching"
      exports: ["ICryptoPriceProvider"]
    - path: "TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/CoinGeckoPriceProvider.cs"
      provides: "CoinGecko implementation with Redis caching"
      contains: "CoinGeckoPriceProvider"
    - path: "TradingBot.ApiService/Infrastructure/PriceFeeds/Etf/IEtfPriceProvider.cs"
      provides: "Interface for ETF price fetching"
      exports: ["IEtfPriceProvider"]
    - path: "TradingBot.ApiService/Infrastructure/PriceFeeds/ExchangeRate/IExchangeRateProvider.cs"
      provides: "Interface for exchange rate fetching"
      exports: ["IExchangeRateProvider"]
  key_links:
    - from: "CoinGeckoPriceProvider"
      to: "IDistributedCache"
      via: "constructor injection"
      pattern: "IDistributedCache"
    - from: "CoinGeckoPriceProvider"
      to: "CoinGecko /simple/price"
      via: "HttpClient.GetFromJsonAsync"
      pattern: "simple/price\\?ids="
    - from: "PriceFeedEntry"
      to: "Redis"
      via: "MessagePackSerializer.Serialize/Deserialize"
      pattern: "MessagePackSerializer"
---

<objective>
Create the shared price feed infrastructure (PriceFeedEntry, PriceFeedResult, all three provider interfaces) and the CoinGecko crypto price provider with Redis caching.

Purpose: Establish the cache model and return types shared by all three providers, plus implement the crypto provider that addresses PRICE-01 (CoinGecko fetch + 5-min Redis cache) and PRICE-04 (staleness tracking via FetchedAt timestamp).

Output: PriceFeedEntry MessagePack record, PriceFeedResult return type, three provider interfaces, and fully-functional CoinGeckoPriceProvider with lazy fetch + cache pattern.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-price-feed-infrastructure/27-CONTEXT.md
@.planning/phases/27-price-feed-infrastructure/27-RESEARCH.md

Key existing patterns to follow:
@TradingBot.ApiService/Infrastructure/CoinGecko/ServiceCollectionExtensions.cs (HttpClient + resilience registration pattern)
@TradingBot.ApiService/Infrastructure/CoinGecko/CoinGeckoClient.cs (existing CoinGecko client — historical data, NOT live prices)
@TradingBot.ApiService/Infrastructure/CoinGecko/CoinGeckoOptions.cs (has optional ApiKey field — reuse for x-cg-demo-api-key header)
@TradingBot.ApiService/Program.cs (DI registration pattern, Redis cache already wired)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared price feed types and all three provider interfaces</name>
  <files>
    TradingBot.ApiService/Infrastructure/PriceFeeds/PriceFeedEntry.cs
    TradingBot.ApiService/Infrastructure/PriceFeeds/PriceFeedResult.cs
    TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/ICryptoPriceProvider.cs
    TradingBot.ApiService/Infrastructure/PriceFeeds/Etf/IEtfPriceProvider.cs
    TradingBot.ApiService/Infrastructure/PriceFeeds/ExchangeRate/IExchangeRateProvider.cs
  </files>
  <action>
    Create the `Infrastructure/PriceFeeds/` directory structure with shared types and all three interfaces.

    **PriceFeedEntry.cs** — MessagePack-serializable cache record:
    - `[MessagePackObject]` attribute on the record
    - `[Key(0)] decimal Price` — the price value
    - `[Key(1)] long FetchedAtUnixSeconds` — Unix timestamp (use long to avoid DateTimeOffset MessagePack resolver issues per research Pitfall 5)
    - `[Key(2)] string Currency` — "USD" or "VND"
    - Computed property `DateTimeOffset FetchedAt => DateTimeOffset.FromUnixTimeSeconds(FetchedAtUnixSeconds)`
    - Static factory `PriceFeedEntry.Create(decimal price, string currency)`
    - Namespace: `TradingBot.ApiService.Infrastructure.PriceFeeds`

    **PriceFeedResult.cs** — Return type for all providers:
    - `record PriceFeedResult(decimal Price, DateTimeOffset FetchedAt, bool IsStale, string Currency)`
    - Static factories: `PriceFeedResult.Fresh(decimal price, DateTimeOffset fetchedAt, string currency)` and `PriceFeedResult.Stale(decimal price, DateTimeOffset fetchedAt, string currency)`
    - Namespace: `TradingBot.ApiService.Infrastructure.PriceFeeds`

    **ICryptoPriceProvider.cs** — Interface:
    - `Task<PriceFeedResult> GetPriceAsync(string coinGeckoId, CancellationToken ct)` — single coin
    - `Task<Dictionary<string, PriceFeedResult>> GetPricesAsync(IEnumerable<string> coinGeckoIds, CancellationToken ct)` — batch
    - Namespace: `TradingBot.ApiService.Infrastructure.PriceFeeds.Crypto`

    **IEtfPriceProvider.cs** — Interface:
    - `Task<PriceFeedResult> GetPriceAsync(string vnDirectTicker, CancellationToken ct)` — e.g., "E1VFVN30"
    - Namespace: `TradingBot.ApiService.Infrastructure.PriceFeeds.Etf`

    **IExchangeRateProvider.cs** — Interface:
    - `Task<PriceFeedResult> GetUsdToVndRateAsync(CancellationToken ct)` — single rate
    - Namespace: `TradingBot.ApiService.Infrastructure.PriceFeeds.ExchangeRate`
  </action>
  <verify>
    `dotnet build TradingBot.slnx` compiles successfully. All five files exist under `Infrastructure/PriceFeeds/`.
  </verify>
  <done>
    PriceFeedEntry has MessagePackObject attribute with Key(0)/Key(1)/Key(2) and FetchedAt computed property. PriceFeedResult has Fresh/Stale factories. All three interfaces are defined with the correct method signatures and namespaces.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CoinGeckoPriceProvider with Redis caching and lazy fetch</name>
  <files>
    TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/CoinGeckoPriceProvider.cs
  </files>
  <action>
    Implement `CoinGeckoPriceProvider : ICryptoPriceProvider` with primary constructor taking `HttpClient`, `IDistributedCache`, `IOptionsMonitor<CoinGeckoOptions>`, and `ILogger<CoinGeckoPriceProvider>`.

    **Cache key format:** `price:crypto:{coinGeckoId}` (e.g., `price:crypto:bitcoin`)
    **Freshness window:** 5 minutes (per PRICE-01)
    **Physical Redis TTL:** 30 days (safety net, per locked decision)

    **GetPriceAsync(string coinGeckoId):**
    1. Read cache via `_cache.GetAsync(cacheKey, ct)`
    2. If cached bytes exist, deserialize with `MessagePackSerializer.Deserialize<PriceFeedEntry>(bytes)`
    3. Check freshness: `DateTimeOffset.UtcNow - entry.FetchedAt <= TimeSpan.FromMinutes(5)`
    4. If fresh → return `PriceFeedResult.Fresh(...)`
    5. If stale → try fetch from CoinGecko. If fetch succeeds, cache and return Fresh. If fetch fails (catch HttpRequestException), return `PriceFeedResult.Stale(...)` with the cached entry's values. Log the failure at Warning level with structured logging.
    6. If cache empty → fetch from CoinGecko (blocking). If fails, let exception propagate (per locked decision: "throw if cache empty and provider down").

    **GetPricesAsync(IEnumerable<string> coinGeckoIds):**
    1. Check cache for each ID first. Collect IDs that need fetching (stale or missing).
    2. Batch-fetch missing/stale IDs in a single CoinGecko `/simple/price?ids={csv}&vs_currencies=usd&include_last_updated_at=true` call (per locked decision: batch-fetch).
    3. Cache each result individually with its own key.
    4. Return dictionary of `coinGeckoId → PriceFeedResult`.

    **CoinGecko API details:**
    - URL: `simple/price?ids={csvIds}&vs_currencies=usd&include_last_updated_at=true`
    - Response: `{"bitcoin":{"usd":67508,"last_updated_at":1771591961}}`
    - Use `HttpClient.GetFromJsonAsync<Dictionary<string, CoinPriceData>>(url, ct)`
    - Inner DTO: `private record CoinPriceData([property: JsonPropertyName("usd")] decimal Usd, [property: JsonPropertyName("last_updated_at")] long LastUpdatedAt)`
    - Currency is always "USD" for crypto

    **CoinGecko API key header:**
    - If `CoinGeckoOptions.ApiKey` is not null/empty, add `x-cg-demo-api-key` header to each request via `HttpRequestMessage` (or configure on HttpClient at registration time in the next plan).
    - For now, add header per-request: create `HttpRequestMessage` manually, add header if API key exists, send via `_httpClient.SendAsync(...)`.

    **Cache write helper:**
    ```
    var entry = PriceFeedEntry.Create(price, "USD");
    var bytes = MessagePackSerializer.Serialize(entry);
    await _cache.SetAsync(cacheKey, bytes, new DistributedCacheEntryOptions
    {
        AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(30)
    }, ct);
    ```

    **Logging:** Use structured templates per project convention:
    - `_logger.LogInformation("Fetched crypto prices for {CoinIds} from CoinGecko", ids)`
    - `_logger.LogWarning("CoinGecko API failed for {CoinId}, returning stale cached price from {FetchedAt}", coinId, entry.FetchedAt)`
  </action>
  <verify>
    `dotnet build TradingBot.slnx` compiles successfully. CoinGeckoPriceProvider implements ICryptoPriceProvider with both single and batch methods. Class uses primary constructor with HttpClient, IDistributedCache, IOptionsMonitor, ILogger.
  </verify>
  <done>
    CoinGeckoPriceProvider correctly implements the lazy fetch + cache pattern: fresh cache returns immediately, stale cache returns stale while logging warning, empty cache blocks on fetch or throws. Batch method calls CoinGecko once with CSV ids. PriceFeedEntry serialized with MessagePack, cached with 30-day physical TTL and 5-minute logical freshness.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.slnx` compiles with zero errors
2. Files exist: PriceFeedEntry.cs, PriceFeedResult.cs, ICryptoPriceProvider.cs, IEtfPriceProvider.cs, IExchangeRateProvider.cs, CoinGeckoPriceProvider.cs
3. PriceFeedEntry has [MessagePackObject] attribute with [Key(0)], [Key(1)], [Key(2)]
4. CoinGeckoPriceProvider implements ICryptoPriceProvider
5. CoinGeckoPriceProvider uses IDistributedCache for Redis operations
6. CoinGeckoPriceProvider respects the 5-minute freshness window
7. Batch method uses single CoinGecko API call with comma-separated IDs
</verification>

<success_criteria>
- All shared types compile and are importable from other files
- CoinGeckoPriceProvider handles fresh cache, stale cache (graceful degradation), and empty cache (blocking fetch) correctly
- No new NuGet packages required (MessagePack, IDistributedCache, Http.Resilience all already in project)
- Code follows project conventions: primary constructors, structured logging, IOptionsMonitor
</success_criteria>

<output>
After completion, create `.planning/phases/27-price-feed-infrastructure/27-01-SUMMARY.md`
</output>
