---
phase: 11-backtest-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
  - TradingBot.ApiService/Endpoints/DashboardDtos.cs
  - TradingBot.Dashboard/server/api/dashboard/config.get.ts
  - TradingBot.Dashboard/server/api/backtest/run.post.ts
  - TradingBot.Dashboard/server/api/backtest/sweep.post.ts
  - TradingBot.Dashboard/app/types/backtest.ts
  - TradingBot.Dashboard/app/composables/useBacktest.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard can fetch live DCA config values from backend"
    - "Dashboard can proxy backtest API calls (run + sweep) to backend with API key auth"
    - "TypeScript types exist for all backtest request/response DTOs"
    - "Composable provides reactive state for backtest form, execution, and results"
  artifacts:
    - path: "TradingBot.ApiService/Endpoints/DashboardEndpoints.cs"
      provides: "GET /api/dashboard/config endpoint returning DCA config"
      contains: "DcaConfigResponse"
    - path: "TradingBot.Dashboard/server/api/dashboard/config.get.ts"
      provides: "Nuxt server proxy for config endpoint"
    - path: "TradingBot.Dashboard/server/api/backtest/run.post.ts"
      provides: "Nuxt server proxy for POST /api/backtest"
    - path: "TradingBot.Dashboard/server/api/backtest/sweep.post.ts"
      provides: "Nuxt server proxy for POST /api/backtest/sweep"
    - path: "TradingBot.Dashboard/app/types/backtest.ts"
      provides: "TypeScript interfaces for all backtest DTOs"
    - path: "TradingBot.Dashboard/app/composables/useBacktest.ts"
      provides: "Composable with runBacktest, runSweep, form state, results state"
  key_links:
    - from: "TradingBot.Dashboard/server/api/backtest/run.post.ts"
      to: "/api/backtest"
      via: "$fetch with API key header"
      pattern: "\\$fetch.*api/backtest"
    - from: "TradingBot.Dashboard/app/composables/useBacktest.ts"
      to: "/api/backtest/run"
      via: "$fetch POST"
      pattern: "\\$fetch.*backtest"
---

<objective>
Create the backend config endpoint, Nuxt server proxy routes, TypeScript types, and composable for backtest functionality.

Purpose: Establish the data layer foundation that all backtest UI components depend on -- backend API, proxy routing, type safety, and reactive state management.
Output: Working API proxy pipeline (Nuxt -> backend) for config, backtest, and sweep endpoints plus typed composable ready for UI components.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-backtest-visualization/11-RESEARCH.md

@TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
@TradingBot.ApiService/Endpoints/DashboardDtos.cs
@TradingBot.ApiService/Configuration/DcaOptions.cs
@TradingBot.ApiService/Application/Services/Backtest/BacktestRequest.cs
@TradingBot.ApiService/Application/Services/Backtest/BacktestResponse.cs
@TradingBot.ApiService/Application/Services/Backtest/BacktestResult.cs
@TradingBot.ApiService/Application/Services/Backtest/BacktestConfig.cs
@TradingBot.ApiService/Application/Services/Backtest/PurchaseLogEntry.cs
@TradingBot.ApiService/Application/Services/Backtest/SweepRequest.cs
@TradingBot.ApiService/Application/Services/Backtest/SweepResponse.cs
@TradingBot.Dashboard/server/api/dashboard/portfolio.get.ts
@TradingBot.Dashboard/server/utils/auth.ts
@TradingBot.Dashboard/app/types/dashboard.ts
@TradingBot.Dashboard/app/composables/useDashboard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backend config endpoint and Nuxt server proxy routes</name>
  <files>
    TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
    TradingBot.ApiService/Endpoints/DashboardDtos.cs
    TradingBot.Dashboard/server/api/dashboard/config.get.ts
    TradingBot.Dashboard/server/api/backtest/run.post.ts
    TradingBot.Dashboard/server/api/backtest/sweep.post.ts
  </files>
  <action>
    1. Add `DcaConfigResponse` record to DashboardDtos.cs:
       ```csharp
       public record DcaConfigResponse(
           decimal BaseDailyAmount,
           int HighLookbackDays,
           int BearMarketMaPeriod,
           decimal BearBoostFactor,
           decimal MaxMultiplierCap,
           List<MultiplierTierDto> Tiers);
       public record MultiplierTierDto(decimal DropPercentage, decimal Multiplier);
       ```

    2. Add `GetConfigAsync` endpoint to DashboardEndpoints.cs:
       - Map `group.MapGet("/config", GetConfigAsync)` in the existing MapDashboardEndpoints method
       - Implementation reads from `IOptionsMonitor<DcaOptions>` and returns `DcaConfigResponse`
       - Map `MultiplierTiers` list to `MultiplierTierDto` list

    3. Create Nuxt server proxy routes following the existing pattern in `server/api/dashboard/portfolio.get.ts`:
       - `server/api/dashboard/config.get.ts`: GET proxy to `${config.public.apiEndpoint}/api/dashboard/config` with x-api-key header
       - `server/api/backtest/run.post.ts`: POST proxy to `${config.public.apiEndpoint}/api/backtest` — read body with `readBody(event)`, forward as POST with x-api-key
       - `server/api/backtest/sweep.post.ts`: POST proxy to `${config.public.apiEndpoint}/api/backtest/sweep` — same pattern as run.post.ts

    All proxy routes must use `useRuntimeConfig(event)` for API endpoint and API key, and wrap in try/catch with `createError` for proper error propagation.
  </action>
  <verify>
    - `dotnet build TradingBot.sln` compiles without errors
    - Config endpoint registered in DashboardEndpoints MapGroup
    - All 3 Nuxt server route files exist with proper defineEventHandler
  </verify>
  <done>
    Backend exposes GET /api/dashboard/config returning DCA options. Nuxt has server proxy routes for config (GET), backtest run (POST), and sweep (POST) endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript types and useBacktest composable</name>
  <files>
    TradingBot.Dashboard/app/types/backtest.ts
    TradingBot.Dashboard/app/composables/useBacktest.ts
  </files>
  <action>
    1. Create `app/types/backtest.ts` with TypeScript interfaces mirroring all backend DTOs:
       - `DcaConfigResponse` (baseDailyAmount, highLookbackDays, bearMarketMaPeriod, bearBoostFactor, maxMultiplierCap, tiers)
       - `MultiplierTierDto` (dropPercentage, multiplier)
       - `BacktestRequest` (startDate?, endDate?, baseDailyAmount?, highLookbackDays?, bearMarketMaPeriod?, bearBoostFactor?, maxMultiplierCap?, tiers?)
       - `MultiplierTierInput` (dropPercentage, multiplier)
       - `BacktestResponse` (config, startDate, endDate, totalDays, result)
       - `BacktestResult` (smartDca, fixedDcaSameBase, fixedDcaMatchTotal, comparison, tierBreakdown, purchaseLog)
       - `DcaMetrics` (totalInvested, totalBtc, avgCostBasis, portfolioValue, returnPercent, maxDrawdown)
       - `ComparisonMetrics` (costBasisDeltaSameBase, costBasisDeltaMatchTotal, extraBtcPercentSameBase, extraBtcPercentMatchTotal, efficiencyRatio)
       - `TierBreakdownEntry` (tierName, triggerCount, extraUsdSpent, extraBtcAcquired)
       - `PurchaseLogEntry` (date, price, smartMultiplier, smartTier, smartAmountUsd, smartBtcBought, smartCumulativeUsd, smartCumulativeBtc, smartRunningCostBasis, fixedSameBaseAmountUsd, fixedSameBaseBtcBought, fixedSameBaseCumulativeUsd, fixedSameBaseCumulativeBtc, fixedSameBaseRunningCostBasis, fixedMatchTotalAmountUsd, fixedMatchTotalBtcBought, fixedMatchTotalCumulativeUsd, fixedMatchTotalCumulativeBtc, fixedMatchTotalRunningCostBasis, high30Day, ma200Day)
       - `BacktestConfig` (baseDailyAmount, highLookbackDays, bearMarketMaPeriod, bearBoostFactor, maxMultiplierCap, tiers)
       - `MultiplierTierConfig` (dropPercentage, multiplier)
       - `SweepRequest` (startDate?, endDate?, preset?, baseAmounts?, highLookbackDays?, bearMarketMaPeriods?, bearBoosts?, maxMultiplierCaps?, tierSets?, rankBy, maxCombinations, validate)
       - `TierSet` (tiers: MultiplierTierInput[])
       - `SweepResponse` (totalCombinations, executedCombinations, rankedBy, startDate, endDate, totalDays, results, topResults, walkForward?)
       - `SweepResultEntry` (rank, config, smartDca, fixedDcaSameBase, comparison, walkForward?)
       - `SweepResultDetailEntry` extends SweepResultEntry with (tierBreakdown, purchaseLog)
       - `WalkForwardEntry` (trainReturnPercent, testReturnPercent, returnDegradation, trainEfficiency, testEfficiency, efficiencyDegradation, overfitWarning)
       - `WalkForwardSummary` (trainRatio, trainEnd, testStart, overfitCount, totalValidated)

       Use camelCase property names matching .NET JSON serialization (System.Text.Json default camelCase).

    2. Create `app/composables/useBacktest.ts`:
       - `fetchConfig()`: GET `/api/dashboard/config`, returns `DcaConfigResponse`
       - Reactive state: `config` (ref), `backtestResult` (ref<BacktestResponse | null>), `sweepResult` (ref<SweepResponse | null>), `isRunning` (ref<boolean>), `progress` (ref<number>), `error` (ref<string | null>)
       - `runBacktest(request: BacktestRequest)`: POST `/api/backtest/run`, updates progress bar (simulated 0-90 in 200ms intervals, 100 on complete), stores result
       - `runSweep(request: SweepRequest)`: POST `/api/backtest/sweep`, similar progress pattern, stores sweep result
       - `loadConfig()`: fetches config on composable init, called in onMounted or immediately
       - Return all refs + functions
       - Use `$fetch` for API calls (Nuxt built-in, handles errors)
       - Error handling: catch errors, set `error` ref, clear `isRunning`
  </action>
  <verify>
    - TypeScript file has all interfaces matching backend DTOs
    - Composable exports fetchConfig, runBacktest, runSweep, and all reactive state refs
    - No TypeScript compilation errors in the types file
  </verify>
  <done>
    Complete TypeScript type coverage for all backtest DTOs. Composable provides reactive backtest state with config loading, single backtest execution, and sweep execution with simulated progress.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` passes
2. Backend config endpoint returns DCA config JSON
3. All 3 Nuxt proxy routes exist and follow existing auth pattern
4. TypeScript types match all backend DTO fields
5. Composable compiles and exports expected API
</verification>

<success_criteria>
- Backend GET /api/dashboard/config returns DcaConfigResponse with live config values
- Nuxt server routes proxy config, backtest, and sweep to backend with API key auth
- All backtest DTOs have corresponding TypeScript interfaces
- useBacktest composable provides reactive state for form pre-fill, execution, and results
</success_criteria>

<output>
After completion, create `.planning/phases/11-backtest-visualization/11-01-SUMMARY.md`
</output>
