---
phase: 03-smart-multipliers
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - TradingBot.ApiService/Application/Services/IPriceDataService.cs
  - TradingBot.ApiService/Application/Services/PriceDataService.cs
  - TradingBot.ApiService/Application/BackgroundJobs/PriceDataRefreshService.cs
autonomous: true

must_haves:
  truths:
    - "PriceDataService bootstraps 200 days of candle data on first run when DB is empty"
    - "PriceDataService calculates 30-day high from daily close prices"
    - "PriceDataService calculates 200-day SMA from daily close prices"
    - "PriceDataRefreshService runs daily at 00:05 UTC to fetch yesterday's candle"
    - "Missing data handled gracefully: skip 200-day MA if insufficient history, log warning"
    - "Stale data policy: use last known values instead of falling back to 1x"
  artifacts:
    - path: "TradingBot.ApiService/Application/Services/IPriceDataService.cs"
      provides: "Price data service abstraction"
      exports: ["IPriceDataService"]
    - path: "TradingBot.ApiService/Application/Services/PriceDataService.cs"
      provides: "Price data fetching, storage, and calculations"
      contains: "class PriceDataService"
    - path: "TradingBot.ApiService/Application/BackgroundJobs/PriceDataRefreshService.cs"
      provides: "Daily background job for candle refresh"
      contains: "class PriceDataRefreshService"
  key_links:
    - from: "PriceDataService"
      to: "HyperliquidClient.GetCandlesAsync"
      via: "constructor injection"
      pattern: "GetCandlesAsync"
    - from: "PriceDataService"
      to: "TradingBotDbContext.DailyPrices"
      via: "EF Core queries"
      pattern: "DailyPrices"
    - from: "PriceDataRefreshService"
      to: "IPriceDataService"
      via: "IServiceScopeFactory resolution"
      pattern: "GetRequiredService<IPriceDataService>"
---

<objective>
Build the PriceDataService that fetches, stores, and calculates 30-day high and 200-day SMA from historical candle data, plus a background service for daily refresh.

Purpose: The multiplier calculation needs 30-day high (for dip tiers) and 200-day SMA (for bear boost). This service owns all price data operations: bootstrap on first run, daily refresh, and cached calculations.

Output: IPriceDataService interface, PriceDataService implementation, PriceDataRefreshService background job.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-smart-multipliers/03-CONTEXT.md
@.planning/phases/03-smart-multipliers/03-RESEARCH.md
@.planning/phases/03-smart-multipliers/03-01-SUMMARY.md
@TradingBot.ApiService/Models/DailyPrice.cs
@TradingBot.ApiService/Infrastructure/Hyperliquid/HyperliquidClient.cs
@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
@TradingBot.ApiService/Application/BackgroundJobs/DcaSchedulerBackgroundService.cs
@TradingBot.ApiService/Configuration/DcaOptions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IPriceDataService interface and PriceDataService implementation</name>
  <files>
    TradingBot.ApiService/Application/Services/IPriceDataService.cs
    TradingBot.ApiService/Application/Services/PriceDataService.cs
  </files>
  <action>
    **Create IPriceDataService.cs** in `TradingBot.ApiService/Application/Services/`:
    ```
    public interface IPriceDataService
    {
        Task BootstrapHistoricalDataAsync(string symbol, CancellationToken ct = default);
        Task FetchAndStoreDailyCandleAsync(string symbol, CancellationToken ct = default);
        Task<decimal> Get30DayHighAsync(string symbol, CancellationToken ct = default);
        Task<decimal> Get200DaySmaAsync(string symbol, CancellationToken ct = default);
    }
    ```

    **Create PriceDataService.cs** in `TradingBot.ApiService/Application/Services/`:

    Dependencies (constructor injection):
    - `TradingBotDbContext dbContext`
    - `HyperliquidClient hyperliquidClient`
    - `IOptionsMonitor<DcaOptions> dcaOptions` (for HighLookbackDays, BearMarketMaPeriod)
    - `ILogger<PriceDataService> logger`

    **BootstrapHistoricalDataAsync(string symbol, CancellationToken ct):**
    - Read `BearMarketMaPeriod` from options (default 200) — this is the max history needed
    - Calculate startDate = today.AddDays(-maPeriod), endDate = today (UTC)
    - Check existing data count: `dbContext.DailyPrices.Where(p => p.Symbol == symbol && p.Date >= startDate).CountAsync()`
    - If count >= maPeriod - 5 (tolerance for gaps), log "Historical data already bootstrapped" and return
    - Fetch candles: `hyperliquidClient.GetCandlesAsync(symbol, startDateOffset, endDateOffset, ct)`
    - Map CandleData to DailyPrice entities
    - Upsert logic: for each candle, check if date+symbol exists. If yes, update OHLCV. If no, add new entity.
    - `await dbContext.SaveChangesAsync(ct)`
    - Log: "Bootstrapped {Count} days of price data for {Symbol}"

    **FetchAndStoreDailyCandleAsync(string symbol, CancellationToken ct):**
    - Find latest date in DB: `dbContext.DailyPrices.Where(p => p.Symbol == symbol).MaxAsync(p => (DateOnly?)p.Date, ct)`
    - If no data exists, delegate to BootstrapHistoricalDataAsync
    - Calculate fetch range: from latestDate to today (UTC) — fetches any missing recent days
    - Fetch candles for the range via GetCandlesAsync
    - Upsert: same logic as bootstrap (update existing, insert new)
    - SaveChangesAsync
    - Log: "Refreshed {Count} daily candles for {Symbol}, latest: {LatestDate}"

    **Get30DayHighAsync(string symbol, CancellationToken ct):**
    - Read `HighLookbackDays` from options (default 30)
    - Calculate startDate = today.AddDays(-lookbackDays), today = DateOnly.FromDateTime(DateTime.UtcNow)
    - Query: `dbContext.DailyPrices.Where(p => p.Symbol == symbol && p.Date >= startDate && p.Date <= today)`
    - Use `.MaxAsync(p => (decimal?)p.Close, ct)` — use daily close (not intraday high), per CONTEXT.md decision
    - If null (no data), log warning "No price data available for 30-day high calculation" and return 0
    - Log debug: "30-day high for {Symbol}: {High} (from {Count} days)"
    - Return the max close value

    **Get200DaySmaAsync(string symbol, CancellationToken ct):**
    - Read `BearMarketMaPeriod` from options (default 200)
    - Calculate startDate = today.AddDays(-maPeriod)
    - Query close prices into memory: `dbContext.DailyPrices.Where(...).OrderBy(p => p.Date).Select(p => p.Close).ToListAsync(ct)`
    - If count < maPeriod * 0.9 (allow 10% tolerance for gaps), log warning "Insufficient data for {MaPeriod}-day SMA: only {Count} days available" and return 0 (caller should skip bear boost)
    - Calculate SMA: `closePrices.Average()`
    - Log debug: "200-day SMA for {Symbol}: {SMA} (from {Count} days)"
    - Return the average

    **Key design decisions:**
    - Use decimal for ALL price math (never double/float)
    - Use `DateOnly.FromDateTime(DateTime.UtcNow)` for UTC day boundary
    - Return 0 for unavailable data (caller decides how to handle: 30-day high=0 means skip dip calc, SMA=0 means skip bear boost)
    - Per CONTEXT.md stale data policy: use last known values in DB, don't require freshness. Background refresh handles keeping data current.
    - Use structured logging with named placeholders throughout
  </action>
  <verify>
    `dotnet build TradingBot.sln` compiles without errors. IPriceDataService interface has all 4 methods. PriceDataService constructor accepts DbContext, HyperliquidClient, IOptionsMonitor, ILogger.
  </verify>
  <done>
    PriceDataService can bootstrap 200 days of historical data, fetch daily candle updates, calculate 30-day high from close prices, and calculate 200-day SMA. Returns 0 for missing/insufficient data with appropriate logging.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PriceDataRefreshService background job</name>
  <files>
    TradingBot.ApiService/Application/BackgroundJobs/PriceDataRefreshService.cs
  </files>
  <action>
    **Create PriceDataRefreshService.cs** in `TradingBot.ApiService/Application/BackgroundJobs/`:

    Extend `BackgroundService` (not TimeBackgroundService — this needs custom scheduling logic for "run at 00:05 UTC daily" rather than fixed intervals).

    Dependencies (constructor injection):
    - `IServiceScopeFactory scopeFactory`
    - `ILogger<PriceDataRefreshService> logger`

    **ExecuteAsync(CancellationToken stoppingToken):**

    Step 1: Bootstrap on startup
    - Create scope, resolve IPriceDataService
    - Call `BootstrapHistoricalDataAsync("BTC", stoppingToken)`
    - Wrap in try/catch — log error but don't crash (DCA can still work with existing data)
    - Log: "Price data bootstrap completed on startup"

    Step 2: Daily refresh loop
    - While not cancelled:
      - Calculate next run time: 00:05 UTC today (or tomorrow if already past)
        - `var targetTime = new TimeOnly(0, 5)` (5 minutes past midnight to let exchange finalize daily candle)
        - `var now = DateTimeOffset.UtcNow`
        - `var todayTarget = new DateTimeOffset(DateOnly.FromDateTime(now.UtcDateTime.Date).ToDateTime(targetTime), TimeSpan.Zero)`
        - `var nextRun = todayTarget > now ? todayTarget : todayTarget.AddDays(1)`
        - `var delay = nextRun - now`
      - Log: "Next price data refresh at {NextRun} UTC (in {Delay})"
      - `await Task.Delay(delay, stoppingToken)`
      - Create scope, resolve IPriceDataService
      - Call `FetchAndStoreDailyCandleAsync("BTC", stoppingToken)`
      - Wrap in try/catch — log error, continue loop (don't crash on transient failures)
      - Log: "Daily candle refresh completed for {Date}"

    **Key design decisions:**
    - Bootstrap runs ONCE on startup (ensures data exists for first DCA execution)
    - Daily refresh at 00:05 UTC aligns with UTC day boundary for candle finalization
    - Errors are logged but never crash the service — the DCA scheduler must not be affected
    - Uses IServiceScopeFactory pattern (same as DcaSchedulerBackgroundService) for scoped DbContext resolution
  </action>
  <verify>
    1. `dotnet build TradingBot.sln` compiles without errors.
    2. PriceDataRefreshService extends BackgroundService.
    3. ExecuteAsync calls BootstrapHistoricalDataAsync on startup and FetchAndStoreDailyCandleAsync in a daily loop.
    4. All operations wrapped in try/catch with error logging.
  </verify>
  <done>
    PriceDataRefreshService bootstraps historical data on app start and refreshes daily candle at 00:05 UTC. Errors are logged but never crash the service. Uses IServiceScopeFactory for scoped service resolution.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` succeeds
2. IPriceDataService has 4 methods: BootstrapHistoricalDataAsync, FetchAndStoreDailyCandleAsync, Get30DayHighAsync, Get200DaySmaAsync
3. PriceDataService uses decimal for all price calculations
4. PriceDataService returns 0 for insufficient data (not throwing exceptions)
5. PriceDataRefreshService bootstraps on startup and runs daily at 00:05 UTC
6. All error handling is graceful (catch + log, never crash)
</verification>

<success_criteria>
- PriceDataService calculates 30-day high from daily close prices (not intraday highs) per CONTEXT.md
- 200-day SMA uses simple LINQ Average() over in-memory close prices
- Bootstrap fetches 200 days of historical data on first run
- Background service is resilient to transient failures
- All code follows existing patterns (structured logging, IServiceScopeFactory, IOptionsMonitor)
</success_criteria>

<output>
After completion, create `.planning/phases/03-smart-multipliers/03-02-SUMMARY.md`
</output>
