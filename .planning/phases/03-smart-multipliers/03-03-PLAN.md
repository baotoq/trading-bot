---
phase: 03-smart-multipliers
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - TradingBot.ApiService/Application/Services/DcaExecutionService.cs
  - TradingBot.ApiService/Configuration/DcaOptions.cs
  - TradingBot.ApiService/Program.cs
  - TradingBot.ApiService/appsettings.json
autonomous: true

must_haves:
  truths:
    - "DCA execution calculates multiplier from 30-day high dip tiers and 200-day MA bear boost"
    - "Multipliers stack multiplicatively: dip tier * bear boost (e.g., 2x * 1.5x = 3x)"
    - "Max multiplier cap is enforced (configurable, default 4.5x)"
    - "Buy amount = min(available_balance, base_daily_amount * total_multiplier)"
    - "Each purchase records: total multiplier, tier name, drop %, 30-day high, 200-day MA value"
    - "Graceful degradation: if price data unavailable, falls back to 1x multiplier with warning"
    - "PriceDataService and PriceDataRefreshService registered in DI container"
  artifacts:
    - path: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      provides: "Multiplier-aware DCA execution"
      contains: "IPriceDataService"
    - path: "TradingBot.ApiService/Configuration/DcaOptions.cs"
      provides: "MaxMultiplierCap option"
      contains: "MaxMultiplierCap"
    - path: "TradingBot.ApiService/Program.cs"
      provides: "Phase 3 service registrations"
      contains: "IPriceDataService"
  key_links:
    - from: "DcaExecutionService"
      to: "IPriceDataService"
      via: "constructor injection"
      pattern: "IPriceDataService"
    - from: "DcaExecutionService"
      to: "DcaOptions.MultiplierTiers"
      via: "IOptionsMonitor"
      pattern: "MultiplierTiers"
    - from: "Program.cs"
      to: "PriceDataService"
      via: "AddScoped registration"
      pattern: "AddScoped<IPriceDataService"
    - from: "Program.cs"
      to: "PriceDataRefreshService"
      via: "AddHostedService registration"
      pattern: "AddHostedService<PriceDataRefreshService>"
---

<objective>
Wire smart multiplier calculation into the DCA execution pipeline: calculate dip tier + bear boost multipliers, apply to buy amount, record metadata on each purchase, and register all Phase 3 services.

Purpose: This is the integration plan that makes multipliers actually work end-to-end. The data layer (Plan 01) and price calculations (Plan 02) are ready — this plan connects them to the existing DCA buy flow.

Output: Updated DcaExecutionService with multiplier logic, DcaOptions with MaxMultiplierCap, Program.cs with new service registrations, appsettings.json with MaxMultiplierCap config.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-smart-multipliers/03-CONTEXT.md
@.planning/phases/03-smart-multipliers/03-RESEARCH.md
@.planning/phases/03-smart-multipliers/03-01-SUMMARY.md
@.planning/phases/03-smart-multipliers/03-02-SUMMARY.md
@TradingBot.ApiService/Application/Services/DcaExecutionService.cs
@TradingBot.ApiService/Application/Services/IDcaExecutionService.cs
@TradingBot.ApiService/Application/Services/IPriceDataService.cs
@TradingBot.ApiService/Configuration/DcaOptions.cs
@TradingBot.ApiService/Program.cs
@TradingBot.ApiService/appsettings.json
@TradingBot.ApiService/Models/Purchase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MaxMultiplierCap to DcaOptions and update appsettings.json</name>
  <files>
    TradingBot.ApiService/Configuration/DcaOptions.cs
    TradingBot.ApiService/appsettings.json
  </files>
  <action>
    **Update DcaOptions.cs:**
    - Add property: `public decimal MaxMultiplierCap { get; set; } = 4.5m;`
    - Place it after `BearBoostFactor` for logical grouping with other multiplier settings

    **Update DcaOptionsValidator** in same file:
    - Add validation: if MaxMultiplierCap <= 0, error "MaxMultiplierCap must be greater than 0"
    - Add validation: if MaxMultiplierCap < 1, error "MaxMultiplierCap must be at least 1.0 (no multiplier reduction)"

    **Update appsettings.json:**
    - Add `"MaxMultiplierCap": 4.5` to the DcaOptions section (after BearBoostFactor)

    The default 4.5x is the natural max (3x dip tier * 1.5x bear boost = 4.5x). Setting it equal to natural max means effectively uncapped, but the config exists for safety.
  </action>
  <verify>
    `dotnet build TradingBot.sln` compiles without errors. MaxMultiplierCap appears in DcaOptions and appsettings.json.
  </verify>
  <done>
    DcaOptions has MaxMultiplierCap with default 4.5, validation ensures positive value >= 1.0, appsettings.json updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate multiplier calculation into DcaExecutionService and register Phase 3 services</name>
  <files>
    TradingBot.ApiService/Application/Services/DcaExecutionService.cs
    TradingBot.ApiService/Program.cs
  </files>
  <action>
    **Update DcaExecutionService constructor:**
    - Add `IPriceDataService priceDataService` parameter (primary constructor)

    **Modify ExecuteDailyPurchaseAsync** — replace the fixed 1x multiplier with smart calculation.

    After getting `currentPrice` (Step 4) and before calculating `btcQuantity`, add multiplier calculation:

    ```
    // Step 4b: Calculate smart multiplier
    var multiplierResult = await CalculateMultiplierAsync(currentPrice, options, ct);

    // Apply multiplier to base amount (capped by available balance)
    var multipliedAmount = options.BaseDailyAmount * multiplierResult.TotalMultiplier;
    var usdAmount = Math.Min(usdcBalance, multipliedAmount);
    ```

    Remove the existing line: `var usdAmount = Math.Min(usdcBalance, options.BaseDailyAmount);`
    (This line is currently before the price fetch — move balance check logic to AFTER multiplier calc since we need the multiplied amount to determine how much to buy.)

    **IMPORTANT refactor note:** The current code flow is:
    1. Check balance against BaseDailyAmount
    2. Set usdAmount = Min(balance, BaseDailyAmount)
    3. Get price

    The new flow should be:
    1. Check balance against MinimumBalance (keep early exit for truly empty wallet)
    2. Get price
    3. Calculate multiplier
    4. Set multipliedAmount = BaseDailyAmount * totalMultiplier
    5. Set usdAmount = Min(balance, multipliedAmount) — buy what you can up to multiplied amount
    6. Re-check: if usdAmount < MinimumOrderValue, skip

    Update the Purchase creation to populate metadata:
    ```
    var purchase = new Purchase
    {
        ExecutedAt = DateTimeOffset.UtcNow,
        Price = currentPrice,
        Quantity = 0,
        Cost = 0,
        Multiplier = multiplierResult.TotalMultiplier,
        MultiplierTier = multiplierResult.Tier,
        DropPercentage = multiplierResult.DropPercentage,
        High30Day = multiplierResult.High30Day,
        Ma200Day = multiplierResult.Ma200Day,
        Status = PurchaseStatus.Pending
    };
    ```

    **Add private helper method CalculateMultiplierAsync:**
    ```
    private async Task<MultiplierResult> CalculateMultiplierAsync(
        decimal currentPrice, DcaOptions options, CancellationToken ct)
    ```
    - Get 30-day high: `var high30Day = await priceDataService.Get30DayHighAsync("BTC", ct)`
    - Get 200-day SMA: `var ma200Day = await priceDataService.Get200DaySmaAsync("BTC", ct)`

    - Calculate dip percentage: if high30Day > 0: `(high30Day - currentPrice) / high30Day * 100m`, else 0
    - Find matching dip tier: iterate `options.MultiplierTiers.OrderByDescending(x => x.DropPercentage)`, first tier where `dropPercent >= t.DropPercentage`. Default dipMultiplier = 1.0m if no tier matches.
    - Track tier name as string (e.g., ">= 10%" or "None")

    - Calculate bear multiplier: if `ma200Day > 0 && currentPrice < ma200Day`: bearMultiplier = options.BearBoostFactor, else 1.0m
    - If ma200Day == 0: log warning "200-day SMA unavailable, skipping bear boost"

    - Stack: totalMultiplier = dipMultiplier * bearMultiplier
    - Cap: totalMultiplier = Math.Min(totalMultiplier, options.MaxMultiplierCap)

    - Log: "Multiplier: dip={DipMult}x (tier: {Tier}, drop: {Drop}%) * bear={BearMult}x = {Total}x (cap: {Cap}x)"

    - Return MultiplierResult record/class with: TotalMultiplier, DipMultiplier, BearMultiplier, Tier, DropPercentage, High30Day, Ma200Day

    **Define MultiplierResult** as a private nested record or a new file. Keep it simple — a record at the bottom of DcaExecutionService.cs or in a separate file `TradingBot.ApiService/Application/Services/MultiplierResult.cs`:
    ```
    public record MultiplierResult(
        decimal TotalMultiplier,
        decimal DipMultiplier,
        decimal BearMultiplier,
        string Tier,
        decimal DropPercentage,
        decimal High30Day,
        decimal Ma200Day);
    ```

    **Graceful degradation:** Wrap the multiplier calculation in try/catch. If any exception (e.g., price data service fails), log error and fall back to multiplier = 1.0m with all metadata = 0. Never let multiplier calculation failure prevent a DCA purchase.

    **Update Program.cs:**
    Add these registrations after the existing DCA service registration:
    ```
    // Price data service (scoped — uses DbContext)
    builder.Services.AddScoped<IPriceDataService, PriceDataService>();

    // Price data refresh (runs daily at 00:05 UTC, bootstraps on startup)
    builder.Services.AddHostedService<PriceDataRefreshService>();
    ```
    Add necessary `using` statements for the new namespaces.
  </action>
  <verify>
    1. `dotnet build TradingBot.sln` compiles without errors.
    2. DcaExecutionService constructor includes IPriceDataService parameter.
    3. Purchase records have multiplier metadata (grep for MultiplierTier, DropPercentage, High30Day, Ma200Day in the purchase creation code).
    4. Program.cs registers IPriceDataService and PriceDataRefreshService.
    5. MaxMultiplierCap is used in the cap calculation.
    6. Graceful fallback to 1.0x on calculation failure.
  </verify>
  <done>
    DcaExecutionService calculates smart multipliers from 30-day high dip tiers and 200-day MA bear boost. Multipliers stack multiplicatively and are capped. Purchase metadata fully populated. All Phase 3 services registered in DI. Fallback to 1x on failure ensures DCA never breaks.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` succeeds
2. Full multiplier pipeline works: price data -> 30d high -> dip tier -> bear boost -> stacking -> cap -> buy amount
3. Purchase entity populated with: Multiplier, MultiplierTier, DropPercentage, High30Day, Ma200Day
4. DcaOptions.MaxMultiplierCap validated and applied
5. Program.cs has AddScoped<IPriceDataService> and AddHostedService<PriceDataRefreshService>
6. Graceful degradation: multiplier calculation failure does not prevent DCA purchase
7. Buy amount = Min(available_balance, BaseDailyAmount * TotalMultiplier)
</verification>

<success_criteria>
- Dip tier calculation uses >= comparison (exactly 10% drop = 2x tier) per CONTEXT.md
- Bear boost applied only when currentPrice < 200-day SMA AND SMA > 0
- Stacking is multiplicative (dip * bear), not additive
- Cap applied after stacking: Math.Min(totalMultiplier, MaxMultiplierCap)
- Purchase records audit trail: every purchase shows the multiplier decision reasoning
- Insufficient funds: buys what it can up to the multiplied amount
- No existing functionality broken (basic DCA still works with default 1x if no price data)
</success_criteria>

<output>
After completion, create `.planning/phases/03-smart-multipliers/03-03-SUMMARY.md`
</output>
