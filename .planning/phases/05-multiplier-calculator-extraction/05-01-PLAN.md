---
phase: 05-multiplier-calculator-extraction
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Application/Services/MultiplierCalculator.cs
  - TradingBot.ApiService/Application/Services/DcaExecutionService.cs
  - tests/TradingBot.ApiService.Tests/Application/Services/MultiplierCalculatorTests.cs
  - tests/TradingBot.ApiService.Tests/TradingBot.ApiService.Tests.csproj
autonomous: true

must_haves:
  truths:
    - "MultiplierCalculator.Calculate() returns correct multiplier for each configured tier boundary (>= 5%, >= 10%, >= 20%)"
    - "Bear market detection activates when currentPrice < ma200Day and applies ADDITIVE boost (tierMultiplier + bearBoost)"
    - "Max cap clamps the final multiplier AFTER bear boost: min(tierMultiplier + bearBoost, maxCap)"
    - "Normal day (no tier triggered) returns multiplier=1.0 with tier='Base', never null"
    - "MA200 unavailable (0 or negative) treated as non-bear market with zero boost"
    - "DcaExecutionService delegates to MultiplierCalculator and produces equivalent behavior"
    - "FinalAmount in result equals baseAmount * capped multiplier"
  artifacts:
    - path: "TradingBot.ApiService/Application/Services/MultiplierCalculator.cs"
      provides: "Pure static MultiplierCalculator class and MultiplierResult record"
      contains: "static class MultiplierCalculator"
    - path: "tests/TradingBot.ApiService.Tests/Application/Services/MultiplierCalculatorTests.cs"
      provides: "Unit tests for all tier boundaries, bear market scenarios, edge cases, and golden snapshot"
      contains: "class MultiplierCalculatorTests"
  key_links:
    - from: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      to: "MultiplierCalculator.Calculate"
      via: "static method call replacing inline calculation"
      pattern: "MultiplierCalculator\\.Calculate\\("
---

<objective>
Extract multiplier calculation logic from DcaExecutionService into a pure, testable static class (MultiplierCalculator), verified by comprehensive TDD tests covering tier boundaries, bear market boost, max cap, and edge cases.

Purpose: Enable backtest simulation engine (Phase 6) to reuse the same multiplier logic as live DCA, with confidence from thorough unit tests. This is the only production code change in v1.1.

Output: MultiplierCalculator.cs (pure static class), MultiplierCalculatorTests.cs (comprehensive tests), updated DcaExecutionService.cs (delegates to calculator)
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multiplier-calculator-extraction/05-CONTEXT.md
@.planning/phases/05-multiplier-calculator-extraction/05-RESEARCH.md
@TradingBot.ApiService/Application/Services/DcaExecutionService.cs
@TradingBot.ApiService/Configuration/DcaOptions.cs
@TradingBot.ApiService/appsettings.json
</context>

<feature>
  <name>MultiplierCalculator extraction with ADDITIVE bear boost</name>
  <files>
    TradingBot.ApiService/Application/Services/MultiplierCalculator.cs
    TradingBot.ApiService/Application/Services/DcaExecutionService.cs
    tests/TradingBot.ApiService.Tests/Application/Services/MultiplierCalculatorTests.cs
    tests/TradingBot.ApiService.Tests/TradingBot.ApiService.Tests.csproj
  </files>
  <behavior>
    MultiplierCalculator.Calculate() is a pure static method that computes a rich MultiplierResult from inputs:
    - currentPrice, baseAmount, high30Day, ma200Day, tiers (IReadOnlyList of MultiplierTier), bearBoostFactor, maxCap

    **Result record (public):**
    - Multiplier (decimal): final capped multiplier value
    - Tier (string): matched tier name ("Base", ">= 5%", ">= 10%", ">= 20%") — NEVER null
    - IsBearMarket (bool): true when currentPrice < ma200Day AND ma200Day > 0
    - BearBoostApplied (decimal): bearBoostFactor if bear, else 0
    - DropPercentage (decimal): percentage drop from 30-day high
    - High30Day (decimal): passthrough for audit
    - Ma200Day (decimal): passthrough for audit
    - FinalAmount (decimal): baseAmount * Multiplier

    **Tier matching (from current production logic):**
    - Calculate dropPercent = (high30Day - currentPrice) / high30Day * 100
    - Match tiers descending by DropPercentage, first where dropPercent >= tier.DropPercentage wins
    - No match = multiplier 1.0, tier "Base"
    - high30Day <= 0 = multiplier 1.0, tier "Base", dropPercent 0

    **Bear boost (ADDITIVE — per locked decision, CHANGING from current multiplicative code):**
    - isBearMarket = ma200Day > 0 AND currentPrice < ma200Day
    - bearBoostApplied = isBearMarket ? bearBoostFactor : 0
    - uncappedMultiplier = tierMultiplier + bearBoostApplied
    - finalMultiplier = min(uncappedMultiplier, maxCap)

    **Test cases (hand-calculated with default tiers [5%->1.5x, 10%->2.0x, 20%->3.0x], bear=1.5, cap=4.5):**

    Tier boundaries (high30Day=100000, ma200Day=200000 so no bear):
    - dropPercent=0.00 (price=100000): multiplier=1.0, tier="Base", finalAmount=10.0
    - dropPercent=4.99 (price=95010): multiplier=1.0, tier="Base"
    - dropPercent=5.00 (price=95000): multiplier=1.5, tier=">= 5%"
    - dropPercent=5.01 (price=94990): multiplier=1.5, tier=">= 5%"
    - dropPercent=9.99 (price=90010): multiplier=1.5, tier=">= 5%"
    - dropPercent=10.00 (price=90000): multiplier=2.0, tier=">= 10%"
    - dropPercent=19.99 (price=80010): multiplier=2.0, tier=">= 10%"
    - dropPercent=20.00 (price=80000): multiplier=3.0, tier=">= 20%"
    - dropPercent=50.00 (price=50000): multiplier=3.0, tier=">= 20%"

    Bear market + tier combos (high30Day=100000, ma200Day=90000 so bear when price < 90000):
    - price=95000 (5% drop, NOT bear since 95000 > 90000): mult=1.5+0=1.5
    - price=85000 (15% drop, bear since 85000 < 90000): mult=2.0+1.5=3.5
    - price=75000 (25% drop, bear): mult=3.0+1.5=4.5 (at cap)
    - price=50000 (50% drop, bear): mult=3.0+1.5=4.5 (capped from 4.5)

    Edge cases:
    - ma200Day=0: isBearMarket=false, no boost
    - high30Day=0: dropPercent=0, tier="Base", multiplier=1.0
    - empty tiers list: multiplier=1.0, tier="Base"
    - currentPrice > high30Day (negative drop): multiplier=1.0, tier="Base" (dropPercent < 0, no tier matches)

    Cap enforcement (high30Day=100000, ma200Day=50000, cap=3.0):
    - price=75000 (25% drop, bear): uncapped=3.0+1.5=4.5, capped=3.0

    **Golden snapshot:**
    - Run production-like scenarios (from appsettings.json defaults) through calculator
    - Capture result as snapshot baseline for regression detection
  </behavior>
  <implementation>
    **RED phase:**
    1. Add Snapper package to test project: `dotnet add tests/TradingBot.ApiService.Tests package Snapper`
    2. Create `tests/TradingBot.ApiService.Tests/Application/Services/MultiplierCalculatorTests.cs`
    3. Write test class with:
       - DefaultTiers static field matching appsettings.json config
       - [Theory] + [InlineData] for tier boundary tests (9 cases above)
       - [Theory] + [InlineData] for bear market + tier combos (4 cases above)
       - [Fact] for max cap enforcement
       - [Fact] for each edge case (ma200Day=0, high30Day=0, empty tiers, negative drop)
       - [Fact] for FinalAmount calculation verification
       - [Fact] for golden snapshot using Snapper (ShouldMatchSnapshot)
    4. Create minimal stub `MultiplierCalculator.cs` that compiles but returns wrong values
    5. Run tests — ALL must fail (red)
    6. Commit: `test(05-01): add failing tests for MultiplierCalculator`

    **GREEN phase:**
    1. Implement `MultiplierCalculator.Calculate()` in `TradingBot.ApiService/Application/Services/MultiplierCalculator.cs`:
       - Public static class in `TradingBot.ApiService.Application.Services` namespace
       - Public record `MultiplierResult` with all 8 fields per locked decision
       - Calculate method signature: `(decimal currentPrice, decimal baseAmount, decimal high30Day, decimal ma200Day, IReadOnlyList<MultiplierTier> tiers, decimal bearBoostFactor, decimal maxCap)`
       - Drop percent calculation: `(high30Day - currentPrice) / high30Day * 100` (guard: high30Day <= 0 => 0)
       - Tier matching: OrderByDescending, FirstOrDefault where dropPercent >= tier.DropPercentage
       - Bear detection: `ma200Day > 0 && currentPrice < ma200Day`
       - ADDITIVE boost: `tierMultiplier + bearBoostApplied` (NOT multiplicative — this CHANGES behavior from current code per locked decision)
       - Cap: `Math.Min(uncapped, maxCap)`
       - FinalAmount: `baseAmount * finalMultiplier`
    2. Run tests — ALL must pass (green)
    3. Commit: `feat(05-01): implement MultiplierCalculator with additive bear boost`

    **REFACTOR phase:**
    1. Update `DcaExecutionService.cs`:
       - Remove the `internal record MultiplierResult(...)` at bottom of file (old shape)
       - Import the new `MultiplierResult` from `MultiplierCalculator.cs`
       - Replace inline calculation in `CalculateMultiplierAsync` with `MultiplierCalculator.Calculate(...)` call
       - Keep async wrapper (fetches high30Day, ma200Day), try-catch, logging in service
       - Update all references from `TotalMultiplier` to `Multiplier` (3 occurrences in service: lines 101, 105, 141)
       - Update error fallback to use MultiplierCalculator.Calculate with zero/empty inputs
       - Keep logging after Calculate call using new result field names
    2. Verify: `dotnet build TradingBot.sln` compiles clean
    3. Run tests: `dotnet test` — ALL pass
    4. Commit: `refactor(05-01): delegate DcaExecutionService to MultiplierCalculator`

    **IMPORTANT behavioral change note:**
    Current production code uses MULTIPLICATIVE bear boost: `dipMultiplier * bearMultiplier` (e.g., 2.0 * 1.5 = 3.0).
    New code uses ADDITIVE per locked decision: `tierMultiplier + bearBoost` (e.g., 2.0 + 1.5 = 3.5).
    This is an intentional change per user decision, not a bug. The golden snapshot will capture the NEW additive behavior.
  </implementation>
</feature>

<verification>
1. `dotnet build TradingBot.sln` — compiles with zero errors and zero warnings
2. `dotnet test` — all MultiplierCalculator tests pass
3. MultiplierCalculator.cs contains NO async, NO DI, NO database access, NO logging — pure static only
4. MultiplierResult record has exactly 8 fields: Multiplier, Tier, IsBearMarket, BearBoostApplied, DropPercentage, High30Day, Ma200Day, FinalAmount
5. DcaExecutionService.CalculateMultiplierAsync calls MultiplierCalculator.Calculate (grep confirms)
6. No remaining references to old `TotalMultiplier`, `DipMultiplier`, `BearMultiplier` field names in production code
7. Bear boost is ADDITIVE in calculator (tierMultiplier + bearBoost, NOT tierMultiplier * bearMultiplier)
</verification>

<success_criteria>
- MultiplierCalculator is a pure static class with zero dependencies
- All tier boundary tests pass with hand-calculated expected values
- Bear market + tier combination tests verify ADDITIVE boost behavior
- Max cap correctly clamps AFTER bear boost application
- Edge cases (0 values, empty tiers, negative drops) handled gracefully
- DcaExecutionService compiles and delegates to MultiplierCalculator
- Golden snapshot captures baseline for regression detection
- Solution builds and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-multiplier-calculator-extraction/05-01-SUMMARY.md`
</output>
