---
phase: 02-core-dca-engine
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - TradingBot.ApiService/Application/Services/DcaExecutionService.cs
  - TradingBot.ApiService/Application/Services/IDcaExecutionService.cs
autonomous: true

must_haves:
  truths:
    - "Bot checks USDC balance before placing order"
    - "Bot skips and notifies if balance below $1 or order below $10 minimum"
    - "Bot buys available balance if less than target amount"
    - "Bot places IOC spot buy order on Hyperliquid"
    - "Purchase record persisted with price, quantity, cost, status, orderId, rawResponse"
    - "Partial fills correctly recorded as PartiallyFilled status"
    - "Domain events published after database commit"
    - "Distributed lock prevents concurrent execution"
    - "Idempotency check prevents duplicate purchases on same day"
  artifacts:
    - path: "TradingBot.ApiService/Application/Services/IDcaExecutionService.cs"
      provides: "Interface for DCA execution"
      contains: "interface IDcaExecutionService"
    - path: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      provides: "Core DCA buy logic: lock, idempotency, balance, order, persist, events"
      min_lines: 100
  key_links:
    - from: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      to: "TradingBot.ApiService/Infrastructure/Hyperliquid/HyperliquidClient.cs"
      via: "constructor injection, calls GetBalancesAsync, GetSpotPriceAsync, GetSpotMetadataAsync, PlaceSpotOrderAsync"
      pattern: "HyperliquidClient"
    - from: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      to: "TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs"
      via: "constructor injection, queries Purchases, adds Purchase, SaveChangesAsync"
      pattern: "TradingBotDbContext"
    - from: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      to: "TradingBot.ApiService/Application/Events/"
      via: "MediatR IPublisher.Publish after SaveChangesAsync"
      pattern: "Publish.*PurchaseCompletedEvent|Publish.*PurchaseFailedEvent|Publish.*PurchaseSkippedEvent"
    - from: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      to: "TradingBot.ApiService/BuildingBlocks/DistributedLocks/DistributedLock.cs"
      via: "IDistributedLock.AcquireLockAsync for daily purchase idempotency"
      pattern: "AcquireLockAsync"
---

<objective>
Implement the core DCA execution service that performs the complete buy flow: acquire lock, check idempotency, check balance, place order, handle partial fills, persist purchase, and publish domain events.

Purpose: This is the central business logic of the bot. It orchestrates the entire purchase pipeline and is the single service called by the scheduler (Plan 03). All edge cases (insufficient balance, partial fills, failed orders) are handled here.

Output: IDcaExecutionService interface and DcaExecutionService implementation with the full buy flow.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-dca-engine/02-CONTEXT.md
@.planning/phases/02-core-dca-engine/02-RESEARCH.md
@.planning/phases/02-core-dca-engine/02-01-SUMMARY.md
@TradingBot.ApiService/Infrastructure/Hyperliquid/HyperliquidClient.cs
@TradingBot.ApiService/Infrastructure/Hyperliquid/Models/HyperliquidModels.cs
@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
@TradingBot.ApiService/BuildingBlocks/DistributedLocks/DistributedLock.cs
@TradingBot.ApiService/Configuration/DcaOptions.cs
@TradingBot.ApiService/BuildingBlocks/BaseEntity.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: IDcaExecutionService interface</name>
  <files>
    TradingBot.ApiService/Application/Services/IDcaExecutionService.cs
  </files>
  <action>
    Create interface in `Application/Services/` namespace `TradingBot.ApiService.Application.Services`:

    ```csharp
    public interface IDcaExecutionService
    {
        Task ExecuteDailyPurchaseAsync(DateOnly purchaseDate, CancellationToken ct = default);
    }
    ```

    Single method — takes the date to purchase for (used for idempotency check) and cancellation token. Returns Task (void) because outcomes are communicated via domain events. The caller (scheduler) does not need to know the result — events drive notifications.

    Use file-scoped namespace.
  </action>
  <verify>
    `dotnet build TradingBot.ApiService` compiles.
  </verify>
  <done>
    IDcaExecutionService interface exists with ExecuteDailyPurchaseAsync method.
  </done>
</task>

<task type="auto">
  <name>Task 2: DcaExecutionService implementation</name>
  <files>
    TradingBot.ApiService/Application/Services/DcaExecutionService.cs
  </files>
  <action>
    Create DcaExecutionService in `Application/Services/` namespace `TradingBot.ApiService.Application.Services`.

    **Constructor dependencies** (use primary constructor):
    - `HyperliquidClient hyperliquidClient`
    - `TradingBotDbContext dbContext`
    - `IDistributedLock distributedLock`
    - `IPublisher publisher` (MediatR — for publishing domain events)
    - `IOptionsMonitor<DcaOptions> dcaOptions`
    - `ILogger<DcaExecutionService> logger`

    **ExecuteDailyPurchaseAsync(DateOnly purchaseDate, CancellationToken ct)** implementation flow:

    **Step 1 — Acquire distributed lock:**
    ```csharp
    var lockKey = $"dca-purchase-{purchaseDate:yyyy-MM-dd}";
    await using var lockResponse = await distributedLock.AcquireLockAsync(lockKey, TimeSpan.FromMinutes(5), ct);
    if (!lockResponse.Success)
    {
        logger.LogWarning("Could not acquire lock for {Date}, another instance may be running", purchaseDate);
        return;
    }
    ```

    **Step 2 — Idempotency check (query database for today's purchase):**
    ```csharp
    var todayStart = purchaseDate.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);
    var todayEnd = purchaseDate.AddDays(1).ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);

    var existingPurchase = await dbContext.Purchases
        .Where(p => p.ExecutedAt >= todayStart && p.ExecutedAt < todayEnd)
        .Where(p => p.Status == PurchaseStatus.Filled || p.Status == PurchaseStatus.PartiallyFilled)
        .FirstOrDefaultAsync(ct);

    if (existingPurchase != null)
    {
        logger.LogInformation("Purchase already completed today {Date}: {PurchaseId}", purchaseDate, existingPurchase.Id);
        await publisher.Publish(new PurchaseSkippedEvent("Already purchased today", null, null, DateTimeOffset.UtcNow), ct);
        return;
    }
    ```

    **Step 3 — Check USDC balance:**
    ```csharp
    const decimal MinimumBalance = 1.0m;
    const decimal MinimumOrderValue = 10.0m;
    var options = dcaOptions.CurrentValue;

    var usdcBalance = await hyperliquidClient.GetBalancesAsync(ct);
    logger.LogInformation("USDC balance: {Balance}, target amount: {Target}", usdcBalance, options.BaseDailyAmount);

    if (usdcBalance < MinimumBalance)
    {
        logger.LogWarning("Balance {Balance} below minimum {Min}, skipping", usdcBalance, MinimumBalance);
        await publisher.Publish(new PurchaseSkippedEvent("Insufficient balance", usdcBalance, options.BaseDailyAmount, DateTimeOffset.UtcNow), ct);
        return;
    }

    // Buy what we can if balance < target
    var usdAmount = Math.Min(usdcBalance, options.BaseDailyAmount);

    if (usdAmount < MinimumOrderValue)
    {
        logger.LogWarning("Amount {Amount} below minimum order {Min}", usdAmount, MinimumOrderValue);
        await publisher.Publish(new PurchaseSkippedEvent($"Amount below minimum order value (${MinimumOrderValue})", usdcBalance, MinimumOrderValue, DateTimeOffset.UtcNow), ct);
        return;
    }
    ```

    **Step 4 — Get price and calculate order size:**
    ```csharp
    var currentPrice = await hyperliquidClient.GetSpotPriceAsync("BTC/USDC", ct);
    var meta = await hyperliquidClient.GetSpotMetadataAsync(ct);
    var btcAssetIndex = meta.Universe.FindIndex(u => u.Name == "BTC/USDC");

    if (btcAssetIndex == -1)
        throw new InvalidOperationException("BTC/USDC not found in Hyperliquid spot metadata");

    // Calculate BTC quantity and round to szDecimals (use 5 decimals for BTC as standard)
    var btcQuantity = usdAmount / currentPrice;
    var roundedQuantity = Math.Round(btcQuantity, 5, MidpointRounding.ToZero); // Round DOWN to avoid exceeding balance

    logger.LogInformation("Placing order: {UsdAmount} USD -> {BtcQty} BTC at {Price}", usdAmount, roundedQuantity, currentPrice);
    ```

    **Step 5 — Place order:**
    Use a try-catch around the order placement. Set a high limit price (e.g., currentPrice * 1.05m — 5% above market) to ensure IOC fills immediately while protecting against extreme slippage.

    ```csharp
    var purchase = new Purchase
    {
        ExecutedAt = DateTimeOffset.UtcNow,
        Price = currentPrice,
        Quantity = 0, // Will be updated with actual fill
        Cost = 0, // Will be updated with actual cost
        Multiplier = 1.0m, // Fixed 1x for Phase 2, smart multipliers in Phase 3
        Status = PurchaseStatus.Pending
    };

    try
    {
        var limitPrice = currentPrice * 1.05m; // 5% slippage tolerance for IOC
        var orderResponse = await hyperliquidClient.PlaceSpotOrderAsync(btcAssetIndex, true, roundedQuantity, limitPrice, ct);

        // Parse fill info from response
        var status = orderResponse.Response?.Data?.Statuses.FirstOrDefault();
        var filled = status?.Filled;

        if (filled != null)
        {
            var filledQty = decimal.Parse(filled.TotalSz, System.Globalization.CultureInfo.InvariantCulture);
            var avgPrice = decimal.Parse(filled.AvgPx, System.Globalization.CultureInfo.InvariantCulture);

            purchase.Quantity = filledQty;
            purchase.Price = avgPrice;
            purchase.Cost = filledQty * avgPrice;
            purchase.OrderId = filled.Oid.ToString();
            purchase.Status = filledQty >= roundedQuantity * 0.95m ? PurchaseStatus.Filled : PurchaseStatus.PartiallyFilled;
        }
        else if (status?.Resting != null)
        {
            // Order is resting (not filled) — unusual for IOC, treat as partial
            purchase.OrderId = status.Resting.Oid.ToString();
            purchase.Status = PurchaseStatus.PartiallyFilled;
            purchase.FailureReason = "Order resting instead of filling (IOC should not rest)";
        }
        else
        {
            purchase.Status = PurchaseStatus.Failed;
            purchase.FailureReason = "No fill or resting status in order response";
        }

        purchase.RawResponse = System.Text.Json.JsonSerializer.Serialize(orderResponse);
    }
    catch (HyperliquidApiException ex)
    {
        purchase.Status = PurchaseStatus.Failed;
        purchase.FailureReason = ex.Message;
        purchase.RawResponse = ex.Message;
    }
    ```

    **Step 6 — Persist and publish events:**
    ```csharp
    dbContext.Purchases.Add(purchase);
    await dbContext.SaveChangesAsync(ct);

    // Publish domain event AFTER database commit
    if (purchase.Status == PurchaseStatus.Filled || purchase.Status == PurchaseStatus.PartiallyFilled)
    {
        // Get updated balances for notification
        var remainingUsdc = await hyperliquidClient.GetBalancesAsync(ct);
        // Get BTC balance from Hyperliquid (source of truth per research)
        // For now, use the filled quantity as BTC balance approximation
        // (exact BTC balance would require parsing spot balances for BTC token)
        var currentBtcBalance = purchase.Quantity; // TODO: Replace with actual BTC balance query in Phase 4

        await publisher.Publish(new PurchaseCompletedEvent(
            purchase.Id,
            purchase.Quantity,
            purchase.Price,
            purchase.Cost,
            remainingUsdc,
            currentBtcBalance,
            purchase.ExecutedAt
        ), ct);
    }
    else
    {
        await publisher.Publish(new PurchaseFailedEvent(
            "OrderFailed",
            purchase.FailureReason ?? "Unknown error",
            0, // RetryCount — retries handled at scheduler level
            DateTimeOffset.UtcNow
        ), ct);
    }
    ```

    **Important implementation details:**
    - Use `System.Globalization.CultureInfo.InvariantCulture` for ALL decimal.Parse calls (Hyperliquid returns strings)
    - Use `DateTimeOffset.UtcNow` for all timestamps (per codebase convention of UTC everywhere)
    - Structured logging with Serilog named placeholders (not string interpolation)
    - Purchase entity inherits BaseEntity (UUIDv7 ID auto-generated)
    - The lock TTL of 5 minutes provides enough time for the full flow
    - Order placement catch block catches `HyperliquidApiException` specifically (from HyperliquidClient.cs)
    - Do NOT catch general Exception around order placement — let transient failures bubble up for retry at scheduler level

    **What NOT to do:**
    - Do NOT poll order status (user decided to trust IOC immediate response)
    - Do NOT retry order placement within this service (retries happen at scheduler level)
    - Do NOT use `float` or `double` for any financial calculations (always `decimal`)
    - Do NOT publish events before SaveChangesAsync (events must follow committed state)
  </action>
  <verify>
    Run `dotnet build TradingBot.ApiService` — should compile with zero errors. Verify DcaExecutionService:
    1. Has constructor with all 6 dependencies
    2. Acquires distributed lock before any operations
    3. Checks for existing purchase before proceeding
    4. Checks balance and publishes PurchaseSkippedEvent if insufficient
    5. Places IOC order via HyperliquidClient.PlaceSpotOrderAsync
    6. Parses fill response and sets correct PurchaseStatus
    7. Persists Purchase entity via DbContext.SaveChangesAsync
    8. Publishes appropriate domain event AFTER SaveChangesAsync
  </verify>
  <done>
    DcaExecutionService implements the complete buy flow: lock -> idempotency -> balance check -> order -> persist -> events. All edge cases handled: insufficient balance, partial fills, failed orders. Purchase entity persisted with all metadata. Domain events published after database commit.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.ApiService` compiles with zero errors
2. DcaExecutionService has exactly 6 constructor dependencies (HyperliquidClient, TradingBotDbContext, IDistributedLock, IPublisher, IOptionsMonitor<DcaOptions>, ILogger)
3. Lock key includes date string for daily granularity
4. Idempotency query filters by date range AND successful status
5. Balance check uses decimal constants ($1 min balance, $10 min order)
6. Order uses IOC via PlaceSpotOrderAsync with 5% slippage limit price
7. Fill response parsed for totalSz and avgPx
8. Purchase.Status correctly set to Filled/PartiallyFilled/Failed based on response
9. SaveChangesAsync called BEFORE Publish
10. Three event types published: PurchaseCompletedEvent, PurchaseFailedEvent, PurchaseSkippedEvent
</verification>

<success_criteria>
- Build succeeds with zero errors
- Full buy pipeline: lock -> idempotency -> balance -> price -> order -> persist -> event
- Partial fills handled (PartiallyFilled status when qty < 95% of requested)
- All decimal parsing uses CultureInfo.InvariantCulture
- Domain events published AFTER database commit
- HyperliquidApiException caught for order failures, general exceptions NOT caught (bubble up for retry)
- Follows codebase conventions: file-scoped namespaces, primary constructor, structured logging, Async suffix
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-dca-engine/02-02-SUMMARY.md`
</output>
