---
phase: 02-core-dca-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
  - TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs
  - TradingBot.ApiService/Application/Events/PurchaseSkippedEvent.cs
  - TradingBot.ApiService/Configuration/TelegramOptions.cs
  - TradingBot.ApiService/Infrastructure/Telegram/TelegramNotificationService.cs
  - TradingBot.ApiService/Infrastructure/Telegram/ServiceCollectionExtensions.cs
  - TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
  - TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
  - TradingBot.ApiService/Application/Handlers/PurchaseSkippedHandler.cs
  - TradingBot.ApiService/appsettings.json
autonomous: true
user_setup:
  - service: telegram
    why: "Bot notifications for purchase events"
    env_vars:
      - name: Telegram__BotToken
        source: "BotFather on Telegram -> create bot -> copy token"
      - name: Telegram__ChatId
        source: "Send /start to your bot, then GET https://api.telegram.org/bot<TOKEN>/getUpdates to find chat_id"

must_haves:
  truths:
    - "Telegram notification sent on successful purchase with price, qty, cost, BTC balance, remaining USDC"
    - "Telegram notification sent on failed purchase with error type, message, retry count"
    - "Telegram notification sent on skipped purchase with reason (low balance, already bought, missed window)"
    - "Domain events decouple purchase execution from notification logic"
  artifacts:
    - path: "TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs"
      provides: "Domain event for successful purchase"
      contains: "record PurchaseCompletedEvent"
    - path: "TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs"
      provides: "Domain event for failed purchase"
      contains: "record PurchaseFailedEvent"
    - path: "TradingBot.ApiService/Application/Events/PurchaseSkippedEvent.cs"
      provides: "Domain event for skipped purchase"
      contains: "record PurchaseSkippedEvent"
    - path: "TradingBot.ApiService/Infrastructure/Telegram/TelegramNotificationService.cs"
      provides: "Telegram message sending with Markdown formatting"
      contains: "class TelegramNotificationService"
    - path: "TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs"
      provides: "Handles PurchaseCompletedEvent -> Telegram success message"
      contains: "INotificationHandler<PurchaseCompletedEvent>"
    - path: "TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs"
      provides: "Handles PurchaseFailedEvent -> Telegram failure message"
      contains: "INotificationHandler<PurchaseFailedEvent>"
    - path: "TradingBot.ApiService/Application/Handlers/PurchaseSkippedHandler.cs"
      provides: "Handles PurchaseSkippedEvent -> Telegram skip message"
      contains: "INotificationHandler<PurchaseSkippedEvent>"
  key_links:
    - from: "TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs"
      to: "TradingBot.ApiService/Infrastructure/Telegram/TelegramNotificationService.cs"
      via: "constructor injection"
      pattern: "TelegramNotificationService"
    - from: "TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs"
      to: "TradingBot.ApiService/BuildingBlocks/IDomainEvent.cs"
      via: "implements IDomainEvent (INotification)"
      pattern: "IDomainEvent"
---

<objective>
Create domain events for purchase outcomes (success, failure, skip) and Telegram notification infrastructure with MediatR handlers that send formatted messages for each event type.

Purpose: Decouples purchase execution from notification logic. The DCA execution service (Plan 02) will publish events, and these handlers respond independently. Telegram errors never block purchase execution.

Output: Three domain event records, TelegramNotificationService for sending formatted messages, three MediatR notification handlers, and TelegramOptions configuration.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-dca-engine/02-CONTEXT.md
@.planning/phases/02-core-dca-engine/02-RESEARCH.md
@TradingBot.ApiService/BuildingBlocks/IDomainEvent.cs
@TradingBot.ApiService/Program.cs
@TradingBot.ApiService/appsettings.json
@TradingBot.ApiService/TradingBot.ApiService.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Domain events and Telegram configuration</name>
  <files>
    TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
    TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs
    TradingBot.ApiService/Application/Events/PurchaseSkippedEvent.cs
    TradingBot.ApiService/Configuration/TelegramOptions.cs
    TradingBot.ApiService/appsettings.json
  </files>
  <action>
    Create three domain event records in `Application/Events/` namespace `TradingBot.ApiService.Application.Events`:

    1. **PurchaseCompletedEvent** — implements `IDomainEvent` (which extends MediatR `INotification`):
       ```
       public record PurchaseCompletedEvent(
           Guid PurchaseId,
           decimal BtcAmount,
           decimal Price,
           decimal UsdSpent,
           decimal RemainingUsdc,
           decimal CurrentBtcBalance,
           DateTimeOffset ExecutedAt
       ) : IDomainEvent;
       ```

    2. **PurchaseFailedEvent** — implements `IDomainEvent`:
       ```
       public record PurchaseFailedEvent(
           string ErrorType,
           string ErrorMessage,
           int RetryCount,
           DateTimeOffset FailedAt
       ) : IDomainEvent;
       ```

    3. **PurchaseSkippedEvent** — implements `IDomainEvent`:
       ```
       public record PurchaseSkippedEvent(
           string Reason,
           decimal? CurrentBalance,
           decimal? RequiredAmount,
           DateTimeOffset SkippedAt
       ) : IDomainEvent;
       ```
       Reason examples: "Insufficient balance", "Already purchased today", "Missed execution window", "Amount below minimum order value ($10)"

    4. **TelegramOptions** — in `Configuration/` namespace `TradingBot.ApiService.Configuration`:
       ```
       public class TelegramOptions
       {
           public string BotToken { get; set; } = string.Empty;
           public string ChatId { get; set; } = string.Empty;
       }
       ```

    5. **Update appsettings.json** — add Telegram section:
       ```json
       "Telegram": {
           "BotToken": "",
           "ChatId": ""
       }
       ```

    Use file-scoped namespaces. Use `using TradingBot.ApiService.BuildingBlocks;` for IDomainEvent.
  </action>
  <verify>
    Run `dotnet build TradingBot.ApiService` — should compile with zero errors. All event records implement IDomainEvent which implements INotification.
  </verify>
  <done>
    Three domain event records exist with all required fields. TelegramOptions config class exists. appsettings.json has Telegram section.
  </done>
</task>

<task type="auto">
  <name>Task 2: Telegram notification service and MediatR handlers</name>
  <files>
    TradingBot.ApiService/Infrastructure/Telegram/TelegramNotificationService.cs
    TradingBot.ApiService/Infrastructure/Telegram/ServiceCollectionExtensions.cs
    TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
    TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
    TradingBot.ApiService/Application/Handlers/PurchaseSkippedHandler.cs
  </files>
  <action>
    1. **TelegramNotificationService** in `Infrastructure/Telegram/` namespace `TradingBot.ApiService.Infrastructure.Telegram`:
       - Inject `ITelegramBotClient` and `IOptions<TelegramOptions>` and `ILogger<TelegramNotificationService>`
       - Single method: `Task SendMessageAsync(string message, CancellationToken ct = default)`
       - Uses `ParseMode.Markdown` (v1, NOT MarkdownV2 — simpler escaping per research)
       - Wraps in try-catch: log error but never throw (notification failure must not crash purchase flow)
       - Uses `telegramBotClient.SendMessage(chatId: options.Value.ChatId, text: message, parseMode: ParseMode.Markdown, cancellationToken: ct)` (Telegram.Bot 22.x uses `SendMessage` not `SendTextMessageAsync`)

    2. **ServiceCollectionExtensions** in `Infrastructure/Telegram/` — `AddTelegram(IServiceCollection, IConfiguration)`:
       - Bind `TelegramOptions` from configuration section "Telegram" with `IOptionsMonitor`
       - Register `TelegramBotClient` as singleton: `new TelegramBotClient(telegramOptions.BotToken)`
       - Register `ITelegramBotClient` interface pointing to the singleton
       - Register `TelegramNotificationService` as singleton
       - Register MediatR from the assembly: `services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(PurchaseCompletedHandler).Assembly))` — NOTE: Check if MediatR is already registered in Program.cs. If not, add it here. If already registered, skip this line.

    3. **PurchaseCompletedHandler** in `Application/Handlers/` namespace `TradingBot.ApiService.Application.Handlers`:
       - Implements `INotificationHandler<PurchaseCompletedEvent>`
       - Inject `TelegramNotificationService` and `ILogger<PurchaseCompletedHandler>`
       - Format success message using Telegram Markdown v1 (bold labels, monospace numbers):
         ```
         *BTC Purchase Successful*

         *BTC Bought:* `{BtcAmount:F8}` BTC
         *Price:* `${Price:F2}`
         *USD Spent:* `${UsdSpent:F2}`
         *BTC Balance:* `{CurrentBtcBalance:F8}` BTC
         *USDC Remaining:* `${RemainingUsdc:F2}`

         _{ExecutedAt:yyyy-MM-dd HH:mm:ss} UTC_
         ```
       - Use primary constructor pattern
       - Use raw string literal (""") for message template

    4. **PurchaseFailedHandler** in `Application/Handlers/`:
       - Implements `INotificationHandler<PurchaseFailedEvent>`
       - Format failure message:
         ```
         *BTC Purchase Failed*

         *Error:* {ErrorType}
         *Message:* `{ErrorMessage}`
         *Retries:* {RetryCount}/3

         _{FailedAt:yyyy-MM-dd HH:mm:ss} UTC_
         ```

    5. **PurchaseSkippedHandler** in `Application/Handlers/`:
       - Implements `INotificationHandler<PurchaseSkippedEvent>`
       - Format skip message:
         ```
         *BTC Purchase Skipped*

         *Reason:* {Reason}
         {if CurrentBalance has value: *Balance:* `${CurrentBalance:F2}` USDC}
         {if RequiredAmount has value: *Required:* `${RequiredAmount:F2}` USDC}

         _{SkippedAt:yyyy-MM-dd HH:mm:ss} UTC_
         ```
       - Conditionally include balance/required lines only when values are non-null

    All handlers use file-scoped namespaces and primary constructors. All handlers log at Information level before sending and at Error level if notification fails (but do NOT rethrow).
  </action>
  <verify>
    Run `dotnet build TradingBot.ApiService` — should compile with zero errors. Verify all three handlers implement INotificationHandler for their respective event types. Verify TelegramNotificationService has try-catch around SendMessage.
  </verify>
  <done>
    TelegramNotificationService exists with error-safe SendMessageAsync. Three MediatR notification handlers exist, each formatting messages for their event type. ServiceCollectionExtensions registers all Telegram dependencies. Telegram.Bot 22.x API used correctly (SendMessage method).
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.ApiService` compiles with zero errors
2. All three event records in Application/Events/ implement IDomainEvent
3. All three handlers in Application/Handlers/ implement INotificationHandler for their event
4. TelegramNotificationService wraps SendMessage in try-catch (grep for "catch" in the file)
5. TelegramOptions config class exists with BotToken and ChatId properties
6. appsettings.json contains "Telegram" section
7. ServiceCollectionExtensions.AddTelegram registers ITelegramBotClient, TelegramNotificationService, and MediatR
</verification>

<success_criteria>
- Build succeeds with zero errors
- Domain events are proper MediatR INotification implementations (via IDomainEvent)
- Telegram messages use Markdown v1 parse mode (not MarkdownV2)
- Notification handlers never throw exceptions (try-catch with logging)
- All files follow codebase conventions: file-scoped namespaces, primary constructors, PascalCase, Async suffix
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-dca-engine/02-01-SUMMARY.md`
</output>
