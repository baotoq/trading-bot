---
phase: 15-rich-aggregate-roots
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/BuildingBlocks/AggregateRoot.cs
  - TradingBot.ApiService/Models/Purchase.cs
  - TradingBot.ApiService/Application/Events/PurchaseCreatedEvent.cs
  - TradingBot.ApiService/Application/Services/DcaExecutionService.cs
autonomous: true
requirements: [DM-01, DM-02, DM-04]

must_haves:
  truths:
    - "AggregateRoot<TId> base class exists with AddDomainEvent() and ClearDomainEvents()"
    - "Purchase cannot be created via public constructor -- only Purchase.Create() factory method"
    - "Purchase properties have private setters -- no external property assignment"
    - "DcaExecutionService uses Purchase.Create() and behavior methods instead of object initializer"
    - "All 53 existing tests pass without regression"
  artifacts:
    - path: "TradingBot.ApiService/BuildingBlocks/AggregateRoot.cs"
      provides: "AggregateRoot<TId> base class with domain event collection"
      contains: "AddDomainEvent"
    - path: "TradingBot.ApiService/Models/Purchase.cs"
      provides: "Purchase aggregate root with factory method and behavior methods"
      contains: "static Purchase Create"
    - path: "TradingBot.ApiService/Application/Events/PurchaseCreatedEvent.cs"
      provides: "Domain event for purchase creation"
      contains: "PurchaseCreatedEvent"
  key_links:
    - from: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      to: "TradingBot.ApiService/Models/Purchase.cs"
      via: "Purchase.Create() factory method"
      pattern: "Purchase\\.Create\\("
    - from: "TradingBot.ApiService/Models/Purchase.cs"
      to: "TradingBot.ApiService/BuildingBlocks/AggregateRoot.cs"
      via: "Inherits AggregateRoot<PurchaseId>"
      pattern: "AggregateRoot<PurchaseId>"
---

<objective>
Introduce AggregateRoot<TId> base class and refactor Purchase into a rich aggregate root with private constructor, static factory method, and behavior methods for post-creation state changes.

Purpose: Establish the DDD aggregate root pattern and apply it to Purchase -- the most critical domain entity. After this plan, no external code can construct or mutate Purchase through property assignment.

Output: AggregateRoot base class in BuildingBlocks, Purchase aggregate with Create() factory and RecordFill/RecordFailure/RecordDryRunFill behavior methods, DcaExecutionService updated to use the new API.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-rich-aggregate-roots/15-RESEARCH.md
@.planning/phases/15-rich-aggregate-roots/15-CONTEXT.md
@TradingBot.ApiService/BuildingBlocks/BaseEntity.cs
@TradingBot.ApiService/BuildingBlocks/AuditedEntity.cs
@TradingBot.ApiService/BuildingBlocks/IDomainEvent.cs
@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/Application/Services/DcaExecutionService.cs
@TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
@TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs
@TradingBot.ApiService/Application/Events/PurchaseSkippedEvent.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AggregateRoot base class and refactor Purchase to rich aggregate</name>
  <files>
    TradingBot.ApiService/BuildingBlocks/AggregateRoot.cs
    TradingBot.ApiService/Models/Purchase.cs
    TradingBot.ApiService/Application/Events/PurchaseCreatedEvent.cs
  </files>
  <action>
**1. Create `AggregateRoot.cs` in BuildingBlocks (new file):**

```csharp
namespace TradingBot.ApiService.BuildingBlocks;

public abstract class AggregateRoot<TId> : BaseEntity<TId>
{
    private readonly List<IDomainEvent> _domainEvents = [];

    public IReadOnlyList<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    protected void AddDomainEvent(IDomainEvent domainEvent) =>
        _domainEvents.Add(domainEvent);

    public void ClearDomainEvents() => _domainEvents.Clear();
}
```

Key: `AddDomainEvent` is `protected` (only the aggregate calls it). `ClearDomainEvents` is `public` (infrastructure calls it after dispatch). `_domainEvents` is NOT mapped by EF Core (no EF config needed -- it's just an in-memory list).

**2. Create `PurchaseCreatedEvent.cs` in Application/Events (new file):**

```csharp
public record PurchaseCreatedEvent(PurchaseId PurchaseId) : IDomainEvent;
```

Events carry identity only per locked decision.

**3. Refactor `Purchase.cs` to be a rich aggregate root:**

- Change inheritance: `Purchase : AggregateRoot<PurchaseId>` (was `BaseEntity<PurchaseId>`)
- Add `protected Purchase() { }` parameterless constructor for EF Core materialization
- Change ALL property setters from `{ get; set; }` to `{ get; private set; }` (DM-04)
- Add a private constructor that takes all required parameters
- Add `static Purchase Create(...)` factory method that:
  - Takes value objects directly: `Symbol symbol, Price price, UsdAmount cost, Multiplier multiplier, string? multiplierTier, Percentage dropPercentage, decimal high30Day, decimal ma200Day, bool isDryRun`
  - Creates PurchaseId.New() internally
  - Sets `Status = PurchaseStatus.Pending`, `ExecutedAt = DateTimeOffset.UtcNow`, `Quantity = Quantity.From(0)`
  - Calls `AddDomainEvent(new PurchaseCreatedEvent(purchase.Id))`
  - Returns the Purchase

- Add behavior methods for post-creation mutation:

  `RecordDryRunFill(Quantity quantity, Price price, UsdAmount actualCost)`:
  - Sets Quantity, Price, Cost, Status = Filled, OrderId = $"DRY-RUN-{Guid.NewGuid():N}", IsDryRun = true
  - Sets UpdatedAt = DateTimeOffset.UtcNow

  `RecordFill(Quantity quantity, Price avgPrice, UsdAmount actualCost, string orderId, decimal requestedQuantity)`:
  - Sets Quantity, Price, Cost, OrderId
  - Status = filledQty >= requestedQuantity * 0.95m ? Filled : PartiallyFilled
  - Sets UpdatedAt = DateTimeOffset.UtcNow

  `RecordResting(string orderId)`:
  - Sets OrderId, Status = PartiallyFilled, FailureReason = "Order resting instead of filling (IOC should not rest)"
  - Sets UpdatedAt = DateTimeOffset.UtcNow

  `RecordFailure(string reason, string? rawResponse = null)`:
  - Sets Status = Failed, FailureReason, RawResponse
  - Sets UpdatedAt = DateTimeOffset.UtcNow

  `SetRawResponse(string rawResponse)`:
  - Sets RawResponse (needed for the full order response after fill/resting)
  - Sets UpdatedAt = DateTimeOffset.UtcNow

IMPORTANT: The `PurchaseStatus` enum and `MultiplierTierData` record stay in the same file (no move needed). Keep `Symbol` as a property from the existing entity -- check if Purchase already has a Symbol column in the DB. Looking at current code, Purchase does NOT have a Symbol property. Do NOT add one now -- it would require a migration. The factory method should NOT take a Symbol parameter since it is not persisted on Purchase. Remove Symbol from the factory method signature.
  </action>
  <verify>
Run `dotnet build TradingBot.sln` from repository root. Expect compile errors ONLY in DcaExecutionService.cs (which still uses object initializer syntax). All other files should compile clean.
  </verify>
  <done>
AggregateRoot base class exists with domain event collection. Purchase inherits AggregateRoot, has private setters, protected parameterless constructor, factory method, and behavior methods. PurchaseCreatedEvent exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update DcaExecutionService to use Purchase factory and behavior methods</name>
  <files>
    TradingBot.ApiService/Application/Services/DcaExecutionService.cs
  </files>
  <action>
Refactor `DcaExecutionService.ExecuteDailyPurchaseAsync` to use the new Purchase API instead of object initializer + direct property assignment.

**Step 6 (create purchase record) becomes:**

Replace the `new Purchase { ... }` block with:
```csharp
var purchase = Purchase.Create(
    price: currentPrice,
    cost: UsdAmount.From(usdAmount.Value),
    multiplier: multiplierResult.Multiplier,
    multiplierTier: multiplierResult.Tier,
    dropPercentage: multiplierResult.DropPercentage,
    high30Day: multiplierResult.High30Day,
    ma200Day: multiplierResult.Ma200Day,
    isDryRun: options.DryRun);
```

**Dry-run path becomes:**
Replace the direct property assignments with:
```csharp
purchase.RecordDryRunFill(
    Quantity.From(roundedQuantity),
    currentPrice,
    UsdAmount.From(roundedQuantity * currentPriceDecimal));
```

**Live order fill path becomes:**
Replace direct property assignments with:
```csharp
purchase.RecordFill(
    Quantity.From(filledQty),
    Price.From(avgPrice),
    UsdAmount.From(filledQty * avgPrice),
    filled.Oid.ToString(),
    roundedQuantity);
```

**Resting path becomes:**
```csharp
purchase.RecordResting(status.Resting.Oid.ToString());
```

**No fill/resting path becomes:**
```csharp
purchase.RecordFailure("No fill or resting status in order response");
```

**Catch block becomes:**
```csharp
purchase.RecordFailure(ex.Message, ex.Message);
```

**After try/catch, set raw response separately for live orders:**
After the order response is received (inside the `else` block for non-dry-run), call:
```csharp
purchase.SetRawResponse(JsonSerializer.Serialize(orderResponse));
```

**Existing IPublisher.Publish() calls STAY as-is** per research recommendation Option A. The aggregate accumulates domain events via AddDomainEvent (PurchaseCreatedEvent), but the existing explicit IPublisher.Publish() calls for PurchaseCompletedEvent/PurchaseFailedEvent/PurchaseSkippedEvent remain as the bridge. Phase 17 will wire the interceptor to dispatch from aggregate events.

Keep the existing `IPublisher publisher` dependency and all `publisher.Publish(...)` calls unchanged.
  </action>
  <verify>
1. Run `dotnet build TradingBot.sln` -- must compile with zero errors
2. Run `dotnet test` from repository root -- all 53 tests must pass
  </verify>
  <done>
DcaExecutionService creates Purchase via Purchase.Create() factory method. All post-creation state changes go through behavior methods (RecordFill, RecordDryRunFill, RecordResting, RecordFailure, SetRawResponse). No direct property assignment on Purchase anywhere in the service. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` compiles with zero errors
2. `dotnet test` passes all 53 tests
3. `grep -r "new Purchase" TradingBot.ApiService/` returns zero matches (no direct construction)
4. `grep -r "purchase\.\w\+ =" TradingBot.ApiService/Application/Services/DcaExecutionService.cs` returns zero matches (no direct property assignment)
5. AggregateRoot.cs exists in BuildingBlocks with AddDomainEvent and ClearDomainEvents
6. Purchase.cs has `private set` on all properties
</verification>

<success_criteria>
- AggregateRoot<TId> base class exists with domain event collection (AddDomainEvent, ClearDomainEvents, DomainEvents)
- Purchase inherits AggregateRoot<PurchaseId> (not BaseEntity)
- Purchase has protected parameterless constructor and static Create() factory
- All Purchase properties use `{ get; private set; }`
- DcaExecutionService uses Purchase.Create() and behavior methods exclusively
- PurchaseCreatedEvent domain event is raised on creation
- All 53 existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-rich-aggregate-roots/15-01-SUMMARY.md`
</output>
