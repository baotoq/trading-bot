---
phase: 15-rich-aggregate-roots
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - TradingBot.ApiService/Models/DcaConfiguration.cs
  - TradingBot.ApiService/Application/Events/DcaConfigurationCreatedEvent.cs
  - TradingBot.ApiService/Application/Events/DcaConfigurationUpdatedEvent.cs
  - TradingBot.ApiService/Application/Services/ConfigurationService.cs
  - TradingBot.ApiService/Endpoints/DataEndpoints.cs
autonomous: true
requirements: [DM-03, DM-04]

must_haves:
  truths:
    - "DcaConfiguration cannot be created via public constructor -- only DcaConfiguration.Create() factory"
    - "DcaConfiguration properties have private setters -- no external property assignment"
    - "DcaConfiguration enforces tier ordering invariant (ascending drop percentages, multiplier 0-20)"
    - "DcaConfiguration enforces schedule invariant (hour 0-23, minute 0-59)"
    - "ConfigurationService uses aggregate behavior methods (UpdateDailyAmount, UpdateSchedule, etc.) instead of MapFromOptions"
    - "All 53 existing tests pass without regression"
  artifacts:
    - path: "TradingBot.ApiService/Models/DcaConfiguration.cs"
      provides: "DcaConfiguration aggregate root with factory method and behavior methods"
      contains: "static DcaConfiguration Create"
    - path: "TradingBot.ApiService/Application/Events/DcaConfigurationCreatedEvent.cs"
      provides: "Domain event for configuration creation"
      contains: "DcaConfigurationCreatedEvent"
    - path: "TradingBot.ApiService/Application/Events/DcaConfigurationUpdatedEvent.cs"
      provides: "Domain event for configuration updates"
      contains: "DcaConfigurationUpdatedEvent"
  key_links:
    - from: "TradingBot.ApiService/Application/Services/ConfigurationService.cs"
      to: "TradingBot.ApiService/Models/DcaConfiguration.cs"
      via: "Aggregate behavior methods"
      pattern: "config\\.Update(DailyAmount|Schedule|Tiers|BearMarket|Settings)"
    - from: "TradingBot.ApiService/Models/DcaConfiguration.cs"
      to: "TradingBot.ApiService/BuildingBlocks/AggregateRoot.cs"
      via: "Inherits AggregateRoot<DcaConfigurationId>"
      pattern: "AggregateRoot<DcaConfigurationId>"
---

<objective>
Refactor DcaConfiguration into a rich aggregate root with fine-grained behavior methods and invariant enforcement, then update ConfigurationService and DataEndpoints to use the new aggregate API.

Purpose: DcaConfiguration owns its state changes -- tier ordering, schedule validity, and amount positivity are enforced by the aggregate itself, not by external validation alone.

Output: DcaConfiguration aggregate with Create() factory and UpdateDailyAmount/UpdateSchedule/UpdateTiers/UpdateBearMarket/UpdateSettings behavior methods. ConfigurationService calls behavior methods instead of direct property mapping. Domain events raised on creation and mutation.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-rich-aggregate-roots/15-RESEARCH.md
@.planning/phases/15-rich-aggregate-roots/15-CONTEXT.md
@.planning/phases/15-rich-aggregate-roots/15-01-SUMMARY.md
@TradingBot.ApiService/Models/DcaConfiguration.cs
@TradingBot.ApiService/Application/Services/ConfigurationService.cs
@TradingBot.ApiService/Endpoints/ConfigurationEndpoints.cs
@TradingBot.ApiService/Endpoints/DataEndpoints.cs
@TradingBot.ApiService/Configuration/DcaOptions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor DcaConfiguration to rich aggregate root with behavior methods</name>
  <files>
    TradingBot.ApiService/Models/DcaConfiguration.cs
    TradingBot.ApiService/Application/Events/DcaConfigurationCreatedEvent.cs
    TradingBot.ApiService/Application/Events/DcaConfigurationUpdatedEvent.cs
  </files>
  <action>
**1. Create domain event files (new files):**

`DcaConfigurationCreatedEvent.cs`:
```csharp
public record DcaConfigurationCreatedEvent(DcaConfigurationId ConfigId) : IDomainEvent;
```

`DcaConfigurationUpdatedEvent.cs`:
```csharp
public record DcaConfigurationUpdatedEvent(DcaConfigurationId ConfigId) : IDomainEvent;
```

**2. Refactor `DcaConfiguration.cs`:**

- Change inheritance: `DcaConfiguration : AggregateRoot<DcaConfigurationId>` (was `BaseEntity<DcaConfigurationId>`)
- Add `protected DcaConfiguration() { }` parameterless constructor for EF Core
- Change ALL property setters to `{ get; private set; }`
- `MultiplierTiers` stays as `List<MultiplierTierData>` with `{ get; private set; } = []` (JSON column, no migration)
- `MultiplierTierData` record stays unchanged in the same file

Add `static DcaConfiguration Create(...)` factory method:
- Parameters: `DcaConfigurationId id, UsdAmount baseDailyAmount, int dailyBuyHour, int dailyBuyMinute, int highLookbackDays, bool dryRun, int bearMarketMaPeriod, Multiplier bearBoostFactor, Multiplier maxMultiplierCap, List<MultiplierTierData> multiplierTiers`
- Calls `ValidateSchedule(dailyBuyHour, dailyBuyMinute)` and `ValidateTiers(multiplierTiers)` before constructing
- Sets all properties
- Calls `AddDomainEvent(new DcaConfigurationCreatedEvent(id))`
- Returns the new DcaConfiguration

Add fine-grained behavior methods (per locked decision):

`UpdateDailyAmount(UsdAmount amount)`:
- Sets BaseDailyAmount = amount (Vogen ensures > 0)
- Sets UpdatedAt = DateTimeOffset.UtcNow
- Calls AddDomainEvent(new DcaConfigurationUpdatedEvent(Id))

`UpdateSchedule(int hour, int minute)`:
- Calls ValidateSchedule(hour, minute)
- Sets DailyBuyHour, DailyBuyMinute
- Sets UpdatedAt = DateTimeOffset.UtcNow
- Calls AddDomainEvent(new DcaConfigurationUpdatedEvent(Id))

`UpdateTiers(List<MultiplierTierData> tiers)`:
- Calls ValidateTiers(tiers)
- Sets MultiplierTiers = tiers
- Sets UpdatedAt = DateTimeOffset.UtcNow
- Calls AddDomainEvent(new DcaConfigurationUpdatedEvent(Id))

`UpdateBearMarket(int maPeriod, Multiplier boostFactor)`:
- Validates maPeriod > 0 (throw ArgumentException if not)
- Sets BearMarketMaPeriod, BearBoostFactor
- Sets UpdatedAt = DateTimeOffset.UtcNow
- Calls AddDomainEvent(new DcaConfigurationUpdatedEvent(Id))

`UpdateSettings(int highLookbackDays, bool dryRun, Multiplier maxMultiplierCap)`:
- Validates highLookbackDays > 0 (throw ArgumentException if not)
- Sets HighLookbackDays, DryRun, MaxMultiplierCap
- Sets UpdatedAt = DateTimeOffset.UtcNow
- Calls AddDomainEvent(new DcaConfigurationUpdatedEvent(Id))

Add private static validation methods:

`ValidateSchedule(int hour, int minute)`:
- if (hour < 0 || hour > 23) throw new ArgumentException("Hour must be between 0 and 23", nameof(hour))
- if (minute < 0 || minute > 59) throw new ArgumentException("Minute must be between 0 and 59", nameof(minute))

`ValidateTiers(List<MultiplierTierData> tiers)`:
- If tiers is empty or null, return (empty tiers are valid -- means base-only)
- Check ascending order: `tiers.OrderBy(t => t.DropPercentage).SequenceEqual(tiers)` -- throw if not
- Check sane multiplier range: `tiers.Any(t => t.Multiplier <= 0 || t.Multiplier > 20)` -- throw if any out of range
- Check no duplicate drop percentages: `tiers.Select(t => t.DropPercentage).Distinct().Count() != tiers.Count` -- throw if duplicates
  </action>
  <verify>
Run `dotnet build TradingBot.sln`. Expect compile errors ONLY in ConfigurationService.cs and DataEndpoints.cs (which still use direct property assignment). All other files should compile clean.
  </verify>
  <done>
DcaConfiguration inherits AggregateRoot, has private setters, protected parameterless constructor, factory method, fine-grained behavior methods, and invariant validation. Domain events created for configuration lifecycle.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ConfigurationService and DataEndpoints to use aggregate methods</name>
  <files>
    TradingBot.ApiService/Application/Services/ConfigurationService.cs
    TradingBot.ApiService/Endpoints/DataEndpoints.cs
  </files>
  <action>
**1. Refactor `ConfigurationService.UpdateAsync`:**

Replace the current upsert pattern (which uses `new DcaConfiguration { ... }` for create and `MapFromOptions()` for update) with aggregate-method calls.

**Create path** (entity == null):
```csharp
entity = DcaConfiguration.Create(
    DcaConfigurationId.Singleton,
    options.BaseDailyAmount,
    options.DailyBuyHour,
    options.DailyBuyMinute,
    options.HighLookbackDays,
    options.DryRun,
    options.BearMarketMaPeriod,
    options.BearBoostFactor,
    options.MaxMultiplierCap,
    options.MultiplierTiers
        .Select(t => new MultiplierTierData(t.DropPercentage.Value, t.Multiplier.Value))
        .ToList());
db.DcaConfigurations.Add(entity);
```

**Update path** (entity exists):
Call the fine-grained behavior methods instead of MapFromOptions:
```csharp
entity.UpdateDailyAmount(options.BaseDailyAmount);
entity.UpdateSchedule(options.DailyBuyHour, options.DailyBuyMinute);
entity.UpdateTiers(options.MultiplierTiers
    .Select(t => new MultiplierTierData(t.DropPercentage.Value, t.Multiplier.Value))
    .ToList());
entity.UpdateBearMarket(options.BearMarketMaPeriod, options.BearBoostFactor);
entity.UpdateSettings(options.HighLookbackDays, options.DryRun, options.MaxMultiplierCap);
```

Remove the `entity.UpdatedAt = DateTimeOffset.UtcNow;` line after MapFromOptions -- the behavior methods now set UpdatedAt themselves.

Remove the `MapFromOptions` private method entirely (no longer used).

Keep `MapToOptions` as-is (it reads properties, which is fine with private setters -- the service can still read public getters).

Keep the `DcaOptionsValidator` validation call at the start of UpdateAsync -- this is defense-in-depth at the application boundary, not redundancy with the aggregate's invariant checks.

**2. Refactor `DataEndpoints.IngestAsync`:**

The current code creates an IngestionJob via object initializer. IngestionJob is a DATA CARRIER (not an aggregate per discretion decision), so it keeps public setters. No changes needed to DataEndpoints.cs for IngestionJob.

However, verify that DataEndpoints does NOT directly construct DcaConfiguration -- it doesn't, so no changes needed for DataEndpoints.cs after all. Remove this file from the plan action but keep it in files_modified list for safety scan.

Actually, looking at the code again, DataEndpoints creates IngestionJob via `new Models.IngestionJob { ... }` which is fine since IngestionJob keeps public setters. No change needed.

The only change needed is in ConfigurationService.cs.
  </action>
  <verify>
1. Run `dotnet build TradingBot.sln` -- must compile with zero errors
2. Run `dotnet test` from repository root -- all 53 tests must pass
3. Verify no direct property assignment on DcaConfiguration in ConfigurationService: `grep -c "entity\.\w\+ =" TradingBot.ApiService/Application/Services/ConfigurationService.cs` should be 0
4. Verify no `new DcaConfiguration {` object initializer: `grep -c "new DcaConfiguration {" TradingBot.ApiService/` should be 0
  </verify>
  <done>
ConfigurationService creates DcaConfiguration via factory method and mutates via behavior methods. No direct property assignment. MapFromOptions removed. IngestionJob and DailyPrice unchanged (data carriers with public setters per locked decision). All 53 tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` compiles with zero errors
2. `dotnet test` passes all 53 tests
3. `grep -r "new DcaConfiguration" TradingBot.ApiService/` shows only `DcaConfiguration.Create()` usage (no object initializer)
4. DcaConfiguration.cs has `private set` on all properties
5. ConfigurationService.cs uses behavior methods (UpdateDailyAmount, UpdateSchedule, UpdateTiers, etc.)
6. DcaConfigurationCreatedEvent and DcaConfigurationUpdatedEvent exist in Application/Events
7. DailyPrice and IngestionJob are UNCHANGED (data carriers, not aggregates)
</verification>

<success_criteria>
- DcaConfiguration inherits AggregateRoot<DcaConfigurationId> (not BaseEntity)
- DcaConfiguration has protected parameterless constructor and static Create() factory
- All DcaConfiguration properties use `{ get; private set; }`
- Fine-grained behavior methods exist: UpdateDailyAmount, UpdateSchedule, UpdateTiers, UpdateBearMarket, UpdateSettings
- Tier ordering invariant enforced in UpdateTiers (ascending, no duplicates, multiplier 0-20)
- Schedule invariant enforced in UpdateSchedule (hour 0-23, minute 0-59)
- ConfigurationService uses factory method and behavior methods exclusively
- Domain events raised on creation and each mutation
- All 53 existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-rich-aggregate-roots/15-02-SUMMARY.md`
</output>
