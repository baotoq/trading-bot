---
phase: 25.1-cross-cutting-notification-handler-split
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
  - TradingBot.ApiService/Models/Purchase.cs
  - TradingBot.ApiService/Application/Services/DcaExecutionService.cs
  - TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
  - TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
autonomous: true
requirements: []
must_haves:
  truths:
    - "PurchaseCompletedEvent carries running totals (TotalBtc, TotalCost, PurchaseCount) so notification handlers do not query the database for aggregate stats"
    - "Telegram and FCM notification channels are independent handlers — a Telegram failure never blocks FCM delivery and vice versa"
    - "PurchaseCompletedHandler.cs contains exactly two INotificationHandler<PurchaseCompletedEvent> classes: TelegramPurchaseCompletedEventHandler and FcmPurchaseCompletedEventHandler"
    - "PurchaseFailedHandler.cs contains exactly two INotificationHandler<PurchaseFailedEvent> classes: TelegramPurchaseFailedEventHandler and FcmPurchaseFailedEventHandler"
    - "The original monolithic PurchaseCompletedHandler and PurchaseFailedHandler classes no longer exist"
    - "All 62 existing tests still pass and the solution builds cleanly"
  artifacts:
    - path: "TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs"
      provides: "PurchaseCompletedEvent record with TotalBtc, TotalCost, PurchaseCount fields"
      contains: "TotalBtc"
    - path: "TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs"
      provides: "TelegramPurchaseCompletedEventHandler and FcmPurchaseCompletedEventHandler"
      contains: "TelegramPurchaseCompletedEventHandler"
    - path: "TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs"
      provides: "TelegramPurchaseFailedEventHandler and FcmPurchaseFailedEventHandler"
      contains: "TelegramPurchaseFailedEventHandler"
  key_links:
    - from: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      to: "Purchase.RecordFill / Purchase.RecordDryRunFill"
      via: "Running totals query executed in DcaExecutionService, passed to aggregate behavior methods which embed them in PurchaseCompletedEvent"
      pattern: "purchase\\.Record(Fill|DryRunFill).*totalBtc"
    - from: "TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs"
      to: "TelegramNotificationService"
      via: "TelegramPurchaseCompletedEventHandler sends verbose Telegram message with running totals from event"
      pattern: "telegramService\\.SendMessageAsync"
    - from: "TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs"
      to: "FcmNotificationService"
      via: "FcmPurchaseCompletedEventHandler sends short push notification"
      pattern: "fcmService\\.SendToAllDevicesAsync"
---

<objective>
Split monolithic PurchaseCompletedHandler and PurchaseFailedHandler into separate INotificationHandler<T> implementations per notification channel (Telegram and FCM), and enrich PurchaseCompletedEvent with running totals so handlers no longer need database access for aggregate stats.

Purpose: Achieve proper separation of concerns — each notification channel is independently deployable, independently failable, and independently testable. This is the cross-cutting concern refactor identified after Phase 24 introduced FCM alongside Telegram in the same handler.

Output: Two handler files, each containing two focused handler classes (one per channel), plus an enriched PurchaseCompletedEvent with running totals pre-computed by the DCA service.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25.1-cross-cutting-concern-with-multiple-inotificationhandler-purchasecompletedevent-handlers-1-handle-telegram-1-handle-firebase/25.1-CONTEXT.md

@TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
@TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs
@TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
@TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/Application/Services/DcaExecutionService.cs
@TradingBot.ApiService/Infrastructure/Firebase/FcmNotificationService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enrich PurchaseCompletedEvent with running totals and wire computation in DCA service</name>
  <files>
    TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
    TradingBot.ApiService/Models/Purchase.cs
    TradingBot.ApiService/Application/Services/DcaExecutionService.cs
  </files>
  <action>
    **PurchaseCompletedEvent.cs:**
    Add three new fields to the record: `decimal TotalBtc`, `decimal TotalCost`, `int PurchaseCount`. These are running totals (including the current purchase) so handlers can format messages without DB queries. Keep all existing fields (PurchaseId, Price, Quantity, Cost, OccurredAt). The record stays a plain `record` with positional parameters.

    **Purchase.cs:**
    Update `RecordFill` and `RecordDryRunFill` to accept running total parameters: `decimal totalBtc, decimal totalCost, int purchaseCount`. Pass these through to the `PurchaseCompletedEvent` constructor. The aggregate does NOT compute these — it just passes them through from the caller.

    **DcaExecutionService.cs:**
    After each `RecordFill` or `RecordDryRunFill` call, the purchase is added to EF's change tracker but NOT yet saved. Before SaveChangesAsync, compute running totals by querying the database for all non-dry-run filled/partially-filled purchases (same query currently in PurchaseCompletedHandler) and ADD the current purchase's values to account for the fact it's not yet committed. Pass these totals to the aggregate method.

    Specifically, in the DCA service:
    1. Before calling `purchase.RecordFill(...)` or `purchase.RecordDryRunFill(...)`, query running totals from DB (same WHERE as current handler: `Status == Filled || PartiallyFilled` and `!IsDryRun`).
    2. Add the current purchase's quantity/cost to the DB totals (since the current purchase isn't saved yet).
    3. Pass totalBtc, totalCost, purchaseCount to RecordFill/RecordDryRunFill as additional parameters.

    Note: For dry-run purchases, the running totals should still reflect only real (non-dry-run) purchases from DB, since dry-run purchases are excluded from totals by convention (existing behavior).
  </action>
  <verify>
    Run `dotnet build TradingBot.slnx` — must compile cleanly. Run `dotnet test` — all 62 tests must pass. Check that PurchaseCompletedEvent now has TotalBtc, TotalCost, PurchaseCount fields.
  </verify>
  <done>
    PurchaseCompletedEvent carries pre-computed running totals. Purchase aggregate's RecordFill/RecordDryRunFill accept and forward totals. DcaExecutionService computes totals before raising the event.
  </done>
</task>

<task type="auto">
  <name>Task 2: Split PurchaseCompletedHandler into TelegramPurchaseCompletedEventHandler and FcmPurchaseCompletedEventHandler</name>
  <files>
    TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
  </files>
  <action>
    Delete the existing `PurchaseCompletedHandler` class entirely. In the same file, create two new classes:

    **TelegramPurchaseCompletedEventHandler:**
    - Implements `INotificationHandler<PurchaseCompletedEvent>`
    - Dependencies: `TelegramNotificationService`, `TradingBotDbContext` (to load the full Purchase for BuildMultiplierReasoning), `HyperliquidClient` (for USDC balance — per locked decision, USDC balance stays in Telegram handler only), `ILogger<TelegramPurchaseCompletedEventHandler>`
    - Loads the Purchase entity from DB (same as current handler)
    - Reads running totals from the event notification (notification.TotalBtc, notification.TotalCost) instead of querying the DB for them
    - Computes avgCost from event totals: `notification.TotalCost / notification.TotalBtc`
    - Fetches remaining USDC balance from HyperliquidClient (same as current)
    - Builds the same verbose Telegram message with multiplier reasoning (keep BuildMultiplierReasoning as a private method on this handler)
    - Internal try-catch: logs error but never throws (preserves current graceful degradation)

    **FcmPurchaseCompletedEventHandler:**
    - Implements `INotificationHandler<PurchaseCompletedEvent>`
    - Dependencies: `FcmNotificationService`, `ILogger<FcmPurchaseCompletedEventHandler>`
    - NO database access, NO HyperliquidClient — uses only event fields (Price, Quantity, Cost from the event itself)
    - Builds short push notification: title = "BTC Purchased" (or "[SIM] BTC Purchased" based on cost/quantity heuristic — since event doesn't carry IsDryRun, load purchase from DB OR infer from event data), body = "{Quantity:F5} BTC at ${Price:N2} ({multiplier}x)" — but the event does not carry Multiplier directly. Since the event carries PurchaseId and this handler should be lightweight, use only event fields Price/Quantity/Cost to format. If multiplier info is needed, either load from DB or accept the simpler format without multiplier.

    IMPORTANT CORRECTION: Looking at the current FCM code, it uses `purchase.Quantity.Value`, `purchase.Price.Value`, `purchase.Multiplier.Value`, and `purchase.IsDryRun`. The event currently carries Price, Quantity, Cost but NOT Multiplier or IsDryRun. Two options:

    Option A (preferred per CONTEXT.md "Each handler builds its own message"): Add `decimal Multiplier` and `bool IsDryRun` fields to PurchaseCompletedEvent so FCM handler can format without DB access. This is the simpler approach since these are already available when the event is raised in RecordFill.

    Option B: Have FcmPurchaseCompletedEventHandler load the Purchase from DB.

    Go with Option A — add Multiplier and IsDryRun to PurchaseCompletedEvent (update Task 1's event enrichment accordingly). Then FcmPurchaseCompletedEventHandler needs NO DB access at all.

    With Option A, FcmPurchaseCompletedEventHandler:
    - Title: `notification.IsDryRun ? "[SIM] BTC Purchased" : "BTC Purchased"`
    - Body: `$"{notification.Quantity:F5} BTC at ${notification.Price:N2} ({notification.Multiplier:F1}x)"`
    - Data: `{ "type": "purchase_completed", "route": "/history" }`
    - Internal try-catch: logs error but never throws

    Update the file-level using directives to import only what's needed (remove unused imports from the old monolithic handler).
  </action>
  <verify>
    Run `dotnet build TradingBot.slnx` — must compile. Verify the file contains exactly two public classes both implementing `INotificationHandler<PurchaseCompletedEvent>`. Verify the old `PurchaseCompletedHandler` class name no longer exists. Run `dotnet test` — all 62 tests pass.
  </verify>
  <done>
    PurchaseCompletedHandler.cs contains TelegramPurchaseCompletedEventHandler (verbose Telegram message with running totals + USDC balance + multiplier reasoning) and FcmPurchaseCompletedEventHandler (short push notification using event data only, no DB access). Both handle errors independently.
  </done>
</task>

<task type="auto">
  <name>Task 3: Split PurchaseFailedHandler into TelegramPurchaseFailedEventHandler and FcmPurchaseFailedEventHandler</name>
  <files>
    TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
  </files>
  <action>
    Delete the existing `PurchaseFailedHandler` class entirely. In the same file, create two new classes:

    **TelegramPurchaseFailedEventHandler:**
    - Implements `INotificationHandler<PurchaseFailedEvent>`
    - Dependencies: `TelegramNotificationService`, `TradingBotDbContext`, `ILogger<TelegramPurchaseFailedEventHandler>`
    - Loads the Purchase entity from DB (same as current handler, needed for FailureReason, UpdatedAt, ExecutedAt)
    - Builds the same verbose Telegram failure message (same format as current: error, details, retries, timestamp)
    - Internal try-catch: logs error but never throws

    **FcmPurchaseFailedEventHandler:**
    - Implements `INotificationHandler<PurchaseFailedEvent>`
    - Dependencies: `FcmNotificationService`, `ILogger<FcmPurchaseFailedEventHandler>`
    - Uses event fields directly: `notification.FailureReason` for the error message (PurchaseFailedEvent already carries FailureReason — no DB access needed)
    - Title: "Purchase Failed"
    - Body: `$"Error: {notification.FailureReason ?? "Unknown error"}"`
    - Data: `{ "type": "purchase_failed", "route": "/home" }`
    - Internal try-catch: logs error but never throws

    Update file-level using directives. Remove unused imports from old monolithic handler.
  </action>
  <verify>
    Run `dotnet build TradingBot.slnx` — must compile. Verify the file contains exactly two public classes both implementing `INotificationHandler<PurchaseFailedEvent>`. Verify the old `PurchaseFailedHandler` class name no longer exists. Run `dotnet test` — all 62 tests pass.
  </verify>
  <done>
    PurchaseFailedHandler.cs contains TelegramPurchaseFailedEventHandler (verbose Telegram message from DB) and FcmPurchaseFailedEventHandler (short push notification from event data only). Both handle errors independently. No shared state between channels.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.slnx` compiles with zero errors and zero warnings related to handler changes
2. `dotnet test` passes all 62 existing tests
3. `grep -r "class PurchaseCompletedHandler" TradingBot.ApiService/` returns NO results (old class deleted)
4. `grep -r "class PurchaseFailedHandler" TradingBot.ApiService/` returns NO results (old class deleted)
5. `grep -r "TelegramPurchaseCompletedEventHandler" TradingBot.ApiService/` finds exactly one class definition
6. `grep -r "FcmPurchaseCompletedEventHandler" TradingBot.ApiService/` finds exactly one class definition
7. `grep -r "TelegramPurchaseFailedEventHandler" TradingBot.ApiService/` finds exactly one class definition
8. `grep -r "FcmPurchaseFailedEventHandler" TradingBot.ApiService/` finds exactly one class definition
9. PurchaseCompletedEvent contains TotalBtc, TotalCost, PurchaseCount, Multiplier, IsDryRun fields
10. PurchaseSkippedHandler is unchanged (Telegram-only, out of scope per CONTEXT.md)
</verification>

<success_criteria>
- Two handler files, each containing exactly two INotificationHandler classes (one per channel)
- PurchaseCompletedEvent enriched with running totals + Multiplier + IsDryRun
- Running totals computed in DcaExecutionService before event is raised
- Each handler has independent error isolation (try-catch per handler)
- FCM handlers use event data only (no DB access for PurchaseCompleted, event fields for PurchaseFailed)
- Telegram handlers retain full DB access for verbose message formatting
- USDC balance lookup remains in Telegram PurchaseCompleted handler only
- BuildMultiplierReasoning stays as private method on TelegramPurchaseCompletedEventHandler
- All 62 tests pass, solution builds clean
</success_criteria>

<output>
After completion, create `.planning/phases/25.1-cross-cutting-concern-with-multiple-inotificationhandler-purchasecompletedevent-handlers-1-handle-telegram-1-handle-firebase/25.1-01-SUMMARY.md`
</output>
