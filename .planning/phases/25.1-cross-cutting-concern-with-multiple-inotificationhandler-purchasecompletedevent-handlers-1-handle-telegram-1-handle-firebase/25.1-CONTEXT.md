# Phase 25.1: Cross-Cutting Notification Handler Split - Context

**Gathered:** 2026-02-20
**Status:** Ready for planning

<domain>
## Phase Boundary

Split monolithic event handlers that do both Telegram and Firebase notifications into separate `INotificationHandler<T>` implementations per notification channel. This applies to PurchaseCompletedEvent and PurchaseFailedEvent handlers only. PurchaseSkippedHandler (Telegram-only) is out of scope.

</domain>

<decisions>
## Implementation Decisions

### Handler splitting scope
- Split PurchaseCompletedHandler into two separate INotificationHandler<PurchaseCompletedEvent> classes: TelegramPurchaseCompletedEventHandler and FcmPurchaseCompletedEventHandler
- Split PurchaseFailedHandler into two separate INotificationHandler<PurchaseFailedEvent> classes: TelegramPurchaseFailedEventHandler and FcmPurchaseFailedEventHandler
- PurchaseSkippedHandler stays as-is (Telegram-only, no split needed)
- Delete the original monolithic handler classes after splitting — no .bak or commented-out code

### Shared data strategy
- Enrich PurchaseCompletedEvent with running totals (total BTC, total cost, purchase count) so handlers don't need DB access for those
- Compute running totals before raising the event (in the DCA service/aggregate, not in the outbox processor)
- USDC balance stays in the Telegram handler only — it calls HyperliquidClient directly (Firebase doesn't use it)
- Each handler builds its own message text/reasoning — Telegram may want verbose, Firebase may want short
- PurchaseFailedEvent is fine as-is (FailureReason + OccurredAt is enough for both channels)

### Error isolation model
- Each handler catches its own errors internally — notification failures are logged and swallowed (current graceful degradation behavior preserved)
- A Telegram failure never blocks Firebase and vice versa
- Claude decides the specific isolation mechanism (internal try-catch vs MediatR pipeline behavior)

### File organization
- Both handler classes for the same event live in the same file
- File naming: PurchaseCompletedEventHandler.cs (contains TelegramPurchaseCompletedEventHandler + FcmPurchaseCompletedEventHandler)
- File naming: PurchaseFailedEventHandler.cs (contains TelegramPurchaseFailedEventHandler + FcmPurchaseFailedEventHandler)
- Files stay in Application/Handlers/ directory (flat, no subfolders)

### Claude's Discretion
- Error isolation mechanism (internal try-catch per handler vs MediatR behavior pipeline)
- Message formatting differences between Telegram and Firebase for each event
- Whether BuildMultiplierReasoning() becomes a shared utility or stays duplicated

</decisions>

<specifics>
## Specific Ideas

- Handler naming follows pattern: `{Channel}{Event}Handler` — e.g., TelegramPurchaseCompletedEventHandler
- MediatR natively supports multiple INotificationHandler<T> for the same event — no custom infrastructure needed
- Current PurchaseCompletedHandler has a BuildMultiplierReasoning() method that both channels may need in different forms

</specifics>

<deferred>
## Deferred Ideas

- Adding Firebase notifications to PurchaseSkippedEvent — separate phase if needed
- Retry tracking for PurchaseFailedEvent (currently hardcoded "Retries: 0/3") — separate concern

</deferred>

---

*Phase: 25.1-cross-cutting-notification-handler-split*
*Context gathered: 2026-02-20*
