---
phase: 04-enhanced-notifications-observability
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - TradingBot.ApiService/Application/BackgroundJobs/WeeklySummaryService.cs
  - TradingBot.ApiService/Application/BackgroundJobs/MissedPurchaseVerificationService.cs
  - TradingBot.ApiService/Program.cs
autonomous: true

must_haves:
  truths:
    - "Weekly summary sent Sunday evening with this week's buys, running totals, avg cost vs current price, unrealized P&L"
    - "Missed purchase alert sent via Telegram if no purchase recorded by 30 minutes after execution window"
    - "Health check reports DCA service status including last successful purchase timestamp"
    - "All new background services follow existing TimeBackgroundService pattern"
  artifacts:
    - path: "TradingBot.ApiService/Application/BackgroundJobs/WeeklySummaryService.cs"
      provides: "Weekly DCA summary report sent Sunday evening"
      contains: "WeeklySummaryService"
    - path: "TradingBot.ApiService/Application/BackgroundJobs/MissedPurchaseVerificationService.cs"
      provides: "Daily missed purchase check with Telegram alert"
      contains: "MissedPurchaseVerificationService"
    - path: "TradingBot.ApiService/Program.cs"
      provides: "DI registration for new services and DCA health check"
      contains: "WeeklySummaryService"
  key_links:
    - from: "WeeklySummaryService.cs"
      to: "TradingBotDbContext"
      via: "EF Core query for weekly purchase data"
      pattern: "dbContext\\.Purchases"
    - from: "MissedPurchaseVerificationService.cs"
      to: "TelegramNotificationService"
      via: "Telegram alert for missed purchases"
      pattern: "telegramService\\.SendMessageAsync"
    - from: "Program.cs"
      to: "WeeklySummaryService"
      via: "AddHostedService registration"
      pattern: "AddHostedService<WeeklySummaryService>"
---

<objective>
Add weekly summary reporting, missed purchase verification, and DCA health check integration.

Purpose: FR-11 (weekly summary), FR-12 (health check + missed purchase detection). The weekly summary gives a consolidated DCA performance view. Missed purchase verification catches silent failures. Health check gives operational confidence.

Output: Two new background services (WeeklySummaryService, MissedPurchaseVerificationService), DCA health check, and Program.cs DI wiring.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-enhanced-notifications-observability/04-CONTEXT.md
@.planning/phases/04-enhanced-notifications-observability/04-01-SUMMARY.md

@TradingBot.ApiService/Application/BackgroundJobs/DcaSchedulerBackgroundService.cs
@TradingBot.ApiService/Application/BackgroundJobs/PriceDataRefreshService.cs
@TradingBot.ApiService/BuildingBlocks/TimeBackgroundService.cs
@TradingBot.ApiService/Infrastructure/Telegram/TelegramNotificationService.cs
@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
@TradingBot.ApiService/Infrastructure/Hyperliquid/HyperliquidClient.cs
@TradingBot.ApiService/Application/Services/IPriceDataService.cs
@TradingBot.ApiService/Configuration/DcaOptions.cs
@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/Program.cs
@TradingBot.ServiceDefaults/Extensions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WeeklySummaryService and MissedPurchaseVerificationService</name>
  <files>
    TradingBot.ApiService/Application/BackgroundJobs/WeeklySummaryService.cs
    TradingBot.ApiService/Application/BackgroundJobs/MissedPurchaseVerificationService.cs
  </files>
  <action>
1. **WeeklySummaryService** — New background service extending TimeBackgroundService:
   - Constructor dependencies: `ILogger<WeeklySummaryService>`, `IServiceScopeFactory` (for scoped DbContext/Telegram/Hyperliquid resolution)
   - `Interval`: `TimeSpan.FromHours(1)` (check every hour, only act on Sunday evening)
   - `ProcessAsync` logic:
     a. Check if current UTC time is Sunday and within the 20:00-21:00 UTC window. If not, return early (no log spam).
     b. Use a simple "already sent this week" guard: query if any purchases exist this week — if this method already ran today (track via a `DateOnly _lastSummarySent` field), return.
     c. Create scope, resolve `TradingBotDbContext`, `TelegramNotificationService`, `HyperliquidClient`.
     d. Query this week's purchases (Monday 00:00 UTC to now):
        ```csharp
        var weekStart = GetMondayOfWeek(DateOnly.FromDateTime(DateTime.UtcNow));
        var purchases = await dbContext.Purchases
            .Where(p => p.ExecutedAt >= weekStart.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc))
            .Where(p => p.Status == PurchaseStatus.Filled || p.Status == PurchaseStatus.PartiallyFilled)
            .Where(p => !p.IsDryRun)
            .OrderBy(p => p.ExecutedAt)
            .ToListAsync(ct);
        ```
     e. Query lifetime running totals (same pattern as PurchaseCompletedHandler from Plan 02):
        ```csharp
        var lifetimeTotals = await dbContext.Purchases
            .Where(p => p.Status == PurchaseStatus.Filled || p.Status == PurchaseStatus.PartiallyFilled)
            .Where(p => !p.IsDryRun)
            .GroupBy(p => 1)
            .Select(g => new { TotalBtc = g.Sum(p => p.Quantity), TotalUsd = g.Sum(p => p.Cost), Count = g.Count() })
            .FirstOrDefaultAsync(ct);
        ```
     f. Fetch current BTC price from Hyperliquid for P&L calculation:
        ```csharp
        var currentPrice = await hyperliquidClient.GetSpotPriceAsync("BTC/USDC", ct);
        ```
     g. Calculate: avg cost basis, unrealized P&L %, best buy (lowest price), worst buy (highest price) this week.
     h. Build Telegram message:
        ```
        *Weekly DCA Summary*
        _Week of {weekStart:MMM dd} - {weekEnd:MMM dd, yyyy}_

        *This Week's Buys:*
        {For each purchase: date, BTC amount, price, multiplier}
        (or "No purchases this week" if empty)

        *Week Totals:*
        Buys: {count}
        BTC Bought: {sum qty}
        USD Spent: ${sum cost}
        Avg Price: ${avg}
        Best Buy: ${lowest price}
        Worst Buy: ${highest price}

        *Lifetime Totals:*
        Total BTC: {totalBtc}
        Total Spent: ${totalUsd}
        Avg Cost Basis: ${avgCost}
        Current Price: ${currentPrice}
        Unrealized P&L: {pnlPercent:F1}%

        _Generated {now:yyyy-MM-dd HH:mm} UTC_
        ```
     i. Send via TelegramNotificationService. Wrap in try/catch, log errors.
     j. Set `_lastSummarySent = DateOnly.FromDateTime(DateTime.UtcNow)`.
   - Helper: `DateOnly GetMondayOfWeek(DateOnly date)` — returns the Monday of the week containing the given date.

2. **MissedPurchaseVerificationService** — New background service extending TimeBackgroundService:
   - Constructor dependencies: `ILogger<MissedPurchaseVerificationService>`, `IServiceScopeFactory`, `IOptionsMonitor<DcaOptions>`
   - `Interval`: `TimeSpan.FromMinutes(30)` (check every 30 minutes)
   - `ProcessAsync` logic:
     a. Calculate the expected purchase time for today: `DailyBuyHour:DailyBuyMinute` from DcaOptions.
     b. Calculate verification time: target time + 10 min execution window + 30 min grace = target + 40 minutes.
     c. If current UTC time is before verification time, return early.
     d. If current UTC time is more than 2 hours past verification time, return early (avoid stale alerts).
     e. Create scope, resolve `TradingBotDbContext`, `TelegramNotificationService`.
     f. Check if a purchase exists today (any status Filled/PartiallyFilled, IsDryRun=false):
        ```csharp
        var todayStart = DateOnly.FromDateTime(DateTime.UtcNow).ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);
        var todayEnd = todayStart.AddDays(1);
        var todayPurchase = await dbContext.Purchases
            .Where(p => p.ExecutedAt >= todayStart && p.ExecutedAt < todayEnd)
            .Where(p => p.Status == PurchaseStatus.Filled || p.Status == PurchaseStatus.PartiallyFilled)
            .Where(p => !p.IsDryRun)
            .FirstOrDefaultAsync(ct);
        ```
     g. If `todayPurchase != null`: purchase found, log and return.
     h. If `todayPurchase == null`: **Missed purchase detected.** Check for failed/skipped records for diagnostics:
        ```csharp
        var failedToday = await dbContext.Purchases
            .Where(p => p.ExecutedAt >= todayStart && p.ExecutedAt < todayEnd)
            .Where(p => p.Status == PurchaseStatus.Failed)
            .OrderByDescending(p => p.ExecutedAt)
            .FirstOrDefaultAsync(ct);
        ```
     i. Build diagnostic reasoning:
        - If failedToday exists: "Order was attempted but failed: {failedToday.FailureReason}"
        - If no records at all: "No purchase attempt detected. Scheduler may not have triggered."
     j. Send Telegram alert:
        ```
        *Missed Purchase Alert*

        No successful BTC purchase recorded today.
        Expected by: {verificationTime:HH:mm} UTC

        *Diagnosis:* {diagnostic reason}

        Please check logs for more details.

        _{now:yyyy-MM-dd HH:mm:ss} UTC_
        ```
     k. Use a `DateOnly _lastAlertSent` field to prevent duplicate alerts for the same day.
  </action>
  <verify>
    - `dotnet build TradingBot.sln` compiles without errors
    - WeeklySummaryService: extends TimeBackgroundService, sends summary only on Sunday evening 20:00-21:00 UTC
    - WeeklySummaryService: running totals exclude dry-run purchases, includes unrealized P&L
    - MissedPurchaseVerificationService: extends TimeBackgroundService, checks ~40 min after execution window
    - MissedPurchaseVerificationService: includes diagnostic reasoning in alert
    - Both services use IServiceScopeFactory for scoped service resolution
    - Both services have de-duplication guards (_lastSummarySent, _lastAlertSent)
  </verify>
  <done>
    Weekly summary service sends comprehensive DCA report on Sunday evenings. Missed purchase verification service detects silent failures and sends diagnostic Telegram alerts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add DCA health check and register all new services in Program.cs</name>
  <files>
    TradingBot.ApiService/Program.cs
  </files>
  <action>
1. **Add DCA health check** inline in Program.cs (no separate class needed — use the lambda overload):
   After the existing `builder.AddServiceDefaults()` call, add a custom health check:
   ```csharp
   builder.Services.AddHealthChecks()
       .AddAsyncCheck("dca-service", async (ct) =>
       {
           using var scope = app.Services.CreateScope();
           var dbContext = scope.ServiceProvider.GetRequiredService<TradingBotDbContext>();

           // Check last successful purchase
           var lastPurchase = await dbContext.Purchases
               .Where(p => p.Status == PurchaseStatus.Filled || p.Status == PurchaseStatus.PartiallyFilled)
               .Where(p => !p.IsDryRun)
               .OrderByDescending(p => p.ExecutedAt)
               .FirstOrDefaultAsync(ct);

           var data = new Dictionary<string, object>();

           if (lastPurchase != null)
           {
               data["last_purchase"] = lastPurchase.ExecutedAt.ToString("o");
               data["last_purchase_status"] = lastPurchase.Status.ToString();
               data["last_purchase_btc"] = lastPurchase.Quantity;

               // Warn if no purchase in the last 36 hours (accounts for weekends/issues)
               var hoursSinceLastPurchase = (DateTimeOffset.UtcNow - lastPurchase.ExecutedAt).TotalHours;
               if (hoursSinceLastPurchase > 36)
               {
                   return HealthCheckResult.Degraded(
                       $"No purchase in {hoursSinceLastPurchase:F0} hours",
                       data: data);
               }
           }
           else
           {
               data["last_purchase"] = "never";
               return HealthCheckResult.Degraded("No purchases recorded yet", data: data);
           }

           return HealthCheckResult.Healthy("DCA service operating normally", data: data);
       });
   ```

   **Important:** Since the health check needs `app` (the built WebApplication), implement this differently. Use a typed health check class or register it after `app` is built. The cleanest approach is:

   Create the health check as a simple class registered in DI. Actually, the simplest approach: use `IServiceScopeFactory` in a registered health check. Add this health check using the `AddCheck<T>` pattern:

   Add a private class `DcaHealthCheck` at the bottom of Program.cs (or as a separate file if the executor prefers — use judgment):
   ```csharp
   // In Program.cs or a new file Application/Health/DcaHealthCheck.cs
   public class DcaHealthCheck(IServiceScopeFactory scopeFactory) : IHealthCheck
   {
       public async Task<HealthCheckResult> CheckHealthAsync(
           HealthCheckContext context, CancellationToken ct = default)
       {
           using var scope = scopeFactory.CreateScope();
           var dbContext = scope.ServiceProvider.GetRequiredService<TradingBotDbContext>();

           var lastPurchase = await dbContext.Purchases
               .Where(p => p.Status == PurchaseStatus.Filled || p.Status == PurchaseStatus.PartiallyFilled)
               .Where(p => !p.IsDryRun)
               .OrderByDescending(p => p.ExecutedAt)
               .FirstOrDefaultAsync(ct);

           var data = new Dictionary<string, object>();
           if (lastPurchase != null)
           {
               data["last_purchase"] = lastPurchase.ExecutedAt.ToString("o");
               data["last_purchase_status"] = lastPurchase.Status.ToString();
               data["last_purchase_btc"] = lastPurchase.Quantity.ToString("F5");

               var hoursSince = (DateTimeOffset.UtcNow - lastPurchase.ExecutedAt).TotalHours;
               if (hoursSince > 36)
                   return HealthCheckResult.Degraded(
                       $"No purchase in {hoursSince:F0} hours", data: data);
           }
           else
           {
               data["last_purchase"] = "never";
               return HealthCheckResult.Degraded("No purchases recorded yet", data: data);
           }

           return HealthCheckResult.Healthy("DCA service operating normally", data: data);
       }
   }
   ```

   Register it: `builder.Services.AddHealthChecks().AddCheck<DcaHealthCheck>("dca-service");`

2. **Register new hosted services** in Program.cs:
   After the existing `PriceDataRefreshService` registration, add:
   ```csharp
   // Weekly summary report (Sunday evening UTC)
   builder.Services.AddHostedService<WeeklySummaryService>();

   // Missed purchase verification (checks after execution window)
   builder.Services.AddHostedService<MissedPurchaseVerificationService>();
   ```

   Add the necessary `using` statements at the top of Program.cs.

3. **Add required using statements:**
   ```csharp
   using Microsoft.Extensions.Diagnostics.HealthChecks;
   ```
   (if not already imported via ServiceDefaults)
  </action>
  <verify>
    - `dotnet build TradingBot.sln` compiles without errors
    - `dotnet test` — all existing tests pass
    - Program.cs registers: WeeklySummaryService, MissedPurchaseVerificationService as hosted services
    - DCA health check registered and accessible at /health endpoint
    - Health check reports last purchase timestamp, returns Degraded if no purchase in 36+ hours
  </verify>
  <done>
    All new services registered in DI. DCA health check integrated into existing /health endpoint. Weekly summary and missed purchase verification background services wired up and ready to run.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` — clean compilation
2. `dotnet test` — all existing tests pass
3. WeeklySummaryService: only runs Sunday 20:00-21:00 UTC, sends comprehensive weekly report
4. MissedPurchaseVerificationService: checks ~40 min after target time, sends diagnostic alert
5. DCA health check: reports last purchase, returns Degraded after 36 hours gap
6. Both background services use IServiceScopeFactory (correct pattern for singleton -> scoped)
7. Both services exclude IsDryRun purchases from queries
8. Program.cs: all 3 new components registered
</verification>

<success_criteria>
- Weekly summary sent Sunday evening with: this week's buys, totals, avg cost, current price, unrealized P&L %
- Missed purchase detection runs after execution window, sends Telegram alert with diagnostic reasoning
- Health check at /health includes DCA service status with last purchase timestamp
- All new services follow existing codebase patterns (TimeBackgroundService, IServiceScopeFactory, error-safe)
- No duplicate alerts or summaries (de-duplication guards)
</success_criteria>

<output>
After completion, create `.planning/phases/04-enhanced-notifications-observability/04-03-SUMMARY.md`
</output>
