---
phase: 04-enhanced-notifications-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Models/Purchase.cs
  - TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
  - TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
  - TradingBot.ApiService/Application/Services/DcaExecutionService.cs
  - TradingBot.ApiService/Infrastructure/Data/Migrations/<new_migration>.cs
autonomous: true

must_haves:
  truths:
    - "Dry-run mode skips order placement but persists a simulated purchase with IsDryRun=true"
    - "Dry-run notifications include a clear SIMULATION banner"
    - "PurchaseCompletedEvent carries multiplier metadata (multiplier, tier, drop%, high30d, ma200d)"
    - "Real running totals queries exclude dry-run purchases"
  artifacts:
    - path: "TradingBot.ApiService/Models/Purchase.cs"
      provides: "IsDryRun boolean flag on Purchase entity"
      contains: "IsDryRun"
    - path: "TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs"
      provides: "Enhanced event with multiplier metadata and IsDryRun flag"
      contains: "Multiplier"
    - path: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      provides: "Dry-run conditional logic and enriched event publishing"
      contains: "DryRun"
  key_links:
    - from: "DcaExecutionService.cs"
      to: "DcaOptions.DryRun"
      via: "IOptionsMonitor<DcaOptions>"
      pattern: "options\\.DryRun"
    - from: "DcaExecutionService.cs"
      to: "PurchaseCompletedEvent"
      via: "publisher.Publish with multiplier metadata"
      pattern: "new PurchaseCompletedEvent"
    - from: "Purchase.cs"
      to: "TradingBotDbContext"
      via: "EF Core entity configuration for IsDryRun"
      pattern: "IsDryRun"
---

<objective>
Add dry-run mode to DCA execution and enrich purchase events with multiplier metadata.

Purpose: Foundation for rich notifications (Plan 02) and accurate running totals. Dry-run mode enables safe testing per FR-13. Enhanced events carry the data notification handlers need for multiplier reasoning messages.

Output: Updated Purchase entity with IsDryRun flag, enhanced PurchaseCompletedEvent with multiplier metadata, DcaExecutionService wired with dry-run conditional logic, and EF Core migration.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-enhanced-notifications-observability/04-CONTEXT.md

@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
@TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs
@TradingBot.ApiService/Application/Events/PurchaseSkippedEvent.cs
@TradingBot.ApiService/Application/Services/DcaExecutionService.cs
@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
@TradingBot.ApiService/Configuration/DcaOptions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IsDryRun to Purchase entity and enhance PurchaseCompletedEvent</name>
  <files>
    TradingBot.ApiService/Models/Purchase.cs
    TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
    TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
  </files>
  <action>
1. **Purchase.cs** — Add `IsDryRun` boolean property:
   ```csharp
   public bool IsDryRun { get; set; }
   ```
   Place it after the `Status` property, before `OrderId`. Default is `false` (non-dry-run) so existing rows are unaffected.

2. **PurchaseCompletedEvent.cs** — Enhance the record to carry multiplier metadata and dry-run flag:
   ```csharp
   public record PurchaseCompletedEvent(
       Guid PurchaseId,
       decimal BtcAmount,
       decimal Price,
       decimal UsdSpent,
       decimal RemainingUsdc,
       decimal CurrentBtcBalance,
       DateTimeOffset ExecutedAt,
       // Multiplier metadata for rich notifications
       decimal Multiplier,
       string? MultiplierTier,
       decimal DropPercentage,
       decimal High30Day,
       decimal Ma200Day,
       bool IsDryRun
   ) : IDomainEvent;
   ```
   Keep the existing parameters in the same order, append new ones at the end.

3. **TradingBotDbContext.cs** — Add `IsDryRun` configuration in the Purchase entity block:
   ```csharp
   entity.Property(e => e.IsDryRun)
       .HasDefaultValue(false);
   ```
   Place after the `FailureReason` configuration, before multiplier metadata fields.

4. **Create EF Core migration** — Run:
   ```bash
   cd TradingBot.ApiService && dotnet ef migrations add AddIsDryRunToPurchase
   ```
  </action>
  <verify>
    - `dotnet build TradingBot.sln` compiles without errors
    - Migration file exists in Infrastructure/Data/Migrations/ with `IsDryRun` column
    - PurchaseCompletedEvent has Multiplier, MultiplierTier, DropPercentage, High30Day, Ma200Day, IsDryRun parameters
  </verify>
  <done>
    Purchase entity has IsDryRun flag with EF Core migration. PurchaseCompletedEvent carries all multiplier metadata needed for rich notification formatting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire dry-run mode and enriched events into DcaExecutionService</name>
  <files>
    TradingBot.ApiService/Application/Services/DcaExecutionService.cs
  </files>
  <action>
Modify `DcaExecutionService.ExecuteDailyPurchaseAsync` to implement dry-run mode and enrich event publishing:

1. **Dry-run conditional in Step 6 (order placement):**
   After calculating `roundedQuantity` and `limitPrice`, check `options.DryRun`:
   - If `DryRun == true`: Skip the actual `PlaceSpotOrderAsync` call. Instead, simulate a fill:
     ```csharp
     if (options.DryRun)
     {
         logger.LogInformation("[DRY RUN] Simulating order: {Quantity} BTC at {Price}", roundedQuantity, currentPrice);
         purchase.Quantity = roundedQuantity;
         purchase.Price = currentPrice;
         purchase.Cost = roundedQuantity * currentPrice;
         purchase.Status = PurchaseStatus.Filled;
         purchase.OrderId = $"DRY-RUN-{Guid.NewGuid():N}";
         purchase.IsDryRun = true;
     }
     else
     {
         // ... existing order placement code (unchanged) ...
     }
     ```
   - Keep the existing try/catch order placement code in the `else` branch, completely unchanged.

2. **Set IsDryRun on purchase record:**
   Right after creating the `Purchase` object (before the try block), set:
   ```csharp
   purchase.IsDryRun = options.DryRun;
   ```

3. **Idempotency check update:**
   In Step 2 (idempotency check), the existing query filters by Filled/PartiallyFilled status. Add a filter to only consider non-dry-run purchases for idempotency:
   ```csharp
   .Where(p => !p.IsDryRun)
   ```
   This allows dry-run to execute even if a real purchase was already made (for testing).

4. **Enrich PurchaseCompletedEvent in Step 8:**
   Update the `new PurchaseCompletedEvent(...)` call to include multiplier metadata:
   ```csharp
   await publisher.Publish(new PurchaseCompletedEvent(
       purchase.Id,
       purchase.Quantity,
       purchase.Price,
       purchase.Cost,
       remainingUsdc,
       currentBtcBalance,
       purchase.ExecutedAt,
       purchase.Multiplier,
       purchase.MultiplierTier,
       purchase.DropPercentage,
       purchase.High30Day,
       purchase.Ma200Day,
       purchase.IsDryRun), ct);
   ```

5. **Log clearly for dry-run mode:**
   At the start of `ExecuteDailyPurchaseAsync`, if DryRun is true, log:
   ```csharp
   if (options.DryRun)
       logger.LogInformation("[DRY RUN] Executing simulated purchase for {Date}", purchaseDate);
   ```
  </action>
  <verify>
    - `dotnet build TradingBot.sln` compiles without errors (PurchaseCompletedEvent constructor matches all call sites)
    - When DryRun=true in config: no `PlaceSpotOrderAsync` call, purchase persisted with IsDryRun=true and status=Filled
    - When DryRun=false: behavior identical to current (no regression)
    - PurchaseCompletedEvent published with all multiplier fields populated
  </verify>
  <done>
    DcaExecutionService respects DryRun config: skips order placement, simulates fill, sets IsDryRun flag. Events enriched with multiplier metadata for downstream notification handlers.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` — clean compilation
2. `dotnet test` — all existing tests pass (no regressions)
3. Migration file created with IsDryRun column (boolean, default false)
4. PurchaseCompletedEvent carries: Multiplier, MultiplierTier, DropPercentage, High30Day, Ma200Day, IsDryRun
5. DcaExecutionService: when DryRun=true, no HyperliquidClient.PlaceSpotOrderAsync call
6. DcaExecutionService: when DryRun=false, identical behavior to before
</verification>

<success_criteria>
- Purchase entity has IsDryRun boolean property with EF Core migration
- PurchaseCompletedEvent enriched with multiplier metadata (6 new fields)
- DcaExecutionService implements dry-run mode (skip order, simulate fill, persist with IsDryRun=true)
- Idempotency check excludes dry-run purchases
- All builds pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-enhanced-notifications-observability/04-01-SUMMARY.md`
</output>
