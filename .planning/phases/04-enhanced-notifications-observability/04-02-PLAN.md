---
phase: 04-enhanced-notifications-observability
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
  - TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
  - TradingBot.ApiService/Application/Handlers/PurchaseSkippedHandler.cs
autonomous: true

must_haves:
  truths:
    - "Buy notification includes multiplier reasoning in natural language (e.g., 'BTC is 15% below 30-day high and below 200-day MA')"
    - "Buy notification includes running totals: total BTC accumulated, total USD spent, average cost basis"
    - "Dry-run buy notifications display a clear SIMULATION banner"
    - "Skip notifications explain why the purchase was skipped with contextual details"
    - "Failed notifications include error type and retry count"
  artifacts:
    - path: "TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs"
      provides: "Rich buy notification with multiplier reasoning and running totals"
      contains: "TradingBotDbContext"
    - path: "TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs"
      provides: "Enhanced failure notification"
      contains: "SendMessageAsync"
    - path: "TradingBot.ApiService/Application/Handlers/PurchaseSkippedHandler.cs"
      provides: "Enhanced skip notification with reasoning"
      contains: "SendMessageAsync"
  key_links:
    - from: "PurchaseCompletedHandler.cs"
      to: "TradingBotDbContext"
      via: "EF Core query for running totals"
      pattern: "dbContext\\.Purchases"
    - from: "PurchaseCompletedHandler.cs"
      to: "PurchaseCompletedEvent"
      via: "Multiplier metadata from enriched event"
      pattern: "notification\\.Multiplier"
---

<objective>
Rewrite all three notification handlers with rich Telegram formatting, multiplier reasoning, and running totals.

Purpose: FR-11 (Rich Notifications). Every buy message explains what the bot did and why. Running totals give the user a quick snapshot of their DCA performance. Dry-run messages are clearly marked as simulations per FR-13.

Output: Three enhanced MediatR notification handlers producing rich, readable Telegram messages.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-enhanced-notifications-observability/04-CONTEXT.md
@.planning/phases/04-enhanced-notifications-observability/04-01-SUMMARY.md

@TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
@TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
@TradingBot.ApiService/Application/Handlers/PurchaseSkippedHandler.cs
@TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
@TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs
@TradingBot.ApiService/Application/Events/PurchaseSkippedEvent.cs
@TradingBot.ApiService/Infrastructure/Telegram/TelegramNotificationService.cs
@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
@TradingBot.ApiService/Models/Purchase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite PurchaseCompletedHandler with rich formatting and running totals</name>
  <files>
    TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
  </files>
  <action>
Rewrite PurchaseCompletedHandler to produce a rich Telegram notification with multiplier reasoning and running totals.

1. **Add TradingBotDbContext dependency** via primary constructor (alongside existing TelegramNotificationService and ILogger). The handler is resolved from a scope, so DbContext injection works.

2. **Query running totals** from the database inside the Handle method:
   ```csharp
   // Running totals — exclude dry-run purchases
   var totals = await dbContext.Purchases
       .Where(p => p.Status == PurchaseStatus.Filled || p.Status == PurchaseStatus.PartiallyFilled)
       .Where(p => !p.IsDryRun)
       .GroupBy(p => 1)
       .Select(g => new
       {
           TotalBtc = g.Sum(p => p.Quantity),
           TotalUsd = g.Sum(p => p.Cost),
           PurchaseCount = g.Count()
       })
       .FirstOrDefaultAsync(cancellationToken);

   var totalBtc = totals?.TotalBtc ?? 0m;
   var totalUsd = totals?.TotalUsd ?? 0m;
   var avgCost = totalBtc > 0 ? totalUsd / totalBtc : 0m;
   ```

3. **Build multiplier reasoning string** from the event metadata:
   ```csharp
   var reasoning = BuildMultiplierReasoning(notification);
   ```
   Create a private helper method `BuildMultiplierReasoning(PurchaseCompletedEvent e)`:
   - If Multiplier == 1.0 and tier is "None" or null: "Standard buy (no dip detected)"
   - If Multiplier > 1.0: Build natural language like:
     - "BTC is {DropPercentage:F1}% below 30-day high (${High30Day:F0})" for dip component
     - "Price below 200-day MA (${Ma200Day:F0}), bear boost active" if Ma200Day > 0 and current price < Ma200Day
     - Combine: "Buying {Multiplier:F1}x: {dip reason} {bear reason}"
   - If tier contains "Error" or "N/A": "Multiplier calculation had limited data, using {Multiplier:F1}x"

4. **Build the message** using Telegram Markdown v1:
   ```
   If IsDryRun: prepend a SIMULATION section at the top

   *BTC Purchase Successful*
   (or *[SIMULATION] BTC Purchase* if dry-run)

   *Price:* `$XX,XXX.XX`
   *Bought:* `0.XXXXX` BTC
   *Cost:* `$XX.XX`
   *Multiplier:* `X.Xx`

   {reasoning line — natural language explanation}

   *Running Totals*
   Total BTC: `X.XXXXX` BTC
   Total Spent: `$X,XXX.XX`
   Avg Cost: `$XX,XXX.XX`

   *Balances*
   BTC: `X.XXXXX` BTC
   USDC: `$XX.XX`

   _YYYY-MM-DD HH:mm:ss UTC_
   ```
   Format numbers appropriately: BTC with 5 decimals, USD with 2 decimals, price with 2 decimals.

5. **Error-safe pattern**: Keep the existing try/catch around `telegramService.SendMessageAsync`. If the running totals query fails, log and fall back to sending the notification without totals (don't let a DB query failure prevent the notification).
  </action>
  <verify>
    - `dotnet build TradingBot.sln` compiles without errors
    - Handler accepts TradingBotDbContext in constructor
    - Message includes: price, quantity, cost, multiplier value, reasoning text, running totals (total BTC, total USD, avg cost), balances
    - Dry-run messages have SIMULATION banner in the message
    - Running totals query filters out IsDryRun purchases
  </verify>
  <done>
    PurchaseCompletedHandler produces rich notifications with multiplier reasoning in natural language, running totals from database, and clear SIMULATION banner for dry-run purchases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance PurchaseFailedHandler and PurchaseSkippedHandler</name>
  <files>
    TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
    TradingBot.ApiService/Application/Handlers/PurchaseSkippedHandler.cs
  </files>
  <action>
1. **PurchaseFailedHandler** — Enhance the failure notification message:
   - Keep existing structure and error-safe pattern
   - Improve formatting with clearer sections:
     ```
     *BTC Purchase Failed*

     *Error:* {ErrorType}
     *Details:* `{ErrorMessage}`
     *Retries:* {RetryCount}/3

     The bot will retry automatically on transient errors.
     Check logs if this persists.

     _YYYY-MM-DD HH:mm:ss UTC_
     ```
   - If RetryCount >= 3: Add "All retries exhausted. Manual intervention may be needed." instead of the retry message.

2. **PurchaseSkippedHandler** — Enhance the skip notification with contextual reasoning:
   - Keep existing conditional balance/required lines
   - Add more context based on reason string:
     - "Already purchased today" -> add: "Next buy scheduled tomorrow."
     - "Insufficient balance" -> keep balance/required lines as-is, add: "Please add USDC to your Hyperliquid account."
     - "Amount below minimum order value" -> add: "The calculated buy amount was too small for a valid order."
     - Default/other reasons: just show the reason
   - Format:
     ```
     *BTC Purchase Skipped*

     *Reason:* {Reason}
     {contextual detail line based on reason}

     {balance line if available}
     {required line if available}

     _YYYY-MM-DD HH:mm:ss UTC_
     ```
   - Keep error-safe try/catch pattern
  </action>
  <verify>
    - `dotnet build TradingBot.sln` compiles without errors
    - PurchaseFailedHandler: messages differentiate between retriable vs exhausted retries
    - PurchaseSkippedHandler: messages include contextual reasoning based on skip reason
    - Both handlers maintain error-safe pattern (catch + log, never throw)
  </verify>
  <done>
    All three notification handlers produce rich, readable Telegram messages. Failed messages distinguish retry states. Skip messages explain reasoning with actionable context.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` — clean compilation
2. `dotnet test` — all existing tests pass
3. PurchaseCompletedHandler: message includes multiplier reasoning, running totals, SIMULATION banner for dry-run
4. PurchaseFailedHandler: message differentiates retriable vs final failure
5. PurchaseSkippedHandler: message includes contextual reasoning per skip reason
6. All handlers maintain error-safe pattern (try/catch around Telegram calls)
7. Running totals query excludes dry-run purchases (WHERE IsDryRun = false)
</verification>

<success_criteria>
- Rich buy notification with: multiplier value, natural language reasoning, running totals (total BTC, total USD, avg cost), balances
- Dry-run notifications clearly marked with SIMULATION banner
- Skip notifications explain the reason with actionable context
- Failed notifications distinguish between retry-in-progress and all-retries-exhausted
- Error-safe: notification failures never propagate as exceptions
</success_criteria>

<output>
After completion, create `.planning/phases/04-enhanced-notifications-observability/04-02-SUMMARY.md`
</output>
