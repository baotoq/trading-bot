---
phase: 12-configuration-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Models/DcaConfiguration.cs
  - TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
  - TradingBot.ApiService/Application/Services/ConfigurationService.cs
  - TradingBot.ApiService/Endpoints/ConfigurationEndpoints.cs
  - TradingBot.ApiService/Endpoints/DashboardDtos.cs
  - TradingBot.ApiService/Program.cs
autonomous: true

must_haves:
  truths:
    - "GET /api/config returns current DCA configuration with all fields"
    - "PUT /api/config validates input using DcaOptionsValidator and saves to PostgreSQL"
    - "PUT /api/config with invalid data returns 400 with structured validation errors"
    - "GET /api/config/defaults returns appsettings.json defaults"
    - "After PUT /api/config, IOptionsMonitor<DcaOptions>.CurrentValue returns updated values"
    - "DcaConfiguration table enforces single-row constraint"
  artifacts:
    - path: "TradingBot.ApiService/Models/DcaConfiguration.cs"
      provides: "DcaConfiguration entity with typed columns and JSONB tiers"
    - path: "TradingBot.ApiService/Application/Services/ConfigurationService.cs"
      provides: "IConfigurationService with GetCurrent, Update, GetDefaults"
      exports: ["IConfigurationService", "ConfigurationService"]
    - path: "TradingBot.ApiService/Endpoints/ConfigurationEndpoints.cs"
      provides: "GET /api/config, PUT /api/config, GET /api/config/defaults"
      exports: ["ConfigurationEndpoints"]
  key_links:
    - from: "ConfigurationService.UpdateAsync"
      to: "IOptionsMonitorCache<DcaOptions>.TryRemove"
      via: "cache invalidation after DB save"
      pattern: "optionsCache\\.TryRemove"
    - from: "ConfigurationEndpoints.UpdateConfigAsync"
      to: "IConfigurationService.UpdateAsync"
      via: "DI injection in endpoint handler"
      pattern: "configService\\.UpdateAsync"
    - from: "ConfigurationService.GetCurrentAsync"
      to: "TradingBotDbContext.DcaConfigurations"
      via: "EF Core query"
      pattern: "db\\.DcaConfigurations"
---

<objective>
Backend configuration management: database entity, service layer, and API endpoints for reading, updating, and resetting DCA configuration.

Purpose: Provides the backend infrastructure for the configuration management feature. The DcaConfiguration entity persists config to PostgreSQL, the ConfigurationService bridges DB storage with IOptionsMonitor for immediate effect, and API endpoints expose CRUD operations with server-side validation.

Output: Working API endpoints (GET/PUT /api/config, GET /api/config/defaults) with database persistence and IOptionsMonitor cache invalidation.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-configuration-management/12-CONTEXT.md
@.planning/phases/12-configuration-management/12-RESEARCH.md

@TradingBot.ApiService/Configuration/DcaOptions.cs
@TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
@TradingBot.ApiService/Endpoints/DashboardDtos.cs
@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/BuildingBlocks/BaseEntity.cs
@TradingBot.ApiService/BuildingBlocks/AuditedEntity.cs
@TradingBot.ApiService/Program.cs
@TradingBot.ApiService/appsettings.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: DcaConfiguration entity, DbContext, and EF migration</name>
  <files>
    TradingBot.ApiService/Models/DcaConfiguration.cs
    TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
  </files>
  <action>
    Create `DcaConfiguration` entity in Models/ that does NOT inherit from BaseEntity (single-row singleton, no UUIDv7 generation needed). Instead, inherit from AuditedEntity for CreatedAt/UpdatedAt timestamps.

    DcaConfiguration fields (separate typed columns, matching DcaOptions exactly):
    - `Guid Id { get; init; }` with fixed value `Guid.Parse("00000000-0000-0000-0000-000000000001")`
    - `decimal BaseDailyAmount`
    - `int DailyBuyHour`
    - `int DailyBuyMinute`
    - `int HighLookbackDays`
    - `bool DryRun`
    - `int BearMarketMaPeriod`
    - `decimal BearBoostFactor`
    - `decimal MaxMultiplierCap`
    - `List<MultiplierTierData> MultiplierTiers` stored as JSONB (variable-length array)

    Create a `MultiplierTierData` record class in the same file: `public record MultiplierTierData(decimal DropPercentage, decimal Multiplier)`

    In TradingBotDbContext:
    - Add `public DbSet<DcaConfiguration> DcaConfigurations => Set<DcaConfiguration>();`
    - Configure entity in OnModelCreating:
      - HasKey(e => e.Id)
      - BaseDailyAmount precision (18, 2)
      - BearBoostFactor precision (4, 2)
      - MaxMultiplierCap precision (4, 2)
      - MultiplierTiers stored as JSONB via `.HasColumnType("jsonb")`
      - Add check constraint: `.HasCheckConstraint("CK_DcaConfiguration_SingleRow", "id = '00000000-0000-0000-0000-000000000001'::uuid")`

    Then create the EF migration by running:
    `cd TradingBot.ApiService && dotnet ef migrations add AddDcaConfiguration`

    The migration auto-runs on startup via `dbContext.Database.MigrateAsync()` in Program.cs.
  </action>
  <verify>
    `dotnet build TradingBot.sln` succeeds. Migration file exists in Infrastructure/Data/Migrations/. `dotnet test` passes (no regressions).
  </verify>
  <done>DcaConfiguration entity exists with all DcaOptions fields, DbContext has DbSet and configuration, migration is generated.</done>
</task>

<task type="auto">
  <name>Task 2: ConfigurationService, API endpoints, and DI wiring</name>
  <files>
    TradingBot.ApiService/Application/Services/ConfigurationService.cs
    TradingBot.ApiService/Endpoints/ConfigurationEndpoints.cs
    TradingBot.ApiService/Endpoints/DashboardDtos.cs
    TradingBot.ApiService/Program.cs
  </files>
  <action>
    **ConfigurationService (Application/Services/ConfigurationService.cs):**

    Create `IConfigurationService` interface and `ConfigurationService` class using primary constructor pattern:

    ```
    public interface IConfigurationService
    {
        Task<DcaOptions> GetCurrentAsync(CancellationToken ct = default);
        Task UpdateAsync(DcaOptions options, CancellationToken ct = default);
        Task<DcaOptions> GetDefaultsAsync(CancellationToken ct = default);
    }
    ```

    ConfigurationService constructor takes: `TradingBotDbContext db, IOptionsMonitor<DcaOptions> defaultOptions, IOptionsMonitorCache<DcaOptions> optionsCache, IValidateOptions<DcaOptions> validator`

    - `GetCurrentAsync`: Query `db.DcaConfigurations.FirstOrDefaultAsync()`. If null (no DB row yet), fallback to `defaultOptions.CurrentValue`. Otherwise map entity to DcaOptions.
    - `UpdateAsync`: Validate using `validator.Validate(Options.DefaultName, options)`. If failed, throw `ValidationException` with joined failure messages. Then upsert: query existing row, if null create new with fixed GUID, map options to entity fields, set UpdatedAt, SaveChangesAsync. CRITICAL: After save, call `optionsCache.TryRemove(Options.DefaultName)` to invalidate IOptionsMonitor cache.
    - `GetDefaultsAsync`: Return `defaultOptions.CurrentValue` (source of truth from appsettings.json). Note: Must capture initial defaults before any DB override. Use a separate IConfiguration read or store initial value. Simplest approach: read directly from IConfiguration section binding since appsettings.json doesn't change at runtime.

    Include private mapping methods:
    - `MapToOptions(DcaConfiguration entity)` -> DcaOptions (map MultiplierTierData to MultiplierTier)
    - `MapFromOptions(DcaConfiguration entity, DcaOptions options)` -> void (map MultiplierTier to MultiplierTierData)

    **ConfigurationEndpoints (Endpoints/ConfigurationEndpoints.cs):**

    Follow DashboardEndpoints pattern. Create `ConfigurationEndpoints` static class with `MapConfigurationEndpoints` extension method.

    Route group: `/api/config` with `ApiKeyEndpointFilter` (same auth as dashboard).

    Three endpoints:
    1. `GET /` -> GetConfigAsync: Inject IConfigurationService, return ConfigResponse record
    2. `GET /defaults` -> GetDefaultsAsync: Inject IConfigurationService, return ConfigResponse
    3. `PUT /` -> UpdateConfigAsync: Inject IConfigurationService + ILogger<Program>. Accept UpdateConfigRequest body. Map to DcaOptions, call UpdateAsync. On success return 200. Catch ValidationException and return Results.BadRequest with `new { errors = new[] { ex.Message } }`. Log successful updates with structured logging.

    **DashboardDtos.cs updates:**

    Add new DTOs (append to existing file):
    - `ConfigResponse` record: BaseDailyAmount, DailyBuyHour, DailyBuyMinute, HighLookbackDays, DryRun, BearMarketMaPeriod, BearBoostFactor, MaxMultiplierCap, List<MultiplierTierDto> Tiers
    - `UpdateConfigRequest` record: same fields as ConfigResponse

    Note: The existing `DcaConfigResponse` is missing DailyBuyHour, DailyBuyMinute, and DryRun fields. The new `ConfigResponse` is a superset. Keep the old `DcaConfigResponse` for backward compatibility with the backtest page.

    **Program.cs updates:**
    - Register `IConfigurationService` as scoped: `builder.Services.AddScoped<IConfigurationService, ConfigurationService>();`
    - Add endpoint mapping: `app.MapConfigurationEndpoints();` (after MapDashboardEndpoints)
  </action>
  <verify>
    `dotnet build TradingBot.sln` succeeds. `dotnet test` passes. Start the app with `cd TradingBot.AppHost && dotnet run` and test:
    - `curl -H "x-api-key: <key>" http://localhost:5000/api/config` returns full config JSON
    - `curl -H "x-api-key: <key>" http://localhost:5000/api/config/defaults` returns defaults
    - `curl -X PUT -H "x-api-key: <key>" -H "Content-Type: application/json" -d '{"baseDailyAmount":20,...}' http://localhost:5000/api/config` returns 200
    - Sending invalid data (e.g., baseDailyAmount: -1) returns 400 with error messages
  </verify>
  <done>ConfigurationService reads/writes config from PostgreSQL with IOptionsMonitor cache invalidation. Three API endpoints work with authentication. Invalid config returns structured errors. DCA scheduler picks up new config on next cycle without restart.</done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` compiles without errors
2. `dotnet test` passes all 53 existing tests
3. GET /api/config returns all DcaOptions fields including DailyBuyHour, DailyBuyMinute, DryRun
4. PUT /api/config saves to database and invalidates IOptionsMonitor cache
5. PUT /api/config with invalid data returns 400 with validation errors
6. GET /api/config/defaults returns appsettings.json values
7. DcaConfiguration table has single-row CHECK constraint
</verification>

<success_criteria>
- Backend API endpoints for config CRUD are functional and authenticated
- Config persists to PostgreSQL and takes effect immediately via IOptionsMonitor cache invalidation
- Server-side validation reuses existing DcaOptionsValidator rules
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/12-configuration-management/12-01-SUMMARY.md`
</output>
