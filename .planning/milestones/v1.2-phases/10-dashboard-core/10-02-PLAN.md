---
phase: 10-dashboard-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.Dashboard/package.json
  - TradingBot.Dashboard/app/types/dashboard.ts
  - TradingBot.Dashboard/app/composables/useDashboard.ts
  - TradingBot.Dashboard/app/composables/usePurchaseHistory.ts
  - TradingBot.Dashboard/app/composables/useCountdownTimer.ts
  - TradingBot.Dashboard/server/api/dashboard/portfolio.get.ts
  - TradingBot.Dashboard/server/api/dashboard/purchases.get.ts
  - TradingBot.Dashboard/server/api/dashboard/status.get.ts
  - TradingBot.Dashboard/server/api/dashboard/chart.get.ts
autonomous: true

must_haves:
  truths:
    - "npm install succeeds with chart.js, vue-chartjs, chartjs-plugin-annotation, @vueuse/core, date-fns"
    - "TypeScript types match backend DTO contracts exactly"
    - "useDashboard composable fetches portfolio and status data with 10-second polling"
    - "usePurchaseHistory composable supports infinite scroll with cursor-based pagination and loading guard"
    - "useCountdownTimer composable ticks every second and formats remaining time as Xh Ym Zs"
    - "Nuxt server routes proxy all four dashboard endpoints to .NET backend with API key auth"
  artifacts:
    - path: "TradingBot.Dashboard/app/types/dashboard.ts"
      provides: "TypeScript interfaces for all API responses"
      contains: "PortfolioResponse|PurchaseHistoryResponse|LiveStatusResponse|PriceChartResponse"
    - path: "TradingBot.Dashboard/app/composables/useDashboard.ts"
      provides: "Portfolio and status data fetching with polling"
      contains: "useDashboard|useIntervalFn|refresh"
    - path: "TradingBot.Dashboard/app/composables/usePurchaseHistory.ts"
      provides: "Infinite scroll purchase history pagination"
      contains: "usePurchaseHistory|cursor|hasMore|loading"
    - path: "TradingBot.Dashboard/app/composables/useCountdownTimer.ts"
      provides: "Live countdown timer for next buy"
      contains: "useCountdownTimer|remaining|useIntervalFn"
  key_links:
    - from: "TradingBot.Dashboard/app/composables/useDashboard.ts"
      to: "/api/dashboard/portfolio"
      via: "useFetch with server:false"
      pattern: "useFetch.*portfolio"
    - from: "TradingBot.Dashboard/app/composables/usePurchaseHistory.ts"
      to: "/api/dashboard/purchases"
      via: "$fetch with cursor param"
      pattern: "\\$fetch.*purchases"
    - from: "TradingBot.Dashboard/server/api/dashboard/portfolio.get.ts"
      to: ".NET /api/dashboard/portfolio"
      via: "$fetch with x-api-key header"
      pattern: "x-api-key"
---

<objective>
Install frontend dependencies, create TypeScript types matching backend DTOs, build data-fetching composables with polling and infinite scroll, and create Nuxt server proxy routes for all dashboard endpoints.

Purpose: Establishes the data layer between the Nuxt frontend and .NET backend. Composables encapsulate fetching logic, polling intervals, pagination state, and countdown timer — keeping Vue components pure presentation.

Output: Installed npm packages, TypeScript types, three composables, and four server proxy routes.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-dashboard-core/10-CONTEXT.md
@.planning/phases/10-dashboard-core/10-RESEARCH.md
@.planning/phases/09.1-migrate-dashboard-to-fresh-nuxt-setup/09.1-01-SUMMARY.md

Key existing code:
@TradingBot.Dashboard/package.json (current deps)
@TradingBot.Dashboard/nuxt.config.ts (runtimeConfig, routeRules)
@TradingBot.Dashboard/server/utils/auth.ts (requireApiKey utility)
@TradingBot.Dashboard/server/api/portfolio.get.ts (existing placeholder — will be replaced)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install npm dependencies and create TypeScript types</name>
  <files>
    TradingBot.Dashboard/package.json
    TradingBot.Dashboard/app/types/dashboard.ts
  </files>
  <action>
Run from `TradingBot.Dashboard/` directory:
```bash
npm install chart.js vue-chartjs chartjs-plugin-annotation @vueuse/core date-fns
```

Then create `TradingBot.Dashboard/app/types/dashboard.ts` with TypeScript interfaces that match the backend DTOs exactly:

```typescript
// Portfolio overview (matches PortfolioResponse)
export interface PortfolioResponse {
  totalBtc: number
  totalCost: number
  averageCostBasis: number
  currentPrice: number
  unrealizedPnl: number
  unrealizedPnlPercent: number
  totalPurchaseCount: number
  firstPurchaseDate: string | null
  lastPurchaseDate: string | null
}

// Purchase history (matches PurchaseHistoryResponse)
export interface PurchaseHistoryResponse {
  items: PurchaseDto[]
  nextCursor: string | null
  hasMore: boolean
}

export interface PurchaseDto {
  id: string
  executedAt: string
  price: number
  cost: number
  quantity: number
  multiplierTier: string
  multiplier: number
  dropPercentage: number
}

// Live status (matches LiveStatusResponse)
export interface LiveStatusResponse {
  healthStatus: string
  healthMessage: string | null
  nextBuyTime: string | null
  lastPurchaseTime: string | null
  lastPurchasePrice: number | null
  lastPurchaseBtc: number | null
  lastPurchaseTier: string | null
}

// Price chart data (matches PriceChartResponse)
export interface PriceChartResponse {
  prices: PricePointDto[]
  purchases: PurchaseMarkerDto[]
  averageCostBasis: number
}

export interface PricePointDto {
  date: string
  price: number
}

export interface PurchaseMarkerDto {
  date: string
  price: number
  btcAmount: number
  tier: string
}

// Timeframe type for chart
export type ChartTimeframe = '7D' | '1M' | '3M' | '6M' | '1Y' | 'All'
```

Note: Properties use camelCase because .NET System.Text.Json defaults to camelCase serialization.
  </action>
  <verify>
Verify `package.json` contains chart.js, vue-chartjs, chartjs-plugin-annotation, @vueuse/core, date-fns in dependencies. Verify `app/types/dashboard.ts` exists with all interface definitions. Run `npx nuxi prepare` to confirm TypeScript compilation.
  </verify>
  <done>
All npm packages installed, TypeScript types defined for all 8 API response shapes matching backend DTOs exactly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create composables, Nuxt server proxy routes, and replace placeholder portfolio route</name>
  <files>
    TradingBot.Dashboard/app/composables/useDashboard.ts
    TradingBot.Dashboard/app/composables/usePurchaseHistory.ts
    TradingBot.Dashboard/app/composables/useCountdownTimer.ts
    TradingBot.Dashboard/server/api/dashboard/portfolio.get.ts
    TradingBot.Dashboard/server/api/dashboard/purchases.get.ts
    TradingBot.Dashboard/server/api/dashboard/status.get.ts
    TradingBot.Dashboard/server/api/dashboard/chart.get.ts
    TradingBot.Dashboard/server/api/portfolio.get.ts
  </files>
  <action>
**Delete** the old `server/api/portfolio.get.ts` (Phase 9 placeholder) — all dashboard routes now live under `server/api/dashboard/`.

**Create four Nuxt server proxy routes** under `server/api/dashboard/`:

Each server route follows the same pattern established in Phase 09-02:
- Get runtimeConfig for apiKey and apiEndpoint
- Forward the request to .NET backend at `${apiEndpoint}/api/dashboard/{endpoint}`
- Include `x-api-key` header from config
- Forward query parameters from the original request
- Catch errors and throw createError with appropriate status

`server/api/dashboard/portfolio.get.ts`:
```typescript
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig(event)
  try {
    return await $fetch(`${config.public.apiEndpoint}/api/dashboard/portfolio`, {
      headers: { 'x-api-key': config.apiKey }
    })
  } catch (error: any) {
    throw createError({
      status: error?.response?.status || 502,
      statusText: error?.response?.statusText || 'Bad Gateway',
      data: { reason: 'Failed to fetch portfolio from backend API' }
    })
  }
})
```

`server/api/dashboard/purchases.get.ts` — Forward query params (cursor, pageSize, startDate, endDate):
```typescript
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig(event)
  const query = getQuery(event)
  try {
    return await $fetch(`${config.public.apiEndpoint}/api/dashboard/purchases`, {
      headers: { 'x-api-key': config.apiKey },
      query
    })
  } catch (error: any) {
    throw createError({
      status: error?.response?.status || 502,
      statusText: error?.response?.statusText || 'Bad Gateway',
      data: { reason: 'Failed to fetch purchases from backend API' }
    })
  }
})
```

`server/api/dashboard/status.get.ts` — Simple forward:
```typescript
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig(event)
  try {
    return await $fetch(`${config.public.apiEndpoint}/api/dashboard/status`, {
      headers: { 'x-api-key': config.apiKey }
    })
  } catch (error: any) {
    throw createError({
      status: error?.response?.status || 502,
      statusText: error?.response?.statusText || 'Bad Gateway',
      data: { reason: 'Failed to fetch status from backend API' }
    })
  }
})
```

`server/api/dashboard/chart.get.ts` — Forward timeframe query param:
```typescript
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig(event)
  const query = getQuery(event)
  try {
    return await $fetch(`${config.public.apiEndpoint}/api/dashboard/chart`, {
      headers: { 'x-api-key': config.apiKey },
      query
    })
  } catch (error: any) {
    throw createError({
      status: error?.response?.status || 502,
      statusText: error?.response?.statusText || 'Bad Gateway',
      data: { reason: 'Failed to fetch chart data from backend API' }
    })
  }
})
```

**Create three composables** under `app/composables/`:

`app/composables/useDashboard.ts`:
- Import `useIntervalFn` from `@vueuse/core` and types from `~/types/dashboard`
- Use `useFetch<PortfolioResponse>('/api/dashboard/portfolio', { lazy: true, server: false })` for portfolio data
- Use `useFetch<LiveStatusResponse>('/api/dashboard/status', { lazy: true, server: false })` for status data
- Set up 10-second polling with `useIntervalFn` that calls both refresh functions
- Return: `{ portfolio, status, portfolioPending, statusPending, portfolioError, statusError, refreshAll }`
- Use `onUnmounted` to pause the interval

`app/composables/usePurchaseHistory.ts`:
- Maintain refs: `purchases: Ref<PurchaseDto[]>`, `cursor: Ref<string | null>`, `hasMore: Ref<boolean>`, `loading: Ref<boolean>`, `startDate: Ref<string | null>`, `endDate: Ref<string | null>`
- `loadMore` function: guard with `if (loading.value || !hasMore.value) return`, set loading true, call `$fetch<PurchaseHistoryResponse>('/api/dashboard/purchases', { query: { cursor, pageSize: 20, startDate, endDate } })`, push items to purchases array, update cursor and hasMore, set loading false in finally block
- `resetAndLoad` function: clear purchases array, reset cursor to null, set hasMore to true, call loadMore — used when filters change
- `loadInitial` function: call resetAndLoad on mount
- Return: `{ purchases, loading, hasMore, loadMore, startDate, endDate, resetAndLoad }`

`app/composables/useCountdownTimer.ts`:
- Accept `targetTime: Ref<string | null>` parameter
- Maintain `remaining: Ref<string>` for display text
- `updateCountdown` function:
  - If no targetTime, set remaining to "N/A"
  - Parse targetTime, calculate diff in seconds from now
  - If <= 0, set remaining to "Now"
  - Otherwise format as `Xh Ym Zs` (e.g., "4h 23m 15s")
- Use `useIntervalFn(updateCountdown, 1000, { immediate: true })` from @vueuse/core
- Pause interval on unmount via onUnmounted
- Return: `{ remaining }`
  </action>
  <verify>
Run `npx nuxi prepare` in TradingBot.Dashboard/ to verify TypeScript compilation. Verify all four server routes exist under `server/api/dashboard/`. Verify old `server/api/portfolio.get.ts` is deleted. Verify all three composables exist under `app/composables/`. Verify composables import from correct type paths.
  </verify>
  <done>
Three composables provide reactive data fetching (portfolio polling, infinite scroll pagination, countdown timer). Four server proxy routes forward dashboard API calls to .NET backend with API key authentication. Old placeholder portfolio route removed.
  </done>
</task>

</tasks>

<verification>
1. `npm ls chart.js vue-chartjs chartjs-plugin-annotation @vueuse/core date-fns` shows all packages installed
2. `app/types/dashboard.ts` contains PortfolioResponse, PurchaseHistoryResponse, PurchaseDto, LiveStatusResponse, PriceChartResponse, PricePointDto, PurchaseMarkerDto, ChartTimeframe
3. `app/composables/useDashboard.ts` uses useIntervalFn for 10-second polling and useFetch with server:false
4. `app/composables/usePurchaseHistory.ts` has loading guard and cursor-based pagination
5. `app/composables/useCountdownTimer.ts` ticks every 1 second with useIntervalFn
6. `server/api/dashboard/portfolio.get.ts` forwards to .NET with x-api-key header
7. `server/api/dashboard/purchases.get.ts` forwards query params (cursor, pageSize, startDate, endDate)
8. `server/api/dashboard/status.get.ts` forwards to .NET with x-api-key header
9. `server/api/dashboard/chart.get.ts` forwards timeframe query param
10. Old `server/api/portfolio.get.ts` is deleted
11. `npx nuxi prepare` succeeds without errors
</verification>

<success_criteria>
Frontend data layer is complete: npm packages installed, TypeScript types match backend contracts, composables provide reactive data fetching with polling and pagination, and server proxy routes securely forward all requests to the .NET backend.
</success_criteria>

<output>
After completion, create `.planning/phases/10-dashboard-core/10-02-SUMMARY.md`
</output>
