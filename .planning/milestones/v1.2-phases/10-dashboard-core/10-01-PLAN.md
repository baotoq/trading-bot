---
phase: 10-dashboard-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
  - TradingBot.ApiService/Endpoints/DashboardDtos.cs
autonomous: true

must_haves:
  truths:
    - "Portfolio endpoint returns total BTC, total cost, average cost basis, purchase count, first/last purchase dates"
    - "Purchase history endpoint returns paginated results with cursor-based navigation, date range filtering, and all purchase metadata"
    - "Live status endpoint returns bot health status, next buy time, last purchase summary, and connection indicator"
    - "Price chart endpoint returns daily close prices for specified timeframe with purchase markers and average cost basis"
  artifacts:
    - path: "TradingBot.ApiService/Endpoints/DashboardEndpoints.cs"
      provides: "Complete dashboard API endpoints"
      contains: "GetPortfolioAsync|GetPurchaseHistoryAsync|GetLiveStatusAsync|GetPriceChartAsync"
    - path: "TradingBot.ApiService/Endpoints/DashboardDtos.cs"
      provides: "DTO records for all dashboard API responses"
      contains: "PortfolioResponse|PurchaseHistoryResponse|LiveStatusResponse|PriceChartResponse"
  key_links:
    - from: "DashboardEndpoints.cs"
      to: "TradingBotDbContext"
      via: "EF Core queries"
      pattern: "db\\.Purchases|db\\.DailyPrices"
    - from: "DashboardEndpoints.cs"
      to: "DcaOptions"
      via: "IOptionsMonitor for schedule time"
      pattern: "IOptionsMonitor<DcaOptions>"
    - from: "DashboardEndpoints.cs"
      to: "IHyperliquidClient"
      via: "Live BTC price"
      pattern: "GetSpotPriceAsync"
---

<objective>
Build all .NET backend API endpoints for the dashboard: portfolio overview, purchase history with cursor pagination, live bot status, and price chart data.

Purpose: The frontend needs structured API data to render the dashboard. These endpoints aggregate data from existing Purchase and DailyPrice tables into dashboard-specific DTOs.

Output: Four fully functional API endpoints under /api/dashboard/ with proper DTOs, all protected by existing API key authentication.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-dashboard-core/10-CONTEXT.md
@.planning/phases/10-dashboard-core/10-RESEARCH.md
@.planning/phases/09-infrastructure-aspire-integration/09-02-SUMMARY.md

Key existing code:
@TradingBot.ApiService/Endpoints/DashboardEndpoints.cs (current placeholder)
@TradingBot.ApiService/Models/Purchase.cs (Purchase entity with all fields)
@TradingBot.ApiService/Models/DailyPrice.cs (DailyPrice entity for price history)
@TradingBot.ApiService/Configuration/DcaOptions.cs (schedule time config)
@TradingBot.ApiService/Application/Health/DcaHealthCheck.cs (health check pattern)
@TradingBot.ApiService/Infrastructure/Hyperliquid/HyperliquidClient.cs (GetSpotPriceAsync)
@TradingBot.ApiService/Program.cs (DI wiring and endpoint registration)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dashboard DTOs and implement all four API endpoints</name>
  <files>
    TradingBot.ApiService/Endpoints/DashboardDtos.cs
    TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
  </files>
  <action>
Create `DashboardDtos.cs` in `TradingBot.ApiService/Endpoints/` with these record types:

```csharp
namespace TradingBot.ApiService.Endpoints;

// Portfolio overview
public record PortfolioResponse(
    decimal TotalBtc,
    decimal TotalCost,
    decimal AverageCostBasis,
    decimal CurrentPrice,
    decimal UnrealizedPnl,
    decimal UnrealizedPnlPercent,
    int TotalPurchaseCount,
    DateTimeOffset? FirstPurchaseDate,
    DateTimeOffset? LastPurchaseDate
);

// Purchase history with cursor pagination
public record PurchaseHistoryResponse(
    List<PurchaseDto> Items,
    string? NextCursor,
    bool HasMore
);

public record PurchaseDto(
    Guid Id,
    DateTimeOffset ExecutedAt,
    decimal Price,
    decimal Cost,
    decimal Quantity,
    string MultiplierTier,
    decimal Multiplier,
    decimal DropPercentage
);

// Live status
public record LiveStatusResponse(
    string HealthStatus,         // "Healthy", "Warning", "Error"
    string? HealthMessage,
    DateTimeOffset? NextBuyTime,
    DateTimeOffset? LastPurchaseTime,
    decimal? LastPurchasePrice,
    decimal? LastPurchaseBtc,
    string? LastPurchaseTier
);

// Price chart data
public record PriceChartResponse(
    List<PricePointDto> Prices,
    List<PurchaseMarkerDto> Purchases,
    decimal AverageCostBasis
);

public record PricePointDto(string Date, decimal Price);

public record PurchaseMarkerDto(string Date, decimal Price, decimal BtcAmount, string Tier);
```

Then replace the placeholder content in `DashboardEndpoints.cs` with four endpoints. Keep the existing `ApiKeyEndpointFilter` class unchanged. Replace only the `DashboardEndpoints` class:

**1. GET /api/dashboard/portfolio** — Replace existing placeholder:
- Query all non-dry-run purchases with status Filled or PartiallyFilled using `AsNoTracking()`
- Calculate: TotalBtc (sum Quantity), TotalCost (sum Cost), AverageCostBasis (TotalCost/TotalBtc, or 0 if no purchases)
- Get current BTC price from `IHyperliquidClient.GetSpotPriceAsync("BTC/USDC")` — wrap in try/catch, use 0 on failure
- Calculate UnrealizedPnl: (CurrentPrice * TotalBtc) - TotalCost, and percentage: PnL/TotalCost * 100
- Get first/last purchase dates (min/max ExecutedAt)
- Return `PortfolioResponse`

**2. GET /api/dashboard/purchases?cursor={cursor}&pageSize=20&startDate={date}&endDate={date}** — NEW:
- Accept optional query params: `string? cursor`, `int pageSize = 20`, `DateOnly? startDate`, `DateOnly? endDate`
- Filter: non-dry-run, Filled or PartiallyFilled status
- Apply date range filters if provided (compare ExecutedAt against start/end)
- Cursor pagination: if cursor provided, parse as DateTimeOffset and filter `ExecutedAt < cursorDate`
- Order by ExecutedAt descending, Take(pageSize + 1) to check hasMore
- Map to `PurchaseDto` — MultiplierTier defaults to "Base" if null
- Return `PurchaseHistoryResponse` with nextCursor as last item's ExecutedAt.ToString("o")

**3. GET /api/dashboard/status** — NEW:
- Use `IServiceScopeFactory` to resolve `TradingBotDbContext` (endpoint runs in its own scope) — actually minimal API endpoints already get scoped DbContext so just inject directly
- Get last purchase (non-dry-run, Filled/PartiallyFilled, ordered by ExecutedAt desc, first or default)
- Calculate health status:
  - No purchases ever: "Warning" with message "No purchases recorded yet"
  - Last purchase > 36 hours ago: "Warning" with message "No purchase in {hours}h"
  - Otherwise: "Healthy" with message "Operating normally"
- Calculate next buy time from `IOptionsMonitor<DcaOptions>`:
  - Get DailyBuyHour and DailyBuyMinute from options
  - Compute next occurrence: today at that time UTC. If already passed, tomorrow at that time.
  - Return as DateTimeOffset
- Return `LiveStatusResponse`

**4. GET /api/dashboard/chart?timeframe=1M** — NEW:
- Accept `string timeframe = "1M"` query parameter
- Map timeframe to days: 7D→7, 1M→30, 3M→90, 6M→180, 1Y→365, All→3650 (10 years as max)
- Query `DailyPrices` where Symbol == "BTC", Date >= startDate, ordered by Date ascending, select Close price
- Map to `PricePointDto` with Date as "yyyy-MM-dd" string
- Query purchases within same date range (non-dry-run, Filled/PartiallyFilled), map to `PurchaseMarkerDto`
- Calculate average cost basis from ALL purchases (not just visible range)
- Return `PriceChartResponse`

All endpoints use `AsNoTracking()` for read-only optimization. Inject dependencies via parameter injection (minimal API pattern). Register all new routes in the MapDashboardEndpoints method under the existing group.
  </action>
  <verify>
Run `dotnet build TradingBot.ApiService` to confirm compilation. Verify DashboardEndpoints.cs contains MapGet for "/portfolio", "/purchases", "/status", and "/chart". Verify DashboardDtos.cs contains all 8 record types (PortfolioResponse, PurchaseHistoryResponse, PurchaseDto, LiveStatusResponse, PriceChartResponse, PricePointDto, PurchaseMarkerDto).
  </verify>
  <done>
Four API endpoints compile and are registered under /api/dashboard/ with proper DTOs. Portfolio returns aggregated stats with live price. Purchases supports cursor pagination with date filtering. Status returns health and next buy countdown. Chart returns time-series price data with purchase markers and average cost basis line.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.ApiService` compiles with 0 errors
2. `DashboardEndpoints.cs` has 4 MapGet calls: "/portfolio", "/purchases", "/status", "/chart"
3. `DashboardDtos.cs` exists with PortfolioResponse, PurchaseHistoryResponse, PurchaseDto, LiveStatusResponse, PriceChartResponse, PricePointDto, PurchaseMarkerDto
4. All endpoints use `AsNoTracking()` for read-only queries
5. Portfolio endpoint calls `GetSpotPriceAsync` for live price with try/catch fallback
6. Purchase history uses cursor-based pagination (not offset)
7. Status endpoint computes next buy time from DcaOptions
8. Chart endpoint supports timeframe parameter mapping to date range
</verification>

<success_criteria>
Backend API is complete: all four dashboard endpoints compile, use efficient queries (AsNoTracking, cursor pagination), and return structured DTOs that match the frontend's needs for portfolio stats, purchase history, live status, and price chart data.
</success_criteria>

<output>
After completion, create `.planning/phases/10-dashboard-core/10-01-SUMMARY.md`
</output>
