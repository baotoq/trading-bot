---
phase: 15-rich-aggregate-roots
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/BuildingBlocks/AggregateRoot.cs
  - TradingBot.ApiService/Models/Purchase.cs
  - TradingBot.ApiService/Application/Events/PurchaseCreatedEvent.cs
  - TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
  - TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs
  - TradingBot.ApiService/Application/Events/PurchaseSkippedEvent.cs
  - TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
  - TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
  - TradingBot.ApiService/Application/Services/DcaExecutionService.cs
autonomous: true
requirements: [DM-01, DM-02, DM-04]

must_haves:
  truths:
    - "AggregateRoot<TId> base class exists with AddDomainEvent() and ClearDomainEvents()"
    - "Purchase cannot be created via public constructor -- only Purchase.Create() factory method"
    - "Purchase properties have private setters -- no external property assignment"
    - "DcaExecutionService uses Purchase.Create() and behavior methods instead of object initializer"
    - "Domain events (PurchaseCompletedEvent, PurchaseFailedEvent) are raised inside Purchase behavior methods via AddDomainEvent() and dispatched from aggregate DomainEvents collection after SaveChanges"
    - "PurchaseCompletedEvent and PurchaseFailedEvent carry identity only (PurchaseId) -- handlers load aggregate from DB"
    - "All 53 existing tests pass without regression"
  artifacts:
    - path: "TradingBot.ApiService/BuildingBlocks/AggregateRoot.cs"
      provides: "AggregateRoot<TId> base class with domain event collection"
      contains: "AddDomainEvent"
    - path: "TradingBot.ApiService/Models/Purchase.cs"
      provides: "Purchase aggregate root with factory method and behavior methods that raise domain events"
      contains: "static Purchase Create"
    - path: "TradingBot.ApiService/Application/Events/PurchaseCreatedEvent.cs"
      provides: "Domain event for purchase creation (identity only)"
      contains: "PurchaseCreatedEvent"
    - path: "TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs"
      provides: "Domain event for purchase completion (identity only)"
      contains: "PurchaseCompletedEvent(PurchaseId"
    - path: "TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs"
      provides: "Domain event for purchase failure (identity only)"
      contains: "PurchaseFailedEvent(PurchaseId"
  key_links:
    - from: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      to: "TradingBot.ApiService/Models/Purchase.cs"
      via: "Purchase.Create() factory method"
      pattern: "Purchase\\.Create\\("
    - from: "TradingBot.ApiService/Models/Purchase.cs"
      to: "TradingBot.ApiService/BuildingBlocks/AggregateRoot.cs"
      via: "Inherits AggregateRoot<PurchaseId>"
      pattern: "AggregateRoot<PurchaseId>"
    - from: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      to: "TradingBot.ApiService/Models/Purchase.cs"
      via: "Dispatches domain events from purchase.DomainEvents after SaveChanges"
      pattern: "purchase\\.DomainEvents"
---

<objective>
Introduce AggregateRoot<TId> base class, refactor Purchase into a rich aggregate root with private constructor, static factory method, and behavior methods, and route all existing domain events through AddDomainEvent() for a clean single-pattern approach.

Purpose: Establish the DDD aggregate root pattern and apply it to Purchase -- the most critical domain entity. After this plan, no external code can construct or mutate Purchase through property assignment, and all domain events flow through the aggregate's event collection.

Output: AggregateRoot base class in BuildingBlocks, Purchase aggregate with Create() factory and RecordFill/RecordFailure/RecordDryRunFill behavior methods that raise domain events, identity-only events, DcaExecutionService dispatching from aggregate DomainEvents after SaveChanges.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-rich-aggregate-roots/15-RESEARCH.md
@.planning/phases/15-rich-aggregate-roots/15-CONTEXT.md
@TradingBot.ApiService/BuildingBlocks/BaseEntity.cs
@TradingBot.ApiService/BuildingBlocks/AuditedEntity.cs
@TradingBot.ApiService/BuildingBlocks/IDomainEvent.cs
@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/Application/Services/DcaExecutionService.cs
@TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
@TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs
@TradingBot.ApiService/Application/Events/PurchaseSkippedEvent.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AggregateRoot base class and refactor Purchase to rich aggregate</name>
  <files>
    TradingBot.ApiService/BuildingBlocks/AggregateRoot.cs
    TradingBot.ApiService/Models/Purchase.cs
    TradingBot.ApiService/Application/Events/PurchaseCreatedEvent.cs
  </files>
  <action>
**1. Create `AggregateRoot.cs` in BuildingBlocks (new file):**

```csharp
namespace TradingBot.ApiService.BuildingBlocks;

public abstract class AggregateRoot<TId> : BaseEntity<TId>
{
    private readonly List<IDomainEvent> _domainEvents = [];

    public IReadOnlyList<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    protected void AddDomainEvent(IDomainEvent domainEvent) =>
        _domainEvents.Add(domainEvent);

    public void ClearDomainEvents() => _domainEvents.Clear();
}
```

Key: `AddDomainEvent` is `protected` (only the aggregate calls it). `ClearDomainEvents` is `public` (infrastructure calls it after dispatch). `_domainEvents` is NOT mapped by EF Core (no EF config needed -- it's just an in-memory list).

**2. Create `PurchaseCreatedEvent.cs` in Application/Events (new file):**

```csharp
public record PurchaseCreatedEvent(PurchaseId PurchaseId) : IDomainEvent;
```

Events carry identity only per locked decision.

**3. Refactor `Purchase.cs` to be a rich aggregate root:**

- Change inheritance: `Purchase : AggregateRoot<PurchaseId>` (was `BaseEntity<PurchaseId>`)
- Add `protected Purchase() { }` parameterless constructor for EF Core materialization
- Change ALL property setters from `{ get; set; }` to `{ get; private set; }` (DM-04)
- Add a private constructor that takes all required parameters
- Add `static Purchase Create(...)` factory method that:
  - Takes value objects directly: `Symbol symbol, Price price, UsdAmount cost, Multiplier multiplier, string? multiplierTier, Percentage dropPercentage, decimal high30Day, decimal ma200Day, bool isDryRun`
  - Creates PurchaseId.New() internally
  - Sets `Status = PurchaseStatus.Pending`, `ExecutedAt = DateTimeOffset.UtcNow`, `Quantity = Quantity.From(0)`
  - Calls `AddDomainEvent(new PurchaseCreatedEvent(purchase.Id))`
  - Returns the Purchase

- Add behavior methods for post-creation mutation. Per locked decision "Refactor existing events now to use AggregateRoot.AddDomainEvent()", each behavior method raises the appropriate domain event:

  `RecordDryRunFill(Quantity quantity, Price price, UsdAmount actualCost)`:
  - Sets Quantity, Price, Cost, Status = Filled, OrderId = $"DRY-RUN-{Guid.NewGuid():N}", IsDryRun = true
  - Sets UpdatedAt = DateTimeOffset.UtcNow
  - Calls `AddDomainEvent(new PurchaseCompletedEvent(Id))`

  `RecordFill(Quantity quantity, Price avgPrice, UsdAmount actualCost, string orderId, decimal requestedQuantity)`:
  - Sets Quantity, Price, Cost, OrderId
  - Status = filledQty >= requestedQuantity * 0.95m ? Filled : PartiallyFilled
  - Sets UpdatedAt = DateTimeOffset.UtcNow
  - Calls `AddDomainEvent(new PurchaseCompletedEvent(Id))`

  `RecordResting(string orderId)`:
  - Sets OrderId, Status = PartiallyFilled, FailureReason = "Order resting instead of filling (IOC should not rest)"
  - Sets UpdatedAt = DateTimeOffset.UtcNow
  - Calls `AddDomainEvent(new PurchaseFailedEvent(Id))`

  `RecordFailure(string reason, string? rawResponse = null)`:
  - Sets Status = Failed, FailureReason, RawResponse
  - Sets UpdatedAt = DateTimeOffset.UtcNow
  - Calls `AddDomainEvent(new PurchaseFailedEvent(Id))`

  `SetRawResponse(string rawResponse)`:
  - Sets RawResponse (needed for the full order response after fill/resting)
  - Sets UpdatedAt = DateTimeOffset.UtcNow

IMPORTANT: The `PurchaseStatus` enum and `MultiplierTierData` record stay in the same file (no move needed). Keep `Symbol` as a property from the existing entity -- check if Purchase already has a Symbol column in the DB. Looking at current code, Purchase does NOT have a Symbol property. Do NOT add one now -- it would require a migration. The factory method should NOT take a Symbol parameter since it is not persisted on Purchase. Remove Symbol from the factory method signature.
  </action>
  <verify>
Run `dotnet build TradingBot.sln` from repository root. Expect compile errors ONLY in DcaExecutionService.cs (which still uses object initializer syntax). All other files should compile clean.
  </verify>
  <done>
AggregateRoot base class exists with domain event collection. Purchase inherits AggregateRoot, has private setters, protected parameterless constructor, factory method, and behavior methods. PurchaseCreatedEvent exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor existing events to identity-only, update DcaExecutionService to use aggregate API and dispatch from DomainEvents</name>
  <files>
    TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
    TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs
    TradingBot.ApiService/Application/Events/PurchaseSkippedEvent.cs
    TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
    TradingBot.ApiService/Application/Handlers/PurchaseFailedHandler.cs
    TradingBot.ApiService/Application/Services/DcaExecutionService.cs
  </files>
  <action>
Per locked decision: "Refactor existing events now to use AggregateRoot.AddDomainEvent() -- clean break, single pattern going forward" and "Events carry identity only (aggregate ID)".

**1. Change PurchaseCompletedEvent to identity-only:**

Replace the entire record with:
```csharp
public record PurchaseCompletedEvent(PurchaseId PurchaseId) : IDomainEvent;
```

Remove all the rich data fields (BtcAmount, Price, UsdSpent, RemainingUsdc, CurrentBtcBalance, ExecutedAt, Multiplier, MultiplierTier, DropPercentage, High30Day, Ma200Day, IsDryRun). Handlers load the Purchase from DB per identity-only convention.

**2. Change PurchaseFailedEvent to identity-only:**

Replace the entire record with:
```csharp
public record PurchaseFailedEvent(PurchaseId PurchaseId) : IDomainEvent;
```

Remove ErrorType, ErrorMessage, RetryCount, FailedAt fields.

**3. PurchaseSkippedEvent stays as-is:**

PurchaseSkippedEvent is published when no Purchase aggregate exists (early returns for insufficient balance, already purchased, etc.). Since there is no aggregate to accumulate it on, it remains published directly via `IPublisher.Publish()` with its current rich data. This is the correct DDD approach -- skip events are application-level, not aggregate domain events.

**4. Update PurchaseCompletedHandler to load Purchase from DB:**

The handler currently reads all data from the event. Refactor it to:
- Inject `TradingBotDbContext` (already injected)
- Load the Purchase by ID: `var purchase = await dbContext.Purchases.FindAsync(notification.PurchaseId);`
- Guard: if purchase is null, log warning and return
- Replace all `notification.X` references with `purchase.X` (e.g., `notification.BtcAmount` -> `purchase.Quantity`, `notification.Price` -> `purchase.Price`, `notification.UsdSpent` -> `purchase.Cost`, `notification.IsDryRun` -> `purchase.IsDryRun`)
- For `RemainingUsdc` and `CurrentBtcBalance`: these were fetched in DcaExecutionService and passed through the event. Now the handler must fetch `RemainingUsdc` itself via `HyperliquidClient.GetBalancesAsync()`. Add `HyperliquidClient` to the handler's primary constructor. For `CurrentBtcBalance`, use `purchase.Quantity` (same as before -- the TODO comment says Phase 4 will track actual balance).
- The `BuildMultiplierReasoning` private method changes from taking `PurchaseCompletedEvent` to taking `Purchase`. Update all field references: `e.BtcAmount` -> `p.Quantity`, `e.Price` -> `p.Price`, `e.Multiplier` -> `p.Multiplier`, `e.MultiplierTier` -> `p.MultiplierTier`, `e.DropPercentage` -> `p.DropPercentage`, `e.High30Day` -> `p.High30Day`, `e.Ma200Day` -> `p.Ma200Day`.

**5. Update PurchaseFailedHandler to load Purchase from DB:**

- Add `TradingBotDbContext` to the handler's primary constructor
- Load the Purchase by ID: `var purchase = await dbContext.Purchases.FindAsync(notification.PurchaseId);`
- Guard: if purchase is null, log warning and return
- Replace `notification.ErrorType` with `"OrderFailed"` (hardcoded -- the handler knows it's a failure)
- Replace `notification.ErrorMessage` with `purchase.FailureReason ?? "Unknown error"`
- Replace `notification.RetryCount` with `0` (retries handled at scheduler level, same as current)
- Replace `notification.FailedAt` with `purchase.UpdatedAt` (the timestamp when failure was recorded)

**6. Refactor DcaExecutionService.ExecuteDailyPurchaseAsync:**

Replace the `new Purchase { ... }` block (Step 6) with:
```csharp
var purchase = Purchase.Create(
    price: currentPrice,
    cost: UsdAmount.From(usdAmount.Value),
    multiplier: multiplierResult.Multiplier,
    multiplierTier: multiplierResult.Tier,
    dropPercentage: multiplierResult.DropPercentage,
    high30Day: multiplierResult.High30Day,
    ma200Day: multiplierResult.Ma200Day,
    isDryRun: options.DryRun);
```

**Dry-run path:**
```csharp
purchase.RecordDryRunFill(
    Quantity.From(roundedQuantity),
    currentPrice,
    UsdAmount.From(roundedQuantity * currentPriceDecimal));
```

**Live order fill path:**
```csharp
purchase.RecordFill(
    Quantity.From(filledQty),
    Price.From(avgPrice),
    UsdAmount.From(filledQty * avgPrice),
    filled.Oid.ToString(),
    roundedQuantity);
```

**Resting path:** `purchase.RecordResting(status.Resting.Oid.ToString());`

**No fill/resting path:** `purchase.RecordFailure("No fill or resting status in order response");`

**Catch block:** `purchase.RecordFailure(ex.Message, ex.Message);`

**Raw response (inside else block for live orders):** `purchase.SetRawResponse(JsonSerializer.Serialize(orderResponse));`

**7. Replace Step 8 (domain event dispatch) with aggregate-based dispatch:**

Remove the entire Step 8 block (the `if (purchase.Status == Filled || PartiallyFilled)` with `publisher.Publish(new PurchaseCompletedEvent(...))` and the `else` with `publisher.Publish(new PurchaseFailedEvent(...))`).

Replace with dispatch from aggregate DomainEvents collection:
```csharp
// Step 8: Dispatch domain events accumulated by aggregate behavior methods
foreach (var domainEvent in purchase.DomainEvents)
{
    await publisher.Publish(domainEvent, ct);
}
purchase.ClearDomainEvents();
```

This dispatches ALL events the aggregate accumulated (PurchaseCreatedEvent from Create(), plus PurchaseCompletedEvent or PurchaseFailedEvent from the behavior method). The PurchaseSkippedEvent calls earlier in the method (Steps 2-4 early returns) remain as direct `publisher.Publish()` calls since no aggregate exists at those points.

Keep the `IPublisher publisher` dependency (still needed for both aggregate event dispatch and PurchaseSkippedEvent).

**Note on Phase 17:** The interceptor that auto-dispatches from SaveChanges is deferred to Phase 17. This phase wires manual accumulation + dispatch loop in the service.
  </action>
  <verify>
1. Run `dotnet build TradingBot.sln` -- must compile with zero errors
2. Run `dotnet test` from repository root -- all 53 tests must pass
3. Verify no inline PurchaseCompletedEvent/PurchaseFailedEvent construction in DcaExecutionService: `grep "new PurchaseCompletedEvent\|new PurchaseFailedEvent" TradingBot.ApiService/Application/Services/DcaExecutionService.cs` should return zero matches
4. Verify dispatch loop exists: `grep "purchase.DomainEvents" TradingBot.ApiService/Application/Services/DcaExecutionService.cs` should return a match
  </verify>
  <done>
DcaExecutionService creates Purchase via Purchase.Create() factory method. All post-creation state changes go through behavior methods that raise identity-only domain events via AddDomainEvent(). After SaveChanges, events are dispatched from purchase.DomainEvents collection and cleared. PurchaseCompletedEvent and PurchaseFailedEvent carry PurchaseId only -- handlers load from DB. PurchaseSkippedEvent stays as direct publish (no aggregate). No direct property assignment on Purchase anywhere in the service. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` compiles with zero errors
2. `dotnet test` passes all 53 tests
3. `grep -r "new Purchase" TradingBot.ApiService/` returns zero matches (no direct construction)
4. `grep -r "purchase\.\w\+ =" TradingBot.ApiService/Application/Services/DcaExecutionService.cs` returns zero matches (no direct property assignment)
5. AggregateRoot.cs exists in BuildingBlocks with AddDomainEvent and ClearDomainEvents
6. Purchase.cs has `private set` on all properties
7. `grep "new PurchaseCompletedEvent\|new PurchaseFailedEvent" TradingBot.ApiService/Application/Services/DcaExecutionService.cs` returns zero matches (events raised inside aggregate, not constructed in service)
8. `grep "purchase.DomainEvents" TradingBot.ApiService/Application/Services/DcaExecutionService.cs` returns a match (dispatch loop exists)
9. PurchaseCompletedEvent.cs contains only PurchaseId parameter (identity-only)
10. PurchaseFailedEvent.cs contains only PurchaseId parameter (identity-only)
</verification>

<success_criteria>
- AggregateRoot<TId> base class exists with domain event collection (AddDomainEvent, ClearDomainEvents, DomainEvents)
- Purchase inherits AggregateRoot<PurchaseId> (not BaseEntity)
- Purchase has protected parameterless constructor and static Create() factory
- All Purchase properties use `{ get; private set; }`
- DcaExecutionService uses Purchase.Create() and behavior methods exclusively
- PurchaseCreatedEvent, PurchaseCompletedEvent, PurchaseFailedEvent are all identity-only (PurchaseId)
- Behavior methods raise domain events via AddDomainEvent() -- single pattern, no inline event construction in service
- DcaExecutionService dispatches events from purchase.DomainEvents after SaveChanges, then clears
- PurchaseSkippedEvent stays as direct IPublisher.Publish() (no aggregate exists at skip points)
- Handlers load Purchase from DB when they need rich data
- All 53 existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-rich-aggregate-roots/15-01-SUMMARY.md`
</output>
