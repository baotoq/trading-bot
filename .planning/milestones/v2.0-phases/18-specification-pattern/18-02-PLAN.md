---
phase: 18-specification-pattern
plan: 02
type: execute
wave: 2
depends_on:
  - 18-01
files_modified:
  - TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
  - TradingBot.ApiService/Application/BackgroundJobs/WeeklySummaryService.cs
  - TradingBot.ApiService/Application/BackgroundJobs/MissedPurchaseVerificationService.cs
autonomous: true
requirements:
  - QP-03

must_haves:
  truths:
    - "Purchase history endpoint uses composable specs instead of inline LINQ for its 5 dynamic filters"
    - "Price chart endpoint uses DailyPriceByDateRangeSpec for prices and PurchaseFilledStatusSpec for purchase markers"
    - "Portfolio endpoint uses PurchaseFilledStatusSpec instead of inline Where clause"
    - "Live status endpoint uses PurchaseFilledStatusSpec + PurchasesOrderedByDateSpec instead of inline LINQ"
    - "WeeklySummaryService uses PurchaseFilledStatusSpec + PurchaseDateRangeSpec instead of inline Where chains"
    - "MissedPurchaseVerificationService uses PurchaseFilledStatusSpec + PurchaseDateRangeSpec instead of inline Where chains"
    - "Pagination (Take, cursor hasMore) stays at endpoint level, not inside specs"
    - "DTO projection (.Select) stays at endpoint level, not inside specs"
    - "Aggregate queries (GroupBy + Sum in WeeklySummaryService) stay as inline LINQ"
  artifacts:
    - path: "TradingBot.ApiService/Endpoints/DashboardEndpoints.cs"
      provides: "All dashboard endpoints refactored to use specs"
      contains: "WithSpecification"
    - path: "TradingBot.ApiService/Application/BackgroundJobs/WeeklySummaryService.cs"
      provides: "Weekly summary using specs for purchase queries"
      contains: "WithSpecification"
    - path: "TradingBot.ApiService/Application/BackgroundJobs/MissedPurchaseVerificationService.cs"
      provides: "Missed purchase verification using specs"
      contains: "WithSpecification"
  key_links:
    - from: "TradingBot.ApiService/Endpoints/DashboardEndpoints.cs"
      to: "TradingBot.ApiService/Application/Specifications/Purchases/*"
      via: "WithSpecification chaining at call site"
      pattern: "WithSpecification.*new Purchase"
    - from: "TradingBot.ApiService/Endpoints/DashboardEndpoints.cs"
      to: "TradingBot.ApiService/Application/Specifications/DailyPrices/*"
      via: "WithSpecification for chart query"
      pattern: "WithSpecification.*new DailyPrice"
---

<objective>
Replace complex inline LINQ queries in dashboard endpoints and background services with composable spec composition using WithSpecification chaining.

Purpose: Move query logic from scattered inline LINQ into reusable spec call-site composition, making queries declarative and testable (QP-03).
Output: All complex queries in DashboardEndpoints.cs, WeeklySummaryService.cs, and MissedPurchaseVerificationService.cs use specs.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-specification-pattern/18-01-SUMMARY.md

@TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
@TradingBot.ApiService/Endpoints/DashboardDtos.cs
@TradingBot.ApiService/Application/BackgroundJobs/WeeklySummaryService.cs
@TradingBot.ApiService/Application/BackgroundJobs/MissedPurchaseVerificationService.cs
@TradingBot.ApiService/Application/Specifications/SpecificationExtensions.cs
@TradingBot.ApiService/Application/Specifications/Purchases/PurchaseFilledStatusSpec.cs
@TradingBot.ApiService/Application/Specifications/Purchases/PurchaseDateRangeSpec.cs
@TradingBot.ApiService/Application/Specifications/Purchases/PurchaseTierFilterSpec.cs
@TradingBot.ApiService/Application/Specifications/Purchases/PurchaseCursorSpec.cs
@TradingBot.ApiService/Application/Specifications/Purchases/PurchasesOrderedByDateSpec.cs
@TradingBot.ApiService/Application/Specifications/DailyPrices/DailyPriceByDateRangeSpec.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor DashboardEndpoints to use composable specs</name>
  <files>
    TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
  </files>
  <action>
Add `using TradingBot.ApiService.Application.Specifications;` and the Purchases/DailyPrices sub-namespaces to DashboardEndpoints.cs. Then refactor each endpoint:

**1. GetPurchaseHistoryAsync (primary target -- 5 dynamic filters):**

Replace the inline LINQ chain (lines 79-123) with composable spec chaining:

```csharp
var query = db.Purchases
    .WithSpecification(new PurchaseFilledStatusSpec())
    .WithSpecification(new PurchasesOrderedByDateSpec());

if (startDate.HasValue)
{
    query = query.WithSpecification(new PurchaseDateRangeSpec(
        startDate.Value, endDate ?? DateOnly.MaxValue));
}

if (!string.IsNullOrEmpty(tier))
{
    query = query.WithSpecification(new PurchaseTierFilterSpec(tier));
}

if (!string.IsNullOrEmpty(cursor) && DateTimeOffset.TryParse(cursor, out var cursorDate))
{
    query = query.WithSpecification(new PurchaseCursorSpec(cursorDate));
}
```

Keep the existing pagination logic (Take, pageSize+1, hasMore) and .Select() projection EXACTLY as-is -- those stay at endpoint level per locked decision.

**2. GetPortfolioAsync:**

Replace lines 30-33 inline LINQ with:
```csharp
var purchases = await db.Purchases
    .WithSpecification(new PurchaseFilledStatusSpec())
    .WithSpecification(new PurchasesOrderedByDateSpec())
    .ToListAsync(ct);
```
(PurchasesOrderedByDateSpec provides AsNoTracking; PurchaseFilledStatusSpec provides the Where filter.)

**3. GetLiveStatusAsync:**

Replace lines 143-147 inline LINQ with:
```csharp
var lastPurchase = await db.Purchases
    .WithSpecification(new PurchaseFilledStatusSpec())
    .WithSpecification(new PurchasesOrderedByDateSpec())
    .FirstOrDefaultAsync(ct);
```

**4. GetPriceChartAsync:**

4a. DailyPrices query (lines 212-220): Replace with:
```csharp
var prices = await db.DailyPrices
    .WithSpecification(new DailyPriceByDateRangeSpec(Symbol.Btc, startDate))
    .Select(dp => new PricePointDto(...))
    .ToListAsync(ct);
```

4b. Purchase markers query (lines 222-234): Replace inline Where chain with:
```csharp
var purchases = await db.Purchases
    .WithSpecification(new PurchaseFilledStatusSpec())
    .Where(p => DateOnly.FromDateTime(p.ExecutedAt.DateTime) >= startDate)
    .OrderBy(p => p.ExecutedAt)
    .AsNoTracking()
    .Select(p => new PurchaseMarkerDto(...))
    .ToListAsync(ct);
```
Note: The date filter here uses `DateOnly.FromDateTime(p.ExecutedAt.DateTime)` which is different from PurchaseDateRangeSpec's DateTimeOffset comparison. Keep this as a plain `.Where()` chained after the spec to avoid creating a one-off spec for a different comparison pattern.

4c. All purchases for avg cost (lines 236-239): Replace with:
```csharp
var allPurchases = await db.Purchases
    .WithSpecification(new PurchaseFilledStatusSpec())
    .WithSpecification(new PurchasesOrderedByDateSpec())
    .ToListAsync(ct);
```

Preserve ALL existing DTO projection (.Select), pagination (.Take, hasMore), and aggregation logic (.Sum, .Count) exactly as-is.

Verify build and existing tests: `dotnet build TradingBot.sln && dotnet test`
  </action>
  <verify>
    `dotnet build TradingBot.sln` succeeds. `dotnet test` passes (all 53 existing tests). Each endpoint method in DashboardEndpoints.cs uses WithSpecification calls instead of inline .Where for the common filters.
  </verify>
  <done>
    All 5 dashboard endpoints use composable specs. GetPurchaseHistoryAsync chains up to 4 specs dynamically. Other endpoints reuse PurchaseFilledStatusSpec. Pagination and projection remain at call sites.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor background services to use composable specs</name>
  <files>
    TradingBot.ApiService/Application/BackgroundJobs/WeeklySummaryService.cs
    TradingBot.ApiService/Application/BackgroundJobs/MissedPurchaseVerificationService.cs
  </files>
  <action>
Add `using TradingBot.ApiService.Application.Specifications;` and sub-namespaces to both services.

**1. WeeklySummaryService.ProcessAsync:**

Replace the weekly purchases query (lines 60-65) with:
```csharp
var weekStart = GetMondayOfWeek(today);
var purchases = await dbContext.Purchases
    .WithSpecification(new PurchaseFilledStatusSpec())
    .WithSpecification(new PurchaseDateRangeSpec(weekStart, today))
    .OrderBy(p => p.ExecutedAt)
    .ToListAsync(cancellationToken);
```
Note: PurchaseDateRangeSpec provides the date filter; OrderBy(ascending) is applied at call site since the spec doesn't include ordering.

The lifetime totals query (lines 68-78) stays as inline LINQ -- it uses GroupBy + Sum which is an aggregate query explicitly locked out of spec pattern.

**2. MissedPurchaseVerificationService.ProcessAsync:**

Replace the today-purchase query (lines 67-71) with:
```csharp
var todayPurchase = await dbContext.Purchases
    .WithSpecification(new PurchaseFilledStatusSpec())
    .WithSpecification(new PurchaseDateRangeSpec(today, today))
    .FirstOrDefaultAsync(cancellationToken);
```
This uses PurchaseDateRangeSpec with same start/end date to filter to "today only."

The failed-purchase diagnostic query (lines 82-86) stays as inline LINQ -- it filters on `PurchaseStatus.Failed` which is a different status than PurchaseFilledStatusSpec provides, and it's a simple 3-condition query (moderate complexity, locked out of spec pattern).

Verify build and tests: `dotnet build TradingBot.sln && dotnet test`
  </action>
  <verify>
    `dotnet build TradingBot.sln` succeeds. `dotnet test` passes. WeeklySummaryService and MissedPurchaseVerificationService use WithSpecification for the filled-purchase queries. Aggregate queries (GroupBy) remain as inline LINQ.
  </verify>
  <done>
    Both background services use composable specs for their purchase queries. Aggregate queries and simple diagnostic queries remain as inline LINQ per locked decisions.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` -- clean build
2. `dotnet test` -- all 53 existing tests pass
3. DashboardEndpoints.cs: every complex purchase query uses WithSpecification, no inline `.Where(p => !p.IsDryRun && ...)` remains for filled-status filtering
4. DashboardEndpoints.cs: `.Select()` and `.Take()` remain at call site (not in specs)
5. WeeklySummaryService: purchases query uses WithSpecification; GroupBy + Sum stays inline
6. MissedPurchaseVerificationService: today-purchase query uses WithSpecification; failed-purchase diagnostic stays inline
7. GetPriceChartAsync: DailyPrices query uses DailyPriceByDateRangeSpec
</verification>

<success_criteria>
- All complex dashboard queries use composable specs (QP-03)
- Pagination and projection remain at endpoint level
- Aggregate queries (GroupBy + Sum) remain as inline LINQ
- Solution builds and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-specification-pattern/18-02-SUMMARY.md`
</output>
