---
phase: 18-specification-pattern
plan: 03
type: execute
wave: 2
depends_on:
  - 18-01
files_modified:
  - tests/TradingBot.ApiService.Tests/TradingBot.ApiService.Tests.csproj
  - tests/TradingBot.ApiService.Tests/Application/Specifications/PostgresFixture.cs
  - tests/TradingBot.ApiService.Tests/Application/Specifications/Purchases/PurchaseSpecsTests.cs
  - tests/TradingBot.ApiService.Tests/Application/Specifications/DailyPrices/DailyPriceSpecsTests.cs
autonomous: true
requirements:
  - QP-02

must_haves:
  truths:
    - "TestContainers.PostgreSql is installed in the test project"
    - "PostgresFixture starts a real PostgreSQL container and runs EF Core migrations"
    - "Spec integration tests execute against real PostgreSQL, not in-memory provider"
    - "Each spec's LINQ expression translates to server-side SQL without client-side evaluation"
    - "Vogen value object comparisons work correctly in spec predicates (Symbol, Price, etc.)"
    - "Composable spec chaining produces correct filtered results"
  artifacts:
    - path: "tests/TradingBot.ApiService.Tests/Application/Specifications/PostgresFixture.cs"
      provides: "IAsyncLifetime container fixture with TradingBotDbContext factory"
      contains: "PostgreSqlContainer"
    - path: "tests/TradingBot.ApiService.Tests/Application/Specifications/Purchases/PurchaseSpecsTests.cs"
      provides: "Integration tests for all Purchase specs"
      contains: "PurchaseFilledStatusSpec"
    - path: "tests/TradingBot.ApiService.Tests/Application/Specifications/DailyPrices/DailyPriceSpecsTests.cs"
      provides: "Integration tests for DailyPrice specs"
      contains: "DailyPriceByDateRangeSpec"
  key_links:
    - from: "tests/TradingBot.ApiService.Tests/Application/Specifications/PostgresFixture.cs"
      to: "TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs"
      via: "DbContextOptionsBuilder<TradingBotDbContext>"
      pattern: "TradingBotDbContext"
    - from: "tests/TradingBot.ApiService.Tests/Application/Specifications/Purchases/PurchaseSpecsTests.cs"
      to: "TradingBot.ApiService/Application/Specifications/Purchases/*"
      via: "WithSpecification extension"
      pattern: "WithSpecification"
---

<objective>
Create integration tests using TestContainers with real PostgreSQL to verify that all specifications translate to server-side SQL and produce correct results with Vogen value objects.

Purpose: Prove QP-02 (specs translate to server-side SQL, no client-side evaluation) by running specs against real PostgreSQL with full EF Core migrations applied, including Vogen value converters.
Output: PostgresFixture, Purchase spec tests, DailyPrice spec tests -- all passing against real Postgres.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-specification-pattern/18-01-SUMMARY.md
@.planning/phases/18-specification-pattern/18-RESEARCH.md

@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/Models/DailyPrice.cs
@TradingBot.ApiService/Application/Specifications/SpecificationExtensions.cs
@TradingBot.ApiService/Application/Specifications/Purchases/PurchaseFilledStatusSpec.cs
@TradingBot.ApiService/Application/Specifications/Purchases/PurchaseDateRangeSpec.cs
@TradingBot.ApiService/Application/Specifications/Purchases/PurchaseTierFilterSpec.cs
@TradingBot.ApiService/Application/Specifications/Purchases/PurchaseCursorSpec.cs
@TradingBot.ApiService/Application/Specifications/Purchases/PurchasesOrderedByDateSpec.cs
@TradingBot.ApiService/Application/Specifications/DailyPrices/DailyPriceByDateRangeSpec.cs
@tests/TradingBot.ApiService.Tests/TradingBot.ApiService.Tests.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install TestContainers and create PostgresFixture</name>
  <files>
    tests/TradingBot.ApiService.Tests/TradingBot.ApiService.Tests.csproj
    tests/TradingBot.ApiService.Tests/Application/Specifications/PostgresFixture.cs
  </files>
  <action>
1. Add TestContainers.PostgreSql to the test project:
   ```bash
   cd tests/TradingBot.ApiService.Tests && dotnet add package Testcontainers.PostgreSql --version 4.10.0
   ```

2. Create `Application/Specifications/PostgresFixture.cs`:
   - `public sealed class PostgresFixture : IAsyncLifetime`
   - Private field: `PostgreSqlContainer _container` built from `new PostgreSqlBuilder().WithDatabase("tradingbot_test").WithUsername("test").WithPassword("test").Build()`
   - Public method `CreateDbContext()` returns `TradingBotDbContext`:
     ```csharp
     var options = new DbContextOptionsBuilder<TradingBotDbContext>()
         .UseNpgsql(_container.GetConnectionString())
         .EnableSensitiveDataLogging()  // For SQL verification during debugging
         .LogTo(Console.WriteLine, Microsoft.Extensions.Logging.LogLevel.Information)
         .Options;
     return new TradingBotDbContext(options);
     ```
   - CRITICAL: Use the real `TradingBotDbContext` constructor (not a subclass) so all `ConfigureConventions` Vogen converters are applied (per research pitfall #1)
   - `InitializeAsync()`: start container, create context, call `await context.Database.MigrateAsync()`
   - `DisposeAsync()`: `_container.DisposeAsync().AsTask()`
   - Namespace: `TradingBot.ApiService.Tests.Application.Specifications`

   Import namespaces:
   - `using Testcontainers.PostgreSql;`
   - `using Microsoft.EntityFrameworkCore;`
   - `using TradingBot.ApiService.Infrastructure.Data;`

3. Verify build: `dotnet build tests/TradingBot.ApiService.Tests/TradingBot.ApiService.Tests.csproj`
  </action>
  <verify>
    Test project builds. PostgresFixture.cs compiles. TestContainers.PostgreSql is in the test csproj.
  </verify>
  <done>
    PostgresFixture with IAsyncLifetime lifecycle, real PostgreSQL container, and TradingBotDbContext factory exists and compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Purchase and DailyPrice spec integration tests</name>
  <files>
    tests/TradingBot.ApiService.Tests/Application/Specifications/Purchases/PurchaseSpecsTests.cs
    tests/TradingBot.ApiService.Tests/Application/Specifications/DailyPrices/DailyPriceSpecsTests.cs
  </files>
  <action>
Create integration test classes using `IClassFixture<PostgresFixture>`. Each test:
1. Gets a fresh DbContext from fixture
2. Seeds test data using Purchase.Create() factory / DailyPrice entity
3. Calls SaveChangesAsync
4. Runs spec query via `.WithSpecification(spec).ToListAsync()`
5. Asserts correct filtering using FluentAssertions

**PurchaseSpecsTests.cs** (in `Application/Specifications/Purchases/`):

Test class: `public class PurchaseSpecsTests : IClassFixture<PostgresFixture>`

Helper method to create test purchases: Use `Purchase.Create(...)` factory with test values. For variety, create purchases with different statuses, dates, tiers, dry-run flags.

Seed data pattern (in a private helper or each test):
- Purchase A: Filled, Jan 15 2024, tier "5% Drop", not dry-run
- Purchase B: Filled, Feb 10 2024, tier "Base"(null), not dry-run
- Purchase C: Failed, Jan 20 2024, not dry-run
- Purchase D: Filled, Jan 25 2024, dry-run (IsDryRun=true)
- Purchase E: PartiallyFilled, Mar 5 2024, tier "10% Drop", not dry-run

IMPORTANT: Purchase.Create() creates with Status=Pending. To set Status=Filled, call `purchase.RecordFill(...)` or `purchase.RecordDryRunFill(...)` after creation. For Failed, call `purchase.RecordFailure(...)`. Check Purchase.cs for the correct method signatures. ClearDomainEvents() after factory/behavior methods to avoid SaveChangesInterceptor issues in tests (interceptor may try to dispatch events).

Tests (one per spec + one for composition):

1. `PurchaseFilledStatusSpec_ExcludesDryRunAndFailedPurchases`:
   - Seed A, B, C, D, E
   - Apply PurchaseFilledStatusSpec
   - Assert: returns A, B, E (filled/partially-filled, not dry-run)
   - Assert: C (failed) and D (dry-run) excluded

2. `PurchaseDateRangeSpec_FiltersToDateRange`:
   - Seed purchases across Jan-Mar 2024
   - Apply PurchaseDateRangeSpec(Jan 1, Jan 31)
   - Assert: only purchases in January returned

3. `PurchaseTierFilterSpec_FiltersByTier`:
   - Seed purchases with different tiers
   - Apply PurchaseTierFilterSpec("5% Drop")
   - Assert: only "5% Drop" tier purchases returned

4. `PurchaseTierFilterSpec_HandlesBaseTier`:
   - Seed purchases with null tier and "Base" tier
   - Apply PurchaseTierFilterSpec("Base")
   - Assert: both null-tier and "Base"-tier purchases returned

5. `PurchaseCursorSpec_FiltersBeforeCursorAndSortsDescending`:
   - Seed purchases at known dates
   - Apply PurchaseCursorSpec with a cursor date
   - Assert: only purchases before cursor, ordered descending

6. `PurchasesOrderedByDateSpec_SortsDescendingWithNoTracking`:
   - Seed multiple purchases
   - Apply PurchasesOrderedByDateSpec
   - Assert: results ordered by ExecutedAt descending

7. `ComposedSpecs_FilledStatusAndDateRange_WorkTogether`:
   - Seed diverse purchases (mix of status, dates, dry-run)
   - Chain PurchaseFilledStatusSpec + PurchaseDateRangeSpec
   - Assert: only filled, non-dry-run purchases within date range

**DailyPriceSpecsTests.cs** (in `Application/Specifications/DailyPrices/`):

Test class: `public class DailyPriceSpecsTests : IClassFixture<PostgresFixture>`

Seed DailyPrice entities directly (DailyPrice uses public setters, no factory):
- DailyPrice for BTC, Jan 1-31 2024 (multiple days)
- DailyPrice for BTC, Feb 1-28 2024

Tests:

8. `DailyPriceByDateRangeSpec_FiltersBySymbolAndDate`:
   - Seed BTC prices for Jan + Feb
   - Apply DailyPriceByDateRangeSpec(Symbol.Btc, Jan 15 start date)
   - Assert: only BTC prices from Jan 15 onward, ordered ascending by Date

9. `DailyPriceByDateRangeSpec_VogenSymbolComparisonWorks`:
   - Verify that `Symbol.Btc` comparison in the spec works correctly through Vogen EF Core converter
   - This directly validates research open question #1

IMPORTANT per-test data isolation: Each test should use unique date ranges or add/remove data carefully. Since all tests share the same PostgreSQL container and schema, either:
- Use unique date ranges per test that don't overlap, OR
- Clean up test data after each test (simpler: delete seeded entities in a finally block or use transactions that rollback)

Recommended approach: wrap each test body in a transaction scope that rolls back:
```csharp
await using var db = _fixture.CreateDbContext();
await using var transaction = await db.Database.BeginTransactionAsync();
// seed + test...
await transaction.RollbackAsync();
```

Verify all tests pass: `dotnet test`
  </action>
  <verify>
    `dotnet test` passes all tests (existing 53 + new integration tests). TestContainers spins up PostgreSQL, migrations run, specs execute against real database, all assertions pass.
  </verify>
  <done>
    9 integration tests verify all specs against real PostgreSQL. Vogen value object comparisons confirmed working in LINQ expressions. Composable spec chaining produces correct filtered results. QP-02 (server-side SQL translation) proven by successful execution against real Postgres.
  </done>
</task>

</tasks>

<verification>
1. `dotnet test` -- all tests pass (existing + new integration tests)
2. PostgresFixture uses real `TradingBotDbContext` (same ConfigureConventions, same Vogen converters)
3. Each Purchase spec has at least one integration test
4. DailyPriceByDateRangeSpec tested with Vogen Symbol comparison
5. Composable spec chaining tested (at least one test chains 2+ specs)
6. No client-side evaluation warnings in test output (specs translate to SQL)
7. Test data isolation works (tests don't interfere with each other)
</verification>

<success_criteria>
- TestContainers.PostgreSql 4.10.0 installed in test project
- PostgresFixture starts PostgreSQL, runs migrations, creates TradingBotDbContext
- 7+ Purchase spec integration tests pass against real Postgres
- 2+ DailyPrice spec integration tests pass against real Postgres
- Vogen value object comparisons verified working in spec predicates
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-specification-pattern/18-03-SUMMARY.md`
</output>
