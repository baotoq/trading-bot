---
phase: 14-value-objects
plan: 02
type: execute
wave: 2
depends_on:
  - 14-01
files_modified:
  - TradingBot.ApiService/Models/Ids/VogenGlobalConfig.cs
  - TradingBot.ApiService/Configuration/DcaOptions.cs
  - TradingBot.ApiService/Application/Services/MultiplierCalculator.cs
  - TradingBot.ApiService/Application/Services/BacktestSimulator.cs
  - TradingBot.ApiService/Application/Services/Backtest/BacktestConfig.cs
  - TradingBot.ApiService/Application/Services/Backtest/DailyPriceData.cs
  - TradingBot.ApiService/Application/Services/Backtest/PurchaseLogEntry.cs
  - TradingBot.ApiService/Application/Services/Backtest/BacktestResult.cs
  - TradingBot.ApiService/Application/Services/DcaExecutionService.cs
  - TradingBot.ApiService/Application/Services/PriceDataService.cs
  - TradingBot.ApiService/Application/Services/ConfigurationService.cs
  - TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
  - TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
  - TradingBot.ApiService/appsettings.json
  - tests/TradingBot.ApiService.Tests/Application/Services/MultiplierCalculatorTests.cs
autonomous: true
requirements:
  - TS-02
  - TS-03
  - TS-04

must_haves:
  truths:
    - "DcaOptions binds from appsettings.json with value object fields (BaseDailyAmount as UsdAmount, BearBoostFactor as Multiplier)"
    - "MultiplierCalculator.Calculate accepts and returns value objects (Price, UsdAmount, Multiplier, Percentage)"
    - "BacktestSimulator.Run works with value object types and produces correct results"
    - "DcaExecutionService orchestrates purchases using value objects throughout the flow"
    - "PriceDataService returns decimal (raw) but callers wrap in Price/value objects"
    - "appsettings.json MultiplierTier DropPercentage values migrated from 0-100 to 0-1 format"
    - "MultiplierCalculatorTests updated for 0-1 format and value object types"
    - "All 53 tests pass (snapshot tests updated if needed)"
    - "DcaOptionsValidator removes redundant bounds checks that value objects now enforce"
  artifacts:
    - path: "TradingBot.ApiService/Configuration/DcaOptions.cs"
      provides: "DcaOptions with value object fields and updated validator"
      contains: "UsdAmount BaseDailyAmount"
    - path: "TradingBot.ApiService/Application/Services/MultiplierCalculator.cs"
      provides: "MultiplierCalculator with typed signature"
      contains: "Price currentPrice"
    - path: "TradingBot.ApiService/Application/Services/BacktestSimulator.cs"
      provides: "BacktestSimulator using value objects internally"
      contains: "MultiplierCalculator.Calculate"
    - path: "TradingBot.ApiService/appsettings.json"
      provides: "Config with 0-1 format DropPercentage values"
      contains: "0.05"
    - path: "tests/TradingBot.ApiService.Tests/Application/Services/MultiplierCalculatorTests.cs"
      provides: "Updated tests for value object types and 0-1 format"
      contains: "0.05m"
  key_links:
    - from: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      to: "TradingBot.ApiService/Application/Services/MultiplierCalculator.cs"
      via: "MultiplierCalculator.Calculate call with value object arguments"
      pattern: "MultiplierCalculator.Calculate"
    - from: "TradingBot.ApiService/Application/Services/BacktestSimulator.cs"
      to: "TradingBot.ApiService/Application/Services/MultiplierCalculator.cs"
      via: "MultiplierCalculator.Calculate call with value object arguments"
      pattern: "MultiplierCalculator.Calculate"
    - from: "TradingBot.ApiService/Configuration/DcaOptions.cs"
      to: "TradingBot.ApiService/Models/Values/UsdAmount.cs"
      via: "Config binding with TypeConverter"
      pattern: "UsdAmount BaseDailyAmount"
---

<objective>
Apply value objects to DcaOptions configuration, MultiplierCalculator, BacktestSimulator, DcaExecutionService, PriceDataService, ConfigurationService, and notification handlers. Update DcaOptionsValidator to remove redundant validation. Refresh snapshot tests.

Purpose: Complete the value object adoption across the entire application layer. Configuration binding, business logic, and backtest simulation all use domain-typed parameters for compile-time safety.

Output: Updated service signatures, config binding with TypeConverter, updated backtest models, refreshed snapshot tests.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-value-objects/14-RESEARCH.md
@.planning/phases/14-value-objects/14-01-SUMMARY.md

@TradingBot.ApiService/Models/Ids/VogenGlobalConfig.cs
@TradingBot.ApiService/Configuration/DcaOptions.cs
@TradingBot.ApiService/Application/Services/MultiplierCalculator.cs
@TradingBot.ApiService/Application/Services/BacktestSimulator.cs
@TradingBot.ApiService/Application/Services/Backtest/BacktestConfig.cs
@TradingBot.ApiService/Application/Services/Backtest/DailyPriceData.cs
@TradingBot.ApiService/Application/Services/Backtest/PurchaseLogEntry.cs
@TradingBot.ApiService/Application/Services/Backtest/BacktestResult.cs
@TradingBot.ApiService/Application/Services/DcaExecutionService.cs
@TradingBot.ApiService/Application/Services/PriceDataService.cs
@TradingBot.ApiService/Application/Services/ConfigurationService.cs
@TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
@TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update VogenGlobalConfig, DcaOptions, DcaOptionsValidator, and ConfigurationService</name>
  <files>
    TradingBot.ApiService/Models/Ids/VogenGlobalConfig.cs
    TradingBot.ApiService/Configuration/DcaOptions.cs
    TradingBot.ApiService/Application/Services/ConfigurationService.cs
  </files>
  <action>
    **VogenGlobalConfig.cs** -- Add `Conversions.TypeConverter` to the global conversions flag. This is required for ASP.NET Core configuration binding to convert config strings ("10.0") to value objects. Update the conversions line:
    ```csharp
    conversions: Conversions.EfCoreValueConverter | Conversions.SystemTextJson | Conversions.TypeConverter,
    ```
    This applies to all Vogen types (both typed IDs and value objects). TypeConverter for Guids is standard and harmless. This approach is simpler than per-type overrides (research Option B).

    **DcaOptions.cs** -- Replace decimal fields with value objects:
    - `decimal BaseDailyAmount` -> `UsdAmount BaseDailyAmount`
    - `decimal BearBoostFactor` -> `Multiplier BearBoostFactor` (default `= Multiplier.From(1.5m)`)
    - `decimal MaxMultiplierCap` -> `Multiplier MaxMultiplierCap` (default `= Multiplier.From(4.5m)`)
    - Add `using TradingBot.ApiService.Models.Values;`

    **MultiplierTier class** in DcaOptions.cs -- Replace fields:
    - `decimal DropPercentage` -> `Percentage DropPercentage`
    - `decimal Multiplier` -> `Multiplier Multiplier`

    **DcaOptionsValidator** -- Remove redundant validation that value objects now enforce at construction:
    - REMOVE: `BaseDailyAmount <= 0` check (UsdAmount rejects <= 0)
    - REMOVE: `BearBoostFactor <= 0` check (Multiplier rejects <= 0)
    - REMOVE: `MaxMultiplierCap <= 0` check (Multiplier rejects <= 0)
    - KEEP: `MaxMultiplierCap < 1` check (cross-field business rule: cap shouldn't reduce)
    - KEEP: `DailyBuyHour`, `DailyBuyMinute` checks (int fields, no value object)
    - KEEP: `HighLookbackDays`, `BearMarketMaPeriod` checks (int fields, no value object)
    - KEEP: MultiplierTiers validation (ordering, positive values) -- these are now cross-field rules
    - Update MultiplierTier comparisons to use value object operators (e.g., `t.Multiplier <= Multiplier.From(0)` or leverage that Multiplier already rejects <= 0 at construction)
    - For tier validation: if config binding creates `Multiplier.From(0)`, it will throw during binding, so the validator check for `Multiplier <= 0` becomes unreachable. REMOVE it. Keep the ascending sort check.
    - Update `MultiplierTierComparer` to compare value objects (use `.Value` for explicit decimal comparison if needed, or rely on `==`/`!=` operators)

    **ConfigurationService.cs** -- Update mapping methods:
    - `MapToOptions`: Map from `DcaConfiguration` entity (which has value object fields from Plan 01) to `DcaOptions` (which now also has value object fields). The mapping becomes trivial: `BaseDailyAmount = entity.BaseDailyAmount` etc.
    - `MapFromOptions`: Reverse mapping. Same simplification.
    - `MultiplierTierData` in DcaConfiguration stays as raw `decimal` (jsonb). So the tier mapping must convert: `new MultiplierTier { DropPercentage = Percentage.From(t.DropPercentage), Multiplier = Multiplier.From(t.Multiplier) }` and reverse: `new MultiplierTierData(t.DropPercentage.Value, t.Multiplier.Value)`.
    - `GetDefaultsAsync` creates a new `DcaOptions()` and binds from config -- this will work because of the TypeConverter addition to VogenGlobalConfig.
  </action>
  <verify>
    `dotnet build TradingBot.sln` compiles. Verify DcaOptions fields are value objects. Verify DcaOptionsValidator has fewer but still meaningful validations.
  </verify>
  <done>
    DcaOptions uses value objects for all numeric domain fields. Configuration binding works via TypeConverter. DcaOptionsValidator is simplified to cross-field business rules only. ConfigurationService maps correctly between entities, config, and DTOs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update MultiplierCalculator, BacktestSimulator, services, handlers, and refresh tests</name>
  <files>
    TradingBot.ApiService/Application/Services/MultiplierCalculator.cs
    TradingBot.ApiService/Application/Services/BacktestSimulator.cs
    TradingBot.ApiService/Application/Services/Backtest/BacktestConfig.cs
    TradingBot.ApiService/Application/Services/Backtest/DailyPriceData.cs
    TradingBot.ApiService/Application/Services/Backtest/PurchaseLogEntry.cs
    TradingBot.ApiService/Application/Services/Backtest/BacktestResult.cs
    TradingBot.ApiService/Application/Services/DcaExecutionService.cs
    TradingBot.ApiService/Application/Services/PriceDataService.cs
    TradingBot.ApiService/Application/Handlers/PurchaseCompletedHandler.cs
    TradingBot.ApiService/Endpoints/DashboardEndpoints.cs
    TradingBot.ApiService/appsettings.json
    tests/TradingBot.ApiService.Tests/Application/Services/MultiplierCalculatorTests.cs
  </files>
  <action>
    **MultiplierCalculator.cs** -- Update signature and internals:
    - Params: `Price currentPrice, UsdAmount baseAmount, decimal high30Day, decimal ma200Day, IReadOnlyList<MultiplierTier> tiers, Multiplier bearBoostFactor, Multiplier maxCap`
    - `high30Day` and `ma200Day` stay as `decimal` parameters (sentinel 0 = "data unavailable"; Price rejects 0). This matches Plan 01's decision to keep Purchase.High30Day/Ma200Day as decimal.
    - Drop percentage calculation in 0-1 format (matching Percentage value object): `decimal drop = high30Day > 0 ? (high30Day - currentPrice.Value) / high30Day : 0m;`
    - Tier matching: `drop >= t.DropPercentage.Value` (both 0-1 format)
    - Tier label: `$">= {t.DropPercentage.Value * 100:F1}%"` (multiply by 100 for display)
    - Bear check: `ma200Day > 0 && currentPrice.Value < ma200Day`
    - For `uncappedMultiplier`: use raw decimal arithmetic since bearBoostApplied can be 0 and Multiplier rejects 0: `var uncapped = tierMultiplier.Value + bearBoostApplied; var final = Math.Min(uncapped, maxCap.Value); var finalMultiplier = Multiplier.From(final);`
    - Result: `Multiplier.From(finalMult)`, `Percentage.From(Math.Clamp(drop, 0, 1))`, `UsdAmount.From(baseAmount.Value * finalMult)`
    - `MultiplierResult` record fields:
      - `Multiplier` -> `Multiplier Multiplier`
      - `DropPercentage` -> `Percentage DropPercentage`
      - `High30Day` -> stays `decimal` (can be 0 sentinel)
      - `Ma200Day` -> stays `decimal` (can be 0 sentinel)
      - `FinalAmount` -> `UsdAmount FinalAmount`
      - `BearBoostApplied` -> stays `decimal` (additive amount, can be 0)
      - `Tier` -> stays `string`
      - `IsBearMarket` -> stays `bool`
    - Add `using TradingBot.ApiService.Models.Values;` and `using TradingBot.ApiService.Configuration;`

    **BacktestConfig.cs** -- Update record fields:
    - `decimal BaseDailyAmount` -> `UsdAmount BaseDailyAmount`
    - `decimal BearBoostFactor` -> `Multiplier BearBoostFactor`
    - `decimal MaxMultiplierCap` -> `Multiplier MaxMultiplierCap`
    - Update `MultiplierTierConfig` to use value objects: `record MultiplierTierConfig(Percentage DropPercentage, Multiplier Multiplier)`. Matches DcaOptions.MultiplierTier.

    **DailyPriceData.cs** -- Keep as raw decimals. Backtest input record from historical data queries. BacktestSimulator wraps in value objects at the MultiplierCalculator call boundary.

    **PurchaseLogEntry.cs** -- Keep as raw decimals. Snapshot-tested output record. Implicit cast from value objects handles assignment.

    **BacktestResult.cs** -- Keep `DcaMetrics`, `ComparisonMetrics`, `TierBreakdownEntry` as raw decimals. API response DTOs.

    **BacktestSimulator.cs** -- Update to work with typed BacktestConfig:
    - Convert `MultiplierTierConfig` to `MultiplierTier` for `MultiplierCalculator` call: `new MultiplierTier { DropPercentage = t.DropPercentage, Multiplier = t.Multiplier }` (both value objects, direct assignment)
    - At `MultiplierCalculator.Calculate` call site: `Price.From(day.Close)`, `config.BaseDailyAmount`, raw `high30Day` decimal, raw `ma200Day` decimal, `config.BearBoostFactor`, `config.MaxMultiplierCap`
    - Extract results to raw decimals for `DayData` and `PurchaseLogEntry`: `multiplierResult.Multiplier.Value`, `multiplierResult.FinalAmount.Value`, etc.
    - `DayData` private record stays raw decimals
    - Tier breakdown: `d.AmountUsd - config.BaseDailyAmount.Value`

    **DcaExecutionService.cs** -- Update to work with value objects:
    - `currentPrice` from `GetSpotPriceAsync` is `decimal` -- wrap at call sites: `Price.From(currentPrice)`
    - `CalculateMultiplierAsync`: pass `Price.From(currentPrice)`, `options.BaseDailyAmount` (already UsdAmount), raw `high30Day`/`ma200Day` decimals (from PriceDataService), `options.MultiplierTiers`, `options.BearBoostFactor`, `options.MaxMultiplierCap`
    - `multipliedAmount = options.BaseDailyAmount * multiplierResult.Multiplier` -- cross-type `UsdAmount * Multiplier = UsdAmount`
    - `usdAmount = UsdAmount.From(Math.Min(usdcBalance, multipliedAmount.Value))` -- cap by available balance
    - For order amount check: `usdAmount.Value < MinimumOrderValue`
    - **Purchase.Cost initialization fix**: Set `Cost = UsdAmount.From(usdAmount.Value)` (the intended spend) instead of `Cost = 0`. This is valid because usdAmount is always positive at this point. On fill, update: `purchase.Cost = UsdAmount.From(filledQty * avgPrice)`. For dry-run: `purchase.Cost = UsdAmount.From(roundedQuantity * currentPrice)`.
    - `Quantity = Quantity.From(0)` -- valid (Quantity allows zero for pending state)
    - `Price = Price.From(currentPrice)` -- valid (always positive)
    - On fill: `purchase.Quantity = Quantity.From(filledQty)`, `purchase.Price = Price.From(avgPrice)`, `purchase.Cost = UsdAmount.From(filledQty * avgPrice)`
    - Fallback in catch block: construct `MultiplierResult` directly instead of calling `MultiplierCalculator.Calculate` with 0 sentinel (avoids the 0-sentinel path entirely):
    ```csharp
    return new MultiplierResult(
        Multiplier: Multiplier.From(1.0m),
        Tier: "Base",
        IsBearMarket: false,
        BearBoostApplied: 0m,
        DropPercentage: Percentage.From(0m),
        High30Day: 0m,
        Ma200Day: 0m,
        FinalAmount: options.BaseDailyAmount);
    ```
    - `PurchaseCompletedEvent` publishing: `purchase.Cost` is now `UsdAmount` -- passes directly as `UsdSpent`. `remainingUsdc` stays `decimal` (matches event field from Plan 01). `purchase.High30Day`/`Ma200Day` stay `decimal` (matches event field from Plan 01).

    **PriceDataService.cs** -- Keep return types as `decimal` for `Get30DayHighAsync` and `Get200DaySmaAsync` (0 sentinel for "data unavailable"). Update method signature parameters from `string symbol` to `Symbol symbol` for type safety. Callers pass `Symbol.Btc`. LINQ `p.Symbol == symbol` works via EF Core value converter. Also update `BootstrapHistoricalDataAsync` and `FetchAndStoreDailyCandleAsync` to accept `Symbol`.

    **PurchaseCompletedHandler.cs** -- Update to use value objects from PurchaseCompletedEvent:
    - `notification.Price.Value` for string interpolation: `${notification.Price.Value:N2}`
    - `notification.BtcAmount.Value`, `notification.UsdSpent.Value` similarly
    - `notification.RemainingUsdc` stays `decimal` -- no `.Value` needed
    - `notification.High30Day` stays `decimal` -- no `.Value` needed
    - `notification.Ma200Day` stays `decimal` -- no `.Value` needed
    - `BuildMultiplierReasoning`: use `.Value` for comparisons: `e.Multiplier.Value == 1.0m`, `e.DropPercentage.Value > 0`

    **DashboardEndpoints.cs** -- The endpoint code reads entities with value objects and maps to DTO records that now also use value objects (per Plan 01). LINQ projections like `Price = p.Price` where both source and target are `Price` work directly. Verify compilation.

    **appsettings.json** -- Migrate MultiplierTier DropPercentage values from 0-100 format to 0-1 format:
    - `"DropPercentage": 5` -> `"DropPercentage": 0.05`
    - `"DropPercentage": 10` -> `"DropPercentage": 0.10`
    - `"DropPercentage": 20` -> `"DropPercentage": 0.20`
    This is required because `Percentage` validates 0-1 range and config binding uses TypeConverter.

    **MultiplierCalculatorTests.cs** -- Update test data for 0-1 format migration:
    - `DefaultTiers`: change `DropPercentage = 5` to `DropPercentage = 0.05m`, `DropPercentage = 10` to `0.10m`, `DropPercentage = 20` to `0.20m`
    - `DefaultBearBoost`, `DefaultMaxCap`: wrap as `Multiplier.From(1.5m)`, `Multiplier.From(4.5m)` if the test calls `MultiplierCalculator.Calculate` with typed params
    - `DefaultBaseAmount`: wrap as `UsdAmount.From(10.0m)` if needed
    - Update `InlineData` test expectations: `expectedDropPercentage` values change from 0-100 to 0-1 format (e.g., `5.00` -> `0.05`, `10.00` -> `0.10`, etc.)
    - Tier label expectations: `">= 5%"` -> `">= 5.0%"` (formatted via `{value * 100:F1}%`)
    - Update assertions to use `.Value` where needed for typed results, or compare value objects directly per CONTEXT.md decision: `result.Multiplier.Should().Be(Multiplier.From(expectedMultiplier))`
    - If BacktestSimulator snapshot tests fail, run `UPDATE_SNAPSHOTS=true dotnet test` to regenerate, then re-run to verify
  </action>
  <verify>
    `dotnet build TradingBot.sln` compiles with zero errors. `dotnet test` passes all 53 tests (with snapshot refresh if needed). Verify MultiplierCalculator signature accepts value objects. Verify DcaOptions binds correctly by checking that the application starts without configuration binding errors.
  </verify>
  <done>
    All services, config, and backtest code use value objects. MultiplierCalculator has typed signature. DcaOptions binds from config with TypeConverter. DcaOptionsValidator simplified. All tests pass. Percentage format standardized to 0-1.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` -- zero compilation errors
2. `dotnet test` -- all tests pass (53 expected, may change if snapshot format changes)
3. Verify DcaOptions config binding: check that `appsettings.json` values (updated to 0-1 format for percentages) bind correctly
4. Verify MultiplierCalculator tests still validate correct behavior with value object inputs
5. Verify BacktestSimulator snapshot tests are current (regenerated if format changed)
</verification>

<success_criteria>
- DcaOptions uses UsdAmount, Multiplier, Percentage value objects with config binding
- MultiplierCalculator.Calculate accepts typed parameters
- BacktestSimulator works with typed BacktestConfig
- DcaExecutionService creates purchases with value objects
- PriceDataService accepts Symbol parameter
- All 53+ tests pass
- DcaOptionsValidator simplified to cross-field rules only
- Percentage format standardized to 0-1 throughout
</success_criteria>

<output>
After completion, create `.planning/phases/14-value-objects/14-02-SUMMARY.md`
</output>
