---
phase: 17-domain-event-dispatch
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/BuildingBlocks/IAggregateRoot.cs
  - TradingBot.ApiService/BuildingBlocks/AggregateRoot.cs
  - TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/DomainEventOutboxInterceptor.cs
  - TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
  - TradingBot.ApiService/Application/Events/PurchaseCreatedEvent.cs
  - TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs
  - TradingBot.ApiService/Application/Events/DcaConfigurationCreatedEvent.cs
  - TradingBot.ApiService/Application/Events/DcaConfigurationUpdatedEvent.cs
  - TradingBot.ApiService/Models/Purchase.cs
  - TradingBot.ApiService/Models/DcaConfiguration.cs
  - TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
  - TradingBot.ApiService/Program.cs
autonomous: true
requirements:
  - DE-01
  - DE-02

must_haves:
  truths:
    - "DomainEventOutboxInterceptor collects domain events from aggregates in ChangeTracker during SavingChangesAsync and inserts OutboxMessage records in the same transaction"
    - "Domain events carry key data (Price, Quantity, Cost, OccurredAt) -- not just identity"
    - "AggregateRoot entities implement IAggregateRoot interface for clean ChangeTracker filtering"
    - "Interceptor does NOT call SaveChangesAsync internally -- only adds tracked entities"
  artifacts:
    - path: "TradingBot.ApiService/BuildingBlocks/IAggregateRoot.cs"
      provides: "IAggregateRoot marker interface with DomainEvents and ClearDomainEvents"
      contains: "interface IAggregateRoot"
    - path: "TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/DomainEventOutboxInterceptor.cs"
      provides: "SaveChangesInterceptor that bridges domain events to outbox messages"
      contains: "SavingChangesAsync"
  key_links:
    - from: "TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/DomainEventOutboxInterceptor.cs"
      to: "TradingBot.ApiService/BuildingBlocks/IAggregateRoot.cs"
      via: "ChangeTracker.Entries<IAggregateRoot>()"
      pattern: "Entries<IAggregateRoot>"
    - from: "TradingBot.ApiService/Program.cs"
      to: "TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/DomainEventOutboxInterceptor.cs"
      via: "AddInterceptors registration"
      pattern: "DomainEventOutboxInterceptor"
    - from: "TradingBot.ApiService/Models/Purchase.cs"
      to: "TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs"
      via: "Enriched event construction in behavior methods"
      pattern: "PurchaseCompletedEvent.*Price.*Quantity.*Cost"
---

<objective>
Create the SaveChangesInterceptor that atomically bridges domain events to outbox messages, and enrich existing thin domain events with key data fields.

Purpose: Guarantees domain events are persisted as outbox messages in the same database transaction as the domain changes -- if SaveChanges fails, no events dispatch. Enriched events carry enough data for handlers to avoid extra DB queries.

Output: DomainEventOutboxInterceptor, IAggregateRoot interface, enriched domain event records, interceptor registered in Program.cs
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-domain-event-dispatch/17-RESEARCH.md

@TradingBot.ApiService/BuildingBlocks/AggregateRoot.cs
@TradingBot.ApiService/BuildingBlocks/IDomainEvent.cs
@TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/OutboxMessage.cs
@TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
@TradingBot.ApiService/Application/Events/PurchaseCreatedEvent.cs
@TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs
@TradingBot.ApiService/Application/Events/PurchaseSkippedEvent.cs
@TradingBot.ApiService/Application/Events/DcaConfigurationCreatedEvent.cs
@TradingBot.ApiService/Application/Events/DcaConfigurationUpdatedEvent.cs
@TradingBot.ApiService/Models/Purchase.cs
@TradingBot.ApiService/Models/DcaConfiguration.cs
@TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
@TradingBot.ApiService/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IAggregateRoot interface and DomainEventOutboxInterceptor</name>
  <files>
    TradingBot.ApiService/BuildingBlocks/IAggregateRoot.cs
    TradingBot.ApiService/BuildingBlocks/AggregateRoot.cs
    TradingBot.ApiService/BuildingBlocks/Pubsub/Outbox/DomainEventOutboxInterceptor.cs
    TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
    TradingBot.ApiService/Program.cs
  </files>
  <action>
    1. Create `IAggregateRoot` interface in `BuildingBlocks/IAggregateRoot.cs`:
       ```csharp
       public interface IAggregateRoot
       {
           IReadOnlyList<IDomainEvent> DomainEvents { get; }
           void ClearDomainEvents();
       }
       ```

    2. Update `AggregateRoot<TId>` in `BuildingBlocks/AggregateRoot.cs` to implement `IAggregateRoot`:
       ```csharp
       public abstract class AggregateRoot<TId> : BaseEntity<TId>, IAggregateRoot
       ```

    3. Create `DomainEventOutboxInterceptor` in `BuildingBlocks/Pubsub/Outbox/DomainEventOutboxInterceptor.cs`:
       - Extend `SaveChangesInterceptor`
       - Override `SavingChangesAsync` (NOT `SavedChangesAsync` -- critical: must be INSIDE the transaction)
       - In `SavingChangesAsync`: call a private `InsertOutboxMessages(DbContext context)` method
       - `InsertOutboxMessages` does:
         a. Query `context.ChangeTracker.Entries<IAggregateRoot>()` to find all tracked aggregates
         b. For each aggregate with `DomainEvents.Count > 0`, collect events and call `aggregate.ClearDomainEvents()`
         c. Map each `IDomainEvent` to an `OutboxMessage` with:
            - `EventName = domainEvent.GetType().Name`
            - `Payload = JsonSerializer.Serialize(domainEvent, domainEvent.GetType(), jsonOptions)` (CRITICAL: pass runtime type to avoid empty JSON serialization of interface)
            - `ProcessingStatus = ProcessingStatus.Pending`
         d. Call `context.Set<OutboxMessage>().AddRange(outboxMessages)` -- do NOT call SaveChangesAsync (causes recursion)
       - Also override the synchronous `SavingChanges` with the same logic for completeness
       - The interceptor takes `JsonSerializerOptions` via constructor. It is stateless -- safe as singleton.

    4. Register the interceptor in `Program.cs`:
       - Register `DomainEventOutboxInterceptor` as singleton
       - IMPORTANT: The codebase uses `builder.AddNpgsqlDbContext<TradingBotDbContext>("tradingbotdb")` (Aspire). The Aspire method has a `configureDbContextOptions` parameter. Use it:
         ```csharp
         builder.AddNpgsqlDbContext<TradingBotDbContext>("tradingbotdb",
             configureDbContextOptions: options =>
             {
                 options.AddInterceptors(/* resolve from DI or create inline */);
             });
         ```
       - Since the interceptor needs `JsonSerializerOptions`, and `AddOutboxPublishingWithEfCore` (wired in Plan 02) registers a singleton `JsonSerializerOptions`, for NOW create the interceptor inline with `new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }`. Plan 02 will consolidate when outbox wiring lands.
       - Alternatively, register the interceptor singleton first, then reference it:
         ```csharp
         var jsonOptions = new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase };
         builder.Services.AddSingleton(new DomainEventOutboxInterceptor(jsonOptions));
         builder.AddNpgsqlDbContext<TradingBotDbContext>("tradingbotdb",
             configureDbContextOptions: options =>
             {
                 // Use service provider to resolve
             });
         ```
       - Check if Aspire's `AddNpgsqlDbContext` overload supports a lambda with `IServiceProvider` access. If not, register as singleton and resolve in a `IDbContextOptionsExtension` or simply pass the options inline.

    5. In `TradingBotDbContext.OnModelCreating`, ensure OutboxMessage entity is configured. It currently uses `AddOutboxMessageEntity()` extension from `EfCoreOutboxMessageModelBuilderExtensions`. Verify it is called -- if not, add `modelBuilder.AddOutboxMessageEntity()` to `OnModelCreating`. (Check if outbox messages are already configured; if not, this is needed for the interceptor to add OutboxMessage to the context.)
  </action>
  <verify>
    Run `dotnet build TradingBot.sln` -- should compile without errors.
    Verify `DomainEventOutboxInterceptor.cs` exists and overrides `SavingChangesAsync`.
    Verify `IAggregateRoot` interface exists and `AggregateRoot<TId>` implements it.
    Verify `Program.cs` registers the interceptor.
  </verify>
  <done>
    IAggregateRoot interface created. AggregateRoot implements it. DomainEventOutboxInterceptor scans ChangeTracker for IAggregateRoot entities, serializes their domain events to OutboxMessage records in the same transaction. Interceptor registered in Program.cs. No SaveChangesAsync called inside interceptor. Solution builds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enrich domain events with key data and OccurredAt timestamp</name>
  <files>
    TradingBot.ApiService/Application/Events/PurchaseCompletedEvent.cs
    TradingBot.ApiService/Application/Events/PurchaseCreatedEvent.cs
    TradingBot.ApiService/Application/Events/PurchaseFailedEvent.cs
    TradingBot.ApiService/Application/Events/DcaConfigurationCreatedEvent.cs
    TradingBot.ApiService/Application/Events/DcaConfigurationUpdatedEvent.cs
    TradingBot.ApiService/Models/Purchase.cs
    TradingBot.ApiService/Models/DcaConfiguration.cs
  </files>
  <action>
    Enrich thin identity-only domain events with key data per locked decision. All events get `DateTimeOffset OccurredAt`.

    1. **PurchaseCompletedEvent** -- add Price, Quantity, Cost, OccurredAt:
       ```csharp
       public record PurchaseCompletedEvent(
           PurchaseId PurchaseId,
           decimal Price,
           decimal Quantity,
           decimal Cost,
           DateTimeOffset OccurredAt) : IDomainEvent;
       ```
       Use `decimal` (not value object types) for event fields -- events are serialized to JSON for outbox; value objects may not round-trip cleanly through JSON. The behavior methods have the raw values available.

    2. **PurchaseCreatedEvent** -- add Price, Cost, Multiplier, OccurredAt:
       ```csharp
       public record PurchaseCreatedEvent(
           PurchaseId PurchaseId,
           decimal Price,
           decimal Cost,
           decimal Multiplier,
           DateTimeOffset OccurredAt) : IDomainEvent;
       ```

    3. **PurchaseFailedEvent** -- add FailureReason, OccurredAt:
       ```csharp
       public record PurchaseFailedEvent(
           PurchaseId PurchaseId,
           string? FailureReason,
           DateTimeOffset OccurredAt) : IDomainEvent;
       ```

    4. **DcaConfigurationCreatedEvent** -- add OccurredAt:
       ```csharp
       public record DcaConfigurationCreatedEvent(
           DcaConfigurationId ConfigId,
           DateTimeOffset OccurredAt) : IDomainEvent;
       ```

    5. **DcaConfigurationUpdatedEvent** -- add OccurredAt:
       ```csharp
       public record DcaConfigurationUpdatedEvent(
           DcaConfigurationId ConfigId,
           DateTimeOffset OccurredAt) : IDomainEvent;
       ```

    6. **PurchaseSkippedEvent** -- already has rich data. Add `OccurredAt` if missing (check: it has `SkippedAt` which serves the same purpose). Keep as-is if `SkippedAt` covers the OccurredAt role. Add `OccurredAt` as a separate field for consistency across all events, setting it to `DateTimeOffset.UtcNow` at creation time. OR rename `SkippedAt` to `OccurredAt` for consistency. Use discretion: simplest is to add `OccurredAt` alongside `SkippedAt` -- but that's redundant. Best: rename `SkippedAt` to `OccurredAt` to match all other events. Update the `PurchaseSkippedHandler` reference from `notification.SkippedAt` to `notification.OccurredAt`.

    7. **Update Purchase behavior methods** to pass enriched data when calling `AddDomainEvent()`:
       - `Create()`: pass `Price.Value`, `Cost.Value`, `Multiplier.Value`, `DateTimeOffset.UtcNow` to `PurchaseCreatedEvent`
       - `RecordDryRunFill()`: pass `Price.Value`, `quantity.Value`, `actualCost.Value`, `DateTimeOffset.UtcNow` to `PurchaseCompletedEvent`
       - `RecordFill()`: pass `avgPrice.Value`, `quantity.Value`, `actualCost.Value`, `DateTimeOffset.UtcNow` to `PurchaseCompletedEvent`
       - `RecordResting()`: pass `FailureReason`, `DateTimeOffset.UtcNow` to `PurchaseFailedEvent`
       - `RecordFailure()`: pass `reason`, `DateTimeOffset.UtcNow` to `PurchaseFailedEvent`

    8. **Update DcaConfiguration methods** to pass `DateTimeOffset.UtcNow` to events:
       - `Create()`: `new DcaConfigurationCreatedEvent(id, DateTimeOffset.UtcNow)`
       - `UpdateDailyAmount()`, `UpdateSchedule()`, `UpdateTiers()`, `UpdateBearMarket()`, `UpdateSettings()`: `new DcaConfigurationUpdatedEvent(Id, DateTimeOffset.UtcNow)`
  </action>
  <verify>
    Run `dotnet build TradingBot.sln` -- should compile without errors.
    Verify each event record has `OccurredAt` field.
    Verify PurchaseCompletedEvent has Price, Quantity, Cost fields.
    Verify Purchase.RecordFill passes price/quantity/cost values to PurchaseCompletedEvent.
  </verify>
  <done>
    All domain events enriched with key data fields and OccurredAt timestamp. Purchase behavior methods pass actual values (Price.Value, Quantity.Value, Cost.Value) when raising events. DcaConfiguration events carry OccurredAt. PurchaseSkippedEvent unified with OccurredAt. Solution builds cleanly.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.sln` compiles without errors
2. `DomainEventOutboxInterceptor` overrides `SavingChangesAsync` (not `SavedChangesAsync`)
3. Interceptor uses `context.Set<OutboxMessage>().AddRange()` -- never calls `SaveChangesAsync` internally
4. `IAggregateRoot` interface exists with `DomainEvents` and `ClearDomainEvents()`
5. All domain events carry `OccurredAt` timestamp
6. `PurchaseCompletedEvent` carries `Price`, `Quantity`, `Cost` as decimal
7. Purchase behavior methods pass enriched data to `AddDomainEvent()`
8. Interceptor registered in Program.cs via `AddInterceptors`
</verification>

<success_criteria>
- Solution builds without errors
- DomainEventOutboxInterceptor intercepts SavingChangesAsync to collect domain events from IAggregateRoot entities and insert OutboxMessage records atomically
- All domain events enriched with key data and OccurredAt timestamp
- Interceptor is stateless, registered as singleton, uses runtime type serialization
</success_criteria>

<output>
After completion, create `.planning/phases/17-domain-event-dispatch/17-01-SUMMARY.md`
</output>
