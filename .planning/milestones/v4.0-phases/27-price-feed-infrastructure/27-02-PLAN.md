---
phase: 27-price-feed-infrastructure
plan: 02
type: execute
wave: 2
depends_on: [27-01]
files_modified:
  - TradingBot.ApiService/Infrastructure/PriceFeeds/Etf/VNDirectPriceProvider.cs
  - TradingBot.ApiService/Infrastructure/PriceFeeds/Etf/VNDirectDchartResponse.cs
  - TradingBot.ApiService/Infrastructure/PriceFeeds/ExchangeRate/OpenErApiProvider.cs
  - TradingBot.ApiService/Infrastructure/PriceFeeds/ExchangeRate/OpenErApiResponse.cs
  - TradingBot.ApiService/Infrastructure/PriceFeeds/ServiceCollectionExtensions.cs
  - TradingBot.ApiService/Program.cs
autonomous: true
requirements: [PRICE-02, PRICE-03, PRICE-04]

must_haves:
  truths:
    - "VN30 ETF price can be fetched from VNDirect dchart-api and returned in VND with a FetchedAt timestamp"
    - "ETF price is cached in Redis with 48-hour freshness and 30-day physical TTL"
    - "Stale ETF cache returns immediately with IsStale=true and triggers a fire-and-forget background refresh"
    - "USD/VND exchange rate can be fetched from open.er-api.com and cached with 12-hour freshness"
    - "All three providers are registered in DI and wirable from Program.cs via a single AddPriceFeeds() call"
    - "VNDirect dchart close prices are multiplied by 1000 to convert from thousands-of-VND to actual VND"
  artifacts:
    - path: "TradingBot.ApiService/Infrastructure/PriceFeeds/Etf/VNDirectPriceProvider.cs"
      provides: "VNDirect dchart implementation with stale-while-revalidate pattern"
      contains: "VNDirectPriceProvider"
    - path: "TradingBot.ApiService/Infrastructure/PriceFeeds/Etf/VNDirectDchartResponse.cs"
      provides: "JSON DTO for dchart API response"
      contains: "VNDirectDchartResponse"
    - path: "TradingBot.ApiService/Infrastructure/PriceFeeds/ExchangeRate/OpenErApiProvider.cs"
      provides: "open.er-api.com implementation with 12-hour freshness"
      contains: "OpenErApiProvider"
    - path: "TradingBot.ApiService/Infrastructure/PriceFeeds/ExchangeRate/OpenErApiResponse.cs"
      provides: "JSON DTO for exchange rate API response"
      contains: "OpenErApiResponse"
    - path: "TradingBot.ApiService/Infrastructure/PriceFeeds/ServiceCollectionExtensions.cs"
      provides: "AddPriceFeeds() registration method wiring all 3 providers"
      contains: "AddPriceFeeds"
    - path: "TradingBot.ApiService/Program.cs"
      provides: "Price feeds registered in DI pipeline"
      contains: "AddPriceFeeds"
  key_links:
    - from: "VNDirectPriceProvider"
      to: "dchart-api.vndirect.com.vn"
      via: "HttpClient.GetFromJsonAsync"
      pattern: "dchart/history\\?resolution=D"
    - from: "OpenErApiProvider"
      to: "open.er-api.com"
      via: "HttpClient.GetFromJsonAsync"
      pattern: "v6/latest/USD"
    - from: "ServiceCollectionExtensions.AddPriceFeeds"
      to: "Program.cs"
      via: "builder.Services.AddPriceFeeds()"
      pattern: "AddPriceFeeds"
    - from: "VNDirectPriceProvider"
      to: "PriceFeedEntry (from Plan 01)"
      via: "MessagePackSerializer"
      pattern: "MessagePackSerializer"
---

<objective>
Implement VNDirect ETF and open.er-api.com exchange rate providers, create the DI registration extension, and wire everything into Program.cs.

Purpose: Complete the price feed infrastructure by adding the remaining two providers (PRICE-02 for ETF, PRICE-03 for exchange rate) with their respective caching strategies, and wire all three providers into the application via a single `AddPriceFeeds()` call. PRICE-04 (staleness tracking) is completed via PriceFeedResult.IsStale + FetchedAt already established in Plan 01.

Output: VNDirectPriceProvider with stale-while-revalidate, OpenErApiProvider with 12h cache, ServiceCollectionExtensions wiring all three, Program.cs updated.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-price-feed-infrastructure/27-CONTEXT.md
@.planning/phases/27-price-feed-infrastructure/27-RESEARCH.md
@.planning/phases/27-price-feed-infrastructure/27-01-SUMMARY.md

Key patterns to follow:
@TradingBot.ApiService/Infrastructure/CoinGecko/ServiceCollectionExtensions.cs (HttpClient + resilience registration)
@TradingBot.ApiService/Infrastructure/PriceFeeds/PriceFeedEntry.cs (from Plan 01)
@TradingBot.ApiService/Infrastructure/PriceFeeds/PriceFeedResult.cs (from Plan 01)
@TradingBot.ApiService/Infrastructure/PriceFeeds/Crypto/CoinGeckoPriceProvider.cs (cache pattern from Plan 01)
@TradingBot.ApiService/Program.cs (where to add AddPriceFeeds call)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement VNDirect ETF provider with stale-while-revalidate and exchange rate provider</name>
  <files>
    TradingBot.ApiService/Infrastructure/PriceFeeds/Etf/VNDirectPriceProvider.cs
    TradingBot.ApiService/Infrastructure/PriceFeeds/Etf/VNDirectDchartResponse.cs
    TradingBot.ApiService/Infrastructure/PriceFeeds/ExchangeRate/OpenErApiProvider.cs
    TradingBot.ApiService/Infrastructure/PriceFeeds/ExchangeRate/OpenErApiResponse.cs
  </files>
  <action>
    **VNDirectDchartResponse.cs** — JSON DTO for dchart endpoint:
    ```
    public record VNDirectDchartResponse(
        [property: JsonPropertyName("t")] long[]? Timestamps,
        [property: JsonPropertyName("c")] decimal[]? Close,
        [property: JsonPropertyName("o")] decimal[]? Open,
        [property: JsonPropertyName("h")] decimal[]? High,
        [property: JsonPropertyName("l")] decimal[]? Low,
        [property: JsonPropertyName("v")] long[]? Volume,
        [property: JsonPropertyName("s")] string? Status
    );
    ```
    Namespace: `TradingBot.ApiService.Infrastructure.PriceFeeds.Etf`

    **VNDirectPriceProvider.cs** — Implements `IEtfPriceProvider`:
    - Primary constructor: `HttpClient`, `IDistributedCache`, `ILogger<VNDirectPriceProvider>`
    - Cache key: `price:etf:{vnDirectTicker}` (e.g., `price:etf:E1VFVN30`)
    - Freshness window: 48 hours (per PRICE-02)
    - Physical Redis TTL: 30 days

    **Stale-while-revalidate pattern (per Claude's discretion, research recommends this for ETF):**
    1. Read cache. If fresh → return Fresh.
    2. If stale → return Stale IMMEDIATELY, then fire-and-forget refresh: `_ = RefreshInBackgroundAsync(ticker, cacheKey)` (DO NOT await).
    3. If cache empty → await blocking fetch. If fails, throw (per locked decision).

    **RefreshInBackgroundAsync:** Private async method wrapped in try/catch that logs errors at Warning level but never throws. Uses `CancellationToken.None` (fire-and-forget should not be cancelled by the original request).

    **FetchAndCacheAsync:**
    - Build URL: `dchart/history?resolution=D&symbol={vnDirectTicker}&from={fromUnix}&to={toUnix}`
    - `from` = 3 days ago (DateTimeOffset.UtcNow.AddDays(-3).ToUnixTimeSeconds()), `to` = now
    - Parse response. Check `Status == "ok"` and `Close` array is non-empty.
    - CRITICAL: Multiply close price by 1000 to convert from thousands-of-VND to actual VND (per research Pitfall 4). Add code comment explaining this conversion.
    - Take last element of Close array: `response.Close[^1]`
    - Create `PriceFeedEntry.Create(latestClose * 1000m, "VND")`, serialize with MessagePack, cache with 30-day TTL.

    **OpenErApiResponse.cs** — JSON DTO:
    ```
    public record OpenErApiResponse(
        [property: JsonPropertyName("result")] string? Result,
        [property: JsonPropertyName("base_code")] string? BaseCode,
        [property: JsonPropertyName("time_last_update_unix")] long TimeLastUpdateUnix,
        [property: JsonPropertyName("rates")] Dictionary<string, decimal>? Rates
    );
    ```
    Namespace: `TradingBot.ApiService.Infrastructure.PriceFeeds.ExchangeRate`

    **OpenErApiProvider.cs** — Implements `IExchangeRateProvider`:
    - Primary constructor: `HttpClient`, `IDistributedCache`, `ILogger<OpenErApiProvider>`
    - Cache key: `price:exchangerate:usd-vnd`
    - Freshness window: 12 hours (per PRICE-03)
    - Physical Redis TTL: 30 days

    **Uses same wait-for-fetch pattern as crypto (NOT stale-while-revalidate):**
    - Exchange rate is used in currency conversion, so stale data is less acceptable than ETF staleness.
    1. Read cache. If fresh → return Fresh.
    2. If stale → try fetch. If fetch succeeds → cache and return Fresh. If fetch fails → return Stale with warning log.
    3. If cache empty → await blocking fetch. If fails, throw.

    **Fetch logic:**
    - URL: `v6/latest/USD`
    - Parse response. Check `Result == "success"` and `Rates` contains "VND" key.
    - Rate value is the USD-to-VND rate (e.g., 25905.86).
    - Create `PriceFeedEntry.Create(rate, "VND")`, serialize, cache.
    - Currency in PriceFeedResult is "VND" (the rate IS the VND value of 1 USD).

    **Logging:** Structured templates per project convention.
  </action>
  <verify>
    `dotnet build TradingBot.slnx` compiles successfully. VNDirectPriceProvider implements IEtfPriceProvider. OpenErApiProvider implements IExchangeRateProvider. Both use IDistributedCache and MessagePackSerializer.
  </verify>
  <done>
    VNDirectPriceProvider uses stale-while-revalidate (returns stale immediately, refreshes in background). Close price is multiplied by 1000 for VND conversion. OpenErApiProvider uses wait-for-fetch with stale fallback. Both have correct freshness windows (48h ETF, 12h exchange rate) and 30-day physical TTL.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DI registration and wire into Program.cs</name>
  <files>
    TradingBot.ApiService/Infrastructure/PriceFeeds/ServiceCollectionExtensions.cs
    TradingBot.ApiService/Program.cs
  </files>
  <action>
    **ServiceCollectionExtensions.cs** — Following exact pattern from `Infrastructure/CoinGecko/ServiceCollectionExtensions.cs`:

    Create `AddPriceFeeds(this IServiceCollection services, IConfiguration configuration)` method.

    Register three HttpClients with `AddStandardResilienceHandler`:

    1. **CoinGeckoPriceProvider** HttpClient:
       - BaseAddress: `https://api.coingecko.com/api/v3/`
       - Timeout: 15 seconds
       - If `CoinGeckoOptions.ApiKey` is configured, add default request header `x-cg-demo-api-key` with the key value. Read from configuration: `configuration.GetSection("CoinGecko").Get<CoinGeckoOptions>()?.ApiKey`
       - Resilience: MaxRetryAttempts=2, Delay=1s, Exponential backoff, TotalRequestTimeout=15s, AttemptTimeout=8s
       - Register as: `services.AddScoped<ICryptoPriceProvider, CoinGeckoPriceProvider>()`

    2. **VNDirectPriceProvider** HttpClient:
       - BaseAddress: `https://dchart-api.vndirect.com.vn/`
       - Timeout: 15 seconds
       - Resilience: Same as above
       - Register as: `services.AddScoped<IEtfPriceProvider, VNDirectPriceProvider>()`

    3. **OpenErApiProvider** HttpClient:
       - BaseAddress: `https://open.er-api.com/`
       - Timeout: 15 seconds
       - Resilience: Same as above
       - Register as: `services.AddScoped<IExchangeRateProvider, OpenErApiProvider>()`

    Use a shared local method or variable for the resilience configuration to avoid repeating the same options 3 times.

    Namespace: `TradingBot.ApiService.Infrastructure.PriceFeeds`

    **Program.cs** — Add the registration call:
    - Add `using TradingBot.ApiService.Infrastructure.PriceFeeds;` to the using statements
    - Add `builder.Services.AddPriceFeeds(builder.Configuration);` after the existing `builder.Services.AddCoinGecko(builder.Configuration);` line (around line 119). This keeps price feed registration near the existing CoinGecko registration for logical grouping.
  </action>
  <verify>
    `dotnet build TradingBot.slnx` compiles successfully. `dotnet test` passes (existing 76 tests unchanged). Program.cs contains `AddPriceFeeds` call. ServiceCollectionExtensions registers all three providers.
  </verify>
  <done>
    All three price providers are registered in DI via AddPriceFeeds(). Each has its own typed HttpClient with AddStandardResilienceHandler. CoinGecko demo API key header is conditionally added. Program.cs wires everything with a single call. Existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.slnx` compiles with zero errors
2. `dotnet test` passes all 76 existing tests
3. Files exist: VNDirectPriceProvider.cs, VNDirectDchartResponse.cs, OpenErApiProvider.cs, OpenErApiResponse.cs, ServiceCollectionExtensions.cs
4. Program.cs contains `AddPriceFeeds(builder.Configuration)`
5. VNDirectPriceProvider uses stale-while-revalidate pattern (fire-and-forget refresh)
6. VNDirectPriceProvider multiplies close price by 1000 (thousands-VND conversion)
7. OpenErApiProvider uses 12-hour freshness window
8. ServiceCollectionExtensions registers 3 HttpClients with AddStandardResilienceHandler
</verification>

<success_criteria>
- VNDirect ETF provider returns prices in VND (not thousands-of-VND) with 48h freshness
- Exchange rate provider returns USD-to-VND rate with 12h freshness
- All three providers are resolvable from DI container
- Fire-and-forget refresh in VNDirectPriceProvider does not block the caller
- No new NuGet packages added
- Existing test suite passes unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/27-price-feed-infrastructure/27-02-SUMMARY.md`
</output>
