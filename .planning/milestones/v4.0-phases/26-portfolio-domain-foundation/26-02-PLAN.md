---
phase: 26-portfolio-domain-foundation
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Application/Services/InterestCalculator.cs
  - tests/TradingBot.ApiService.Tests/Application/Services/InterestCalculatorTests.cs
autonomous: true
requirements:
  - PORT-06

must_haves:
  truths:
    - "Simple interest calculation returns P * (1 + r * t) for a given principal, rate, and elapsed time"
    - "Monthly compound interest returns P * (1 + r/12)^(12*t) correctly"
    - "Quarterly compound interest returns P * (1 + r/4)^(4*t) correctly"
    - "Semi-annual compound interest returns P * (1 + r/2)^(2*t) correctly"
    - "Annual compound interest returns P * (1 + r)^t correctly"
    - "Calculation returns principal when asOfDate is on or before startDate"
  artifacts:
    - path: "TradingBot.ApiService/Application/Services/InterestCalculator.cs"
      provides: "Pure static interest calculator"
      contains: "static class InterestCalculator"
    - path: "tests/TradingBot.ApiService.Tests/Application/Services/InterestCalculatorTests.cs"
      provides: "Theory tests covering all 5 compounding modes + edge cases"
      contains: "class InterestCalculatorTests"
  key_links:
    - from: "tests/TradingBot.ApiService.Tests/Application/Services/InterestCalculatorTests.cs"
      to: "TradingBot.ApiService/Application/Services/InterestCalculator.cs"
      via: "Direct static method calls"
      pattern: "InterestCalculator\\.CalculateAccruedValue"
---

<objective>
Implement InterestCalculator as a pure static class using TDD, supporting all 5 compounding frequencies (Simple, Monthly, Quarterly, SemiAnnual, Annual) per PORT-06.

Purpose: Fixed deposit accrued value calculation is critical business logic that must be correct — TDD ensures every formula is verified before shipping.
Output: InterestCalculator.cs (production) + InterestCalculatorTests.cs (tests covering all modes + edge cases).
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/26-portfolio-domain-foundation/26-RESEARCH.md

# Pattern to follow for pure static calculator:
@TradingBot.ApiService/Application/Services/MultiplierCalculator.cs

# Pattern to follow for theory tests:
# (grep for InlineData/Theory patterns in test files)
</context>

<feature>
  <name>InterestCalculator — fixed deposit accrued value</name>
  <files>
    TradingBot.ApiService/Application/Services/InterestCalculator.cs
    tests/TradingBot.ApiService.Tests/Application/Services/InterestCalculatorTests.cs
  </files>
  <behavior>
    `InterestCalculator.CalculateAccruedValue(decimal principal, decimal annualRate, DateOnly startDate, DateOnly asOfDate, CompoundingFrequency frequency)` returns the accrued value as a `decimal`.

    The `CompoundingFrequency` enum is defined in `TradingBot.ApiService.Models.FixedDeposit` (created by Plan 01). If Plan 01 has not run yet, create a local `CompoundingFrequency` enum in InterestCalculator.cs temporarily — but prefer using the one from FixedDeposit.cs if it exists. Since Plan 01 and Plan 02 run in parallel (Wave 1), handle the possibility that the enum may not exist yet: define the enum in the InterestCalculator file if needed, then consolidate later. HOWEVER — the simplest approach is to define `CompoundingFrequency` in its own file or accept that both plans will define it. **Best approach:** Define the enum inline in `InterestCalculator.cs` if `FixedDeposit.cs` doesn't exist yet. The executor should check if `Models/FixedDeposit.cs` exists first and use its enum if available.

    Formulas (t = days elapsed / 365):
    - Simple: `principal * (1 + annualRate * t)`
    - Monthly: `principal * (1 + annualRate / 12) ^ (12 * t)`
    - Quarterly: `principal * (1 + annualRate / 4) ^ (4 * t)`
    - SemiAnnual: `principal * (1 + annualRate / 2) ^ (2 * t)`
    - Annual: `principal * (1 + annualRate) ^ t`

    Edge cases:
    - asOfDate <= startDate: return principal (no interest earned)
    - dayNumber difference used for day count (not TimeSpan)
    - 365-day year convention (Vietnamese banking standard)

    Test cases using [Theory] + [InlineData]:

    1. Simple interest, 10M VND, 6.5%, 180 days:
       t = 180/365 = 0.4932...
       Expected = 10,000,000 * (1 + 0.065 * 180/365) = 10,320,547.945... ≈ 10,320,548 (rounded)

    2. Simple interest, 10M VND, 6.5%, 365 days:
       Expected = 10,000,000 * (1 + 0.065 * 1) = 10,650,000

    3. Monthly compound, 10M VND, 6.5%, 365 days:
       Expected = 10,000,000 * (1 + 0.065/12)^12 ≈ 10,669,719.98...

    4. Quarterly compound, 10M VND, 6.5%, 365 days:
       Expected = 10,000,000 * (1 + 0.065/4)^4 ≈ 10,666,258.16...

    5. SemiAnnual compound, 10M VND, 6.5%, 365 days:
       Expected = 10,000,000 * (1 + 0.065/2)^2 ≈ 10,660,562.50

    6. Annual compound, 10M VND, 6.5%, 365 days:
       Expected = 10,000,000 * (1 + 0.065)^1 = 10,650,000

    7. Edge: asOfDate == startDate → return 10,000,000 (principal)

    8. Edge: asOfDate before startDate → return 10,000,000 (principal)

    Use `Math.Round(result, 2)` for comparison tolerance in tests (or Assert with tolerance). The function returns raw decimal — rounding is caller's concern. Tests should use `.Should().BeApproximately(expected, 1m)` for VND-level precision (whole numbers tolerance).
  </behavior>
  <implementation>
    Create `InterestCalculator.cs` in `Application/Services/`:
    - Namespace: `TradingBot.ApiService.Application.Services`
    - `public static class InterestCalculator`
    - Single method: `public static decimal CalculateAccruedValue(decimal principal, decimal annualRate, DateOnly startDate, DateOnly asOfDate, CompoundingFrequency frequency)`
    - Use `DateOnly.DayNumber` subtraction for days elapsed
    - Use `daysElapsed / 365.0m` for years (decimal division, 365-day convention)
    - Use `Math.Pow` with double casts for compound formulas, cast result back to decimal
    - Pattern match on `CompoundingFrequency` with switch expression

    Create `InterestCalculatorTests.cs` in `tests/TradingBot.ApiService.Tests/Application/Services/`:
    - Follow MultiplierCalculatorTests pattern: xUnit [Theory] + [InlineData] for parameterized tests
    - Use FluentAssertions `.Should().BeApproximately(expected, precision: 1m)` for tolerance
    - Test all 5 compounding modes + 2 edge cases (on/before start date)

    TDD cycle:
    - RED: Write all test cases first, run `dotnet test --filter InterestCalculatorTests` — all fail
    - GREEN: Implement InterestCalculator.CalculateAccruedValue — all pass
    - REFACTOR: Clean up if needed (likely minimal — formulas are straightforward)
  </implementation>
</feature>

<verification>
1. `dotnet test --filter InterestCalculatorTests` — all tests pass
2. At least 8 test cases (5 compounding modes + 2 edge cases + 1 additional scenario)
3. InterestCalculator has no dependencies (pure static, no DI)
4. No new NuGet packages added
</verification>

<success_criteria>
InterestCalculator correctly computes accrued value for all 5 compounding frequencies and handles edge cases (asOfDate on or before start). All tests pass with VND-appropriate precision.
</success_criteria>

<output>
After completion, create `.planning/phases/26-portfolio-domain-foundation/26-02-SUMMARY.md`
</output>
