---
phase: 02-core-dca-engine
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - TradingBot.ApiService/Application/BackgroundJobs/DcaSchedulerBackgroundService.cs
  - TradingBot.ApiService/Program.cs
autonomous: true

must_haves:
  truths:
    - "DcaSchedulerBackgroundService triggers daily at configured DailyBuyHour:DailyBuyMinute UTC"
    - "Scheduler checks every 5 minutes via PeriodicTimer"
    - "Scheduler only executes within a 10-minute window after target time"
    - "If bot starts after today's target time, it waits until tomorrow (no catch-up buys)"
    - "Transient failures retried up to 3 times with exponential backoff and jitter"
    - "Permanent errors (HyperliquidApiException with 4xx status) fail immediately without retry"
    - "All services registered in DI and application starts successfully"
  artifacts:
    - path: "TradingBot.ApiService/Application/BackgroundJobs/DcaSchedulerBackgroundService.cs"
      provides: "Daily DCA trigger with time window, retry, and scoped service resolution"
      min_lines: 60
    - path: "TradingBot.ApiService/Program.cs"
      provides: "DI registration for MediatR, Telegram, DcaExecutionService, scheduler"
      contains: "AddHostedService<DcaSchedulerBackgroundService>"
  key_links:
    - from: "TradingBot.ApiService/Application/BackgroundJobs/DcaSchedulerBackgroundService.cs"
      to: "TradingBot.ApiService/Application/Services/DcaExecutionService.cs"
      via: "IServiceScopeFactory -> resolve IDcaExecutionService"
      pattern: "IDcaExecutionService"
    - from: "TradingBot.ApiService/Application/BackgroundJobs/DcaSchedulerBackgroundService.cs"
      to: "TradingBot.ApiService/BuildingBlocks/TimeBackgroundService.cs"
      via: "extends TimeBackgroundService"
      pattern: "TimeBackgroundService"
    - from: "TradingBot.ApiService/Program.cs"
      to: "TradingBot.ApiService/Infrastructure/Telegram/ServiceCollectionExtensions.cs"
      via: "builder.Services.AddTelegram(builder.Configuration)"
      pattern: "AddTelegram"
    - from: "TradingBot.ApiService/Program.cs"
      to: "TradingBot.ApiService/Application/BackgroundJobs/DcaSchedulerBackgroundService.cs"
      via: "builder.Services.AddHostedService<DcaSchedulerBackgroundService>()"
      pattern: "AddHostedService.*DcaSchedulerBackgroundService"
---

<objective>
Create the DCA scheduler background service that triggers daily purchases at configured time, with retry logic for transient failures, and wire all Phase 2 services into Program.cs DI container.

Purpose: This is the entry point that drives the entire DCA engine. It extends the existing TimeBackgroundService pattern, runs on a 5-minute interval, and delegates to DcaExecutionService when the time window is right. Program.cs wiring makes everything live.

Output: DcaSchedulerBackgroundService with time window logic and retry, plus updated Program.cs with all DI registrations.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-dca-engine/02-CONTEXT.md
@.planning/phases/02-core-dca-engine/02-RESEARCH.md
@.planning/phases/02-core-dca-engine/02-01-SUMMARY.md
@.planning/phases/02-core-dca-engine/02-02-SUMMARY.md
@TradingBot.ApiService/BuildingBlocks/TimeBackgroundService.cs
@TradingBot.ApiService/Program.cs
@TradingBot.ApiService/Configuration/DcaOptions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: DcaSchedulerBackgroundService with time window and retry</name>
  <files>
    TradingBot.ApiService/Application/BackgroundJobs/DcaSchedulerBackgroundService.cs
  </files>
  <action>
    Create DcaSchedulerBackgroundService in `Application/BackgroundJobs/` namespace `TradingBot.ApiService.Application.BackgroundJobs`.

    **Extends TimeBackgroundService** (from BuildingBlocks):

    ```csharp
    public class DcaSchedulerBackgroundService(
        ILogger<DcaSchedulerBackgroundService> logger,
        IServiceScopeFactory scopeFactory,
        IOptionsMonitor<DcaOptions> dcaOptions
    ) : TimeBackgroundService(logger)
    {
        protected override TimeSpan Interval => TimeSpan.FromMinutes(5);
        private const int MaxRetries = 3;
        private static readonly TimeSpan ExecutionWindow = TimeSpan.FromMinutes(10);
    ```

    **ProcessAsync override** — the core logic called every 5 minutes by TimeBackgroundService:

    1. **Check if within execution window:**
       ```csharp
       var now = DateTimeOffset.UtcNow;
       var options = dcaOptions.CurrentValue;
       var targetTime = new TimeOnly(options.DailyBuyHour, options.DailyBuyMinute);
       var todayTarget = new DateTimeOffset(DateOnly.FromDateTime(now.UtcDateTime.Date).ToDateTime(targetTime), TimeSpan.Zero);

       if (now < todayTarget || now >= todayTarget.Add(ExecutionWindow))
       {
           // Not within execution window — skip silently (no log spam every 5 min)
           return;
       }

       logger.LogInformation("DCA execution window reached: {TargetTime} UTC", targetTime);
       ```

    2. **Create scope and resolve services:**
       ```csharp
       await using var scope = scopeFactory.CreateAsyncScope();
       var dcaService = scope.ServiceProvider.GetRequiredService<IDcaExecutionService>();
       var purchaseDate = DateOnly.FromDateTime(now.UtcDateTime.Date);
       ```

    3. **Retry loop with exponential backoff + jitter:**
       ```csharp
       var retryCount = 0;
       while (retryCount <= MaxRetries)
       {
           try
           {
               await dcaService.ExecuteDailyPurchaseAsync(purchaseDate, cancellationToken);
               logger.LogInformation("DCA execution completed for {Date}", purchaseDate);
               return; // Success — exit retry loop
           }
           catch (HyperliquidApiException ex) when (ex.StatusCode.HasValue && ex.StatusCode.Value >= 400 && ex.StatusCode.Value < 500)
           {
               // Permanent error (4xx) — fail immediately, no retry
               logger.LogError(ex, "Permanent error during DCA execution for {Date}, not retrying", purchaseDate);

               // Publish failure event for Telegram notification
               var publisher = scope.ServiceProvider.GetRequiredService<IPublisher>();
               await publisher.Publish(new PurchaseFailedEvent(
                   "PermanentError",
                   ex.Message,
                   retryCount,
                   DateTimeOffset.UtcNow
               ), cancellationToken);
               return;
           }
           catch (Exception ex) when (retryCount < MaxRetries)
           {
               retryCount++;
               // Exponential backoff: 2^retry * 1s + jitter (0-500ms)
               var baseDelay = TimeSpan.FromSeconds(Math.Pow(2, retryCount));
               var jitter = TimeSpan.FromMilliseconds(Random.Shared.Next(0, 500));
               var delay = baseDelay + jitter;

               logger.LogWarning(ex, "DCA execution failed for {Date}, retry {Retry}/{MaxRetries} in {Delay}",
                   purchaseDate, retryCount, MaxRetries, delay);

               await Task.Delay(delay, cancellationToken);
           }
           catch (Exception ex)
           {
               // Final retry exhausted
               logger.LogError(ex, "DCA execution failed for {Date} after {MaxRetries} retries", purchaseDate, MaxRetries);

               var publisher = scope.ServiceProvider.GetRequiredService<IPublisher>();
               await publisher.Publish(new PurchaseFailedEvent(
                   ex.GetType().Name,
                   ex.Message,
                   retryCount,
                   DateTimeOffset.UtcNow
               ), cancellationToken);
               return;
           }
       }
       ```

    **Important details:**
    - Inject `IServiceScopeFactory` (NOT scoped services directly) because BackgroundService is singleton
    - Use `IOptionsMonitor<DcaOptions>` (NOT IOptions) for hot-reload support of buy time config
    - Import `TradingBot.ApiService.Infrastructure.Hyperliquid.Models` for HyperliquidApiException
    - Import `TradingBot.ApiService.Application.Events` for PurchaseFailedEvent
    - Import `TradingBot.ApiService.Application.Services` for IDcaExecutionService
    - The time window check (todayTarget to todayTarget+10min) ensures:
      - Bot doesn't execute before scheduled time
      - Bot doesn't catch up if started late (past the 10-min window = skip)
      - Bot doesn't re-execute in subsequent 5-min ticks (idempotency in DcaExecutionService handles this too, but window prevents unnecessary lock attempts)
    - The 5-minute interval means the bot checks 288 times/day, only executing within the 10-minute window (2 checks max)
    - Use `Random.Shared` for jitter (thread-safe, no need for separate Random instance)
    - The `when` exception filter on HyperliquidApiException distinguishes permanent (4xx) from transient (5xx, network) errors

    Use file-scoped namespace and primary constructor.
  </action>
  <verify>
    `dotnet build TradingBot.ApiService` compiles with zero errors. Verify:
    1. Extends TimeBackgroundService
    2. Interval is 5 minutes
    3. ProcessAsync has time window check with 10-minute window
    4. Retry loop: 3 retries with exponential backoff + jitter
    5. Permanent errors (4xx) fail immediately
    6. IServiceScopeFactory used for scoped service resolution
  </verify>
  <done>
    DcaSchedulerBackgroundService extends TimeBackgroundService, checks 5-min intervals, only executes within 10-min window of configured time, retries transient failures 3x with exponential backoff + jitter, and fails fast on permanent errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire all Phase 2 services into Program.cs</name>
  <files>
    TradingBot.ApiService/Program.cs
  </files>
  <action>
    Update Program.cs to register all Phase 2 services. Add the following AFTER the existing Hyperliquid registration (`builder.Services.AddHyperliquid(builder.Configuration);`) and BEFORE `builder.AddRedisDistributedCache("redis");`:

    1. **Add MediatR registration:**
       ```csharp
       // MediatR for domain events
       builder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));
       ```

    2. **Add Telegram notification infrastructure:**
       ```csharp
       // Telegram notifications
       builder.Services.AddTelegram(builder.Configuration);
       ```
       This calls the ServiceCollectionExtensions.AddTelegram from Plan 01.

    3. **Add DCA execution service:**
       ```csharp
       // DCA execution service (scoped — uses DbContext)
       builder.Services.AddScoped<IDcaExecutionService, DcaExecutionService>();
       ```

    4. **Add DCA scheduler background service:**
       ```csharp
       // DCA scheduler (runs daily at configured time)
       builder.Services.AddHostedService<DcaSchedulerBackgroundService>();
       ```

    **Required using statements** (add at top of Program.cs):
    ```csharp
    using TradingBot.ApiService.Application.BackgroundJobs;
    using TradingBot.ApiService.Application.Services;
    using TradingBot.ApiService.Infrastructure.Telegram;
    ```

    **Ordering matters:** MediatR must be registered before services that use it. Telegram must be registered before handlers. DcaExecutionService must be registered as scoped (uses TradingBotDbContext which is scoped).

    **Important:** Do NOT move or reorder existing registrations. Only ADD new lines in the appropriate location. Read Program.cs first to find exact insertion point.
  </action>
  <verify>
    Run `dotnet build TradingBot.ApiService` — should compile with zero errors. Verify Program.cs contains:
    1. `AddMediatR` call with assembly registration
    2. `AddTelegram` call
    3. `AddScoped<IDcaExecutionService, DcaExecutionService>`
    4. `AddHostedService<DcaSchedulerBackgroundService>`
    5. All required using statements present
    6. Existing registrations not modified
  </verify>
  <done>
    Program.cs registers all Phase 2 services: MediatR, Telegram, DcaExecutionService (scoped), DcaSchedulerBackgroundService (hosted). Application builds and all DI dependencies resolve correctly.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build TradingBot.ApiService` compiles with zero errors
2. DcaSchedulerBackgroundService extends TimeBackgroundService with 5-min interval
3. Time window check uses DcaOptions.DailyBuyHour and DailyBuyMinute
4. Retry: 3 attempts, exponential backoff (2s/4s/8s + jitter), 4xx fail-fast
5. Program.cs has AddMediatR, AddTelegram, AddScoped IDcaExecutionService, AddHostedService DcaSchedulerBackgroundService
6. DcaExecutionService registered as Scoped (not Singleton — uses scoped DbContext)
7. DcaSchedulerBackgroundService uses IServiceScopeFactory to resolve scoped services
</verification>

<success_criteria>
- Build succeeds with zero errors
- Scheduler triggers within 10-min window of configured daily time
- Missed windows are skipped (no catch-up buys)
- Transient failures retried 3x with exponential backoff + jitter
- Permanent errors (4xx) fail immediately with Telegram notification
- All DI registrations in correct order in Program.cs
- Follows codebase conventions: file-scoped namespaces, primary constructors, structured logging
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-dca-engine/02-03-SUMMARY.md`
</output>
