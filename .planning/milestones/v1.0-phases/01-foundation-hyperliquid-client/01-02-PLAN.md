---
phase: 01-foundation-hyperliquid-client
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - TradingBot.ApiService/Infrastructure/Hyperliquid/HyperliquidSigner.cs
  - TradingBot.ApiService/Infrastructure/Hyperliquid/HyperliquidClient.cs
  - TradingBot.ApiService/Infrastructure/Hyperliquid/Models/HyperliquidModels.cs
  - TradingBot.ApiService/Infrastructure/Hyperliquid/ServiceCollectionExtensions.cs
  - TradingBot.ApiService/TradingBot.ApiService.csproj
  - TradingBot.ApiService/Program.cs
autonomous: false

user_setup:
  - service: hyperliquid-testnet
    why: "EIP-712 signing requires an Ethereum private key for testnet authentication"
    env_vars:
      - name: Hyperliquid__PrivateKey
        source: "Generate or use an existing Ethereum wallet private key. Store via: dotnet user-secrets set 'Hyperliquid:PrivateKey' '0xYOUR_PRIVATE_KEY' --project TradingBot.ApiService"
    dashboard_config:
      - task: "Fund testnet wallet with USDC"
        location: "Hyperliquid testnet interface or Discord faucet"

must_haves:
  truths:
    - "HyperliquidClient authenticates with Hyperliquid testnet using EIP-712 signatures"
    - "HyperliquidClient fetches current BTC spot price from testnet"
    - "HyperliquidClient queries USDC balance for the configured wallet"
    - "HyperliquidClient places a spot buy order on testnet"
    - "Private key is loaded from user secrets, never logged"
    - "HTTP retries are disabled for POST order placement requests"
  artifacts:
    - path: "TradingBot.ApiService/Infrastructure/Hyperliquid/HyperliquidSigner.cs"
      provides: "EIP-712 typed data signing for Hyperliquid API authentication"
      contains: "class HyperliquidSigner"
    - path: "TradingBot.ApiService/Infrastructure/Hyperliquid/HyperliquidClient.cs"
      provides: "HTTP client for Hyperliquid REST API (prices, balances, orders)"
      contains: "class HyperliquidClient"
    - path: "TradingBot.ApiService/Infrastructure/Hyperliquid/Models/HyperliquidModels.cs"
      provides: "Request/response DTOs for Hyperliquid API"
      contains: "SpotMetaResponse|OrderResponse|UserBalance"
  key_links:
    - from: "HyperliquidClient"
      to: "HyperliquidSigner"
      via: "constructor injection, signs orders before POST to /exchange"
      pattern: "_signer.Sign"
    - from: "HyperliquidClient"
      to: "HyperliquidOptions"
      via: "IOptions for API URL and testnet toggle"
      pattern: "IOptions<HyperliquidOptions>"
    - from: "Program.cs"
      to: "HyperliquidClient"
      via: "HttpClientFactory with resilience handler"
      pattern: "AddHttpClient<HyperliquidClient>"
    - from: "HyperliquidSigner"
      to: "Nethereum.Signer.EIP712"
      via: "Eip712TypedDataSigner.SignTypedDataV4"
      pattern: "SignTypedDataV4|EthECKey"
---

<objective>
Build the Hyperliquid API client with EIP-712 authentication. This is the highest-risk component in Phase 1 - EIP-712 signing requires exact message structure matching Hyperliquid's expectations. The client must fetch spot prices, query balances, and place spot buy orders on testnet.

Purpose: The entire DCA bot depends on reliable communication with Hyperliquid. EIP-712 signing is the hardest part and the most likely to fail - getting it working against testnet proves the integration is viable.

Output: Working HyperliquidClient registered via HttpClientFactory with EIP-712 signing, tested against Hyperliquid testnet.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-hyperliquid-client/01-CONTEXT.md
@.planning/phases/01-foundation-hyperliquid-client/01-RESEARCH.md
@.planning/phases/01-foundation-hyperliquid-client/01-01-SUMMARY.md

Hyperliquid Python SDK for EIP-712 reference:
https://github.com/hyperliquid-dex/hyperliquid-python-sdk

Key Hyperliquid API docs:
- Exchange endpoint: https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint
- Info endpoint (spot): https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot
- Signing: https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/signing
</context>

<tasks>

<task type="auto">
  <name>Task 1: EIP-712 signer and Hyperliquid HTTP client</name>
  <files>
    TradingBot.ApiService/Infrastructure/Hyperliquid/HyperliquidSigner.cs
    TradingBot.ApiService/Infrastructure/Hyperliquid/HyperliquidClient.cs
    TradingBot.ApiService/Infrastructure/Hyperliquid/Models/HyperliquidModels.cs
    TradingBot.ApiService/Infrastructure/Hyperliquid/ServiceCollectionExtensions.cs
    TradingBot.ApiService/TradingBot.ApiService.csproj
    TradingBot.ApiService/Program.cs
  </files>
  <action>
    **CRITICAL FIRST STEP:** Before writing any code, analyze the Hyperliquid Python SDK signing implementation to understand the exact EIP-712 message structure. Read:
    - `hyperliquid/utils/signing.py` from the Python SDK (fetch from GitHub)
    - Focus on: domain separator values, type definitions, field ordering, how orders are encoded
    - Document the exact TypedData structure you'll implement

    **Add NuGet packages** to csproj:
    - `Nethereum.Signer.EIP712` (5.8.0+)
    - `Microsoft.Extensions.Http.Resilience` (latest)

    **HyperliquidModels.cs** (`TradingBot.ApiService/Infrastructure/Hyperliquid/Models/`):
    Create all API request/response DTOs:
    - `SpotMetaResponse` - response from `{"type": "spotMeta"}` info endpoint
    - `SpotMetaAndAssetCtxsResponse` - response from `{"type": "spotMetaAndAssetCtxs"}` with price data
    - `UserBalanceResponse` - response from `{"type": "spotClearinghouseState", "user": "0x..."}`
    - `OrderRequest` - the order action structure for `/exchange` endpoint
    - `OrderResponse` - response from order placement (contains `status`, `response` with `data.statuses`)
    - `OrderStatusResponse` - response from `{"type": "orderStatus", "user": "0x...", "oid": N}`
    - Use `System.Text.Json` attributes (`[JsonPropertyName]`) for correct JSON serialization
    - All numeric strings in API responses should deserialize to `string` first, then parse to decimal in client methods (Hyperliquid returns numbers as strings)

    **HyperliquidSigner.cs** (`TradingBot.ApiService/Infrastructure/Hyperliquid/`):
    - Constructor takes private key string, creates `EthECKey`
    - `GetAddress()` - returns lowercase wallet address derived from the key
    - `SignOrderAction(orderAction, nonce, isTestnet)` - signs an order action using EIP-712
    - `SignWithdrawAction(...)` - placeholder for future (not needed now)
    - Internal helpers:
      - `BuildOrderTypedData(action, nonce, isTestnet)` - constructs the `TypedData` object with exact structure from Python SDK analysis
      - Domain separator: name="Exchange", version="1", chainId depends on testnet/mainnet
        - IMPORTANT: Analyze Python SDK to get the EXACT chainId values (Arbitrum: 42161 mainnet, 421614 testnet - but verify)
        - verifyingContract: "0x0000000000000000000000000000000000000000" (verify with Python SDK)
      - Field ordering MUST match Python SDK exactly (different order = different hash = invalid signature)
    - CRITICAL: Always lowercase addresses before including in signatures
    - CRITICAL: Never log the private key or the EthECKey. The constructor should validate the key format and throw a clear error if invalid, without including the key in the error message.
    - Log the derived wallet address on construction (this is public info) to help debugging

    **HyperliquidClient.cs** (`TradingBot.ApiService/Infrastructure/Hyperliquid/`):
    - Inject: `HttpClient` (from HttpClientFactory), `HyperliquidSigner`, `IOptions<HyperliquidOptions>`, `ILogger<HyperliquidClient>`
    - Methods:
      - `GetSpotMetadataAsync(ct)` - POST to `/info` with `{"type": "spotMeta"}`, returns spot metadata including token list
      - `GetSpotPriceAsync(string symbol, ct)` - POST to `/info` with `{"type": "spotMetaAndAssetCtxs"}`, finds BTC/USDC pair, returns current mark price as decimal
      - `GetBalancesAsync(ct)` - POST to `/info` with `{"type": "spotClearinghouseState", "user": "WALLET_ADDRESS"}`, returns USDC balance
      - `PlaceSpotOrderAsync(int assetIndex, bool isBuy, decimal size, decimal price, ct)` - Constructs order with asset = 10000 + assetIndex (spot prefix), signs with EIP-712, POSTs to `/exchange`
      - `GetOrderStatusAsync(string oid, ct)` - POST to `/info` to check order status
    - For `PlaceSpotOrderAsync`:
      - Order TIF (time in force): Use IOC (Immediate Or Cancel) for market-like orders (research says "Ioc" not "Gtc" for market buys)
      - Set `r` (reduce-only) to false for spot buys
      - Set `grouping` to "na" for single orders
      - Nonce: `DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()`
      - Log order details (asset, side, size, price) but NEVER log signature or private key
      - Parse response to detect errors vs success. Hyperliquid returns 200 even for some errors - check the response body for error messages.
    - All API errors should throw `HyperliquidApiException` (custom exception class) with the error message and HTTP status code

    **ServiceCollectionExtensions.cs** (`TradingBot.ApiService/Infrastructure/Hyperliquid/`):
    - Extension method `AddHyperliquid(this IServiceCollection services, IConfiguration configuration)`:
      - Register `HyperliquidSigner` as singleton (private key doesn't change)
        - Read private key from `configuration["Hyperliquid:PrivateKey"]`
        - Throw clear error at startup if private key is missing/empty
      - Register `HyperliquidClient` via `AddHttpClient<HyperliquidClient>`:
        - Set `BaseAddress` from `HyperliquidOptions.ApiUrl`
        - Set `Timeout` to 30 seconds
        - Add `Content-Type: application/json` default header
        - Add `AddStandardResilienceHandler` with:
          - `options.Retry.DisableForUnsafeHttpMethods()` (CRITICAL: prevents duplicate orders)
          - Reasonable circuit breaker settings
      - Register options: `services.Configure<HyperliquidOptions>(configuration.GetSection("Hyperliquid"))`

    **Program.cs** - Add after configuration setup from Plan 01:
    ```csharp
    builder.Services.AddHyperliquid(builder.Configuration);
    ```
  </action>
  <verify>
    `dotnet build TradingBot.ApiService` compiles without errors. All files exist. Verify that `Nethereum.Signer.EIP712` and `Microsoft.Extensions.Http.Resilience` are in the csproj.
  </verify>
  <done>
    HyperliquidSigner signs EIP-712 messages matching the Python SDK's expected structure. HyperliquidClient can make authenticated requests to Hyperliquid API. HttpClientFactory configured with resilience (retries disabled for POST). Private key loaded securely from user secrets.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Hyperliquid API client with EIP-712 signing, registered via HttpClientFactory. The client can:
    1. Fetch BTC spot price from Hyperliquid testnet
    2. Query USDC wallet balance
    3. Place spot buy orders with EIP-712 authentication

    Configuration, domain models, persistence, and distributed locking from Plan 01 are also wired in.
  </what-built>
  <how-to-verify>
    1. Set up private key in user secrets:
       ```bash
       cd TradingBot.ApiService
       dotnet user-secrets set "Hyperliquid:PrivateKey" "0xYOUR_TESTNET_PRIVATE_KEY"
       dotnet user-secrets set "Hyperliquid:WalletAddress" "0xYOUR_WALLET_ADDRESS"
       ```

    2. Start the application via Aspire:
       ```bash
       dotnet run --project TradingBot.AppHost
       ```

    3. Verify startup:
       - No configuration validation errors
       - Wallet address logged (NOT private key)
       - Database migration applies cleanly
       - Health check responds: `curl http://localhost:{port}/health`

    4. Test API calls (if a test endpoint was added, or use the Aspire dashboard to inspect):
       - Check Aspire dashboard for any HTTP errors to Hyperliquid
       - Verify logs show successful API communication

    5. Security check:
       - Search all log output for "0x" patterns longer than 10 chars - only wallet address should appear, not private key
       - Verify `appsettings.json` does NOT contain any private key value

    Note: Full order placement testing requires a funded testnet wallet. If the wallet is unfunded, verify that price fetch and balance query work, and that order placement returns a clear "insufficient balance" error rather than a signing error.
  </how-to-verify>
  <resume-signal>Type "approved" if the client works against testnet, or describe any signing/API issues encountered</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. **EIP-712 Signing:** HyperliquidSigner produces valid signatures accepted by Hyperliquid testnet (no "user does not exist" or signature errors)
2. **Price Fetch:** `GetSpotPriceAsync("BTC")` returns a non-zero decimal from testnet
3. **Balance Query:** `GetBalancesAsync()` returns the wallet's USDC balance (may be 0 if unfunded)
4. **Order Placement:** `PlaceSpotOrderAsync(...)` either succeeds (if funded) or returns a clear business error (insufficient balance), NOT a signing error
5. **Resilience:** POST requests to /exchange are NOT retried (verify via resilience handler config)
6. **Security:** Private key never appears in any log output, config dump, or error message
7. **Build:** Entire solution builds cleanly
</verification>

<success_criteria>
- HyperliquidSigner signs EIP-712 typed data matching Hyperliquid's expected format
- HyperliquidClient fetches BTC spot price from testnet
- HyperliquidClient queries wallet USDC balance from testnet
- HyperliquidClient places spot buy order (or gets clear business error, not signing error)
- HttpClient configured with resilience handler, POST retries disabled
- Private key securely loaded from user secrets, never logged
- Human verifies testnet integration works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-hyperliquid-client/01-02-SUMMARY.md`
</output>
