---
phase: 01-foundation-hyperliquid-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TradingBot.ApiService/Configuration/DcaOptions.cs
  - TradingBot.ApiService/Configuration/HyperliquidOptions.cs
  - TradingBot.ApiService/Models/Purchase.cs
  - TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
  - TradingBot.ApiService/Infrastructure/Data/Migrations/*.cs
  - TradingBot.ApiService/Infrastructure/Locking/PostgresDistributedLock.cs
  - TradingBot.ApiService/Infrastructure/Locking/ServiceCollectionExtensions.cs
  - TradingBot.ApiService/TradingBot.ApiService.csproj
  - TradingBot.ApiService/appsettings.json
  - TradingBot.ApiService/Program.cs
  - TradingBot.AppHost/AppHost.cs
autonomous: true

must_haves:
  truths:
    - "App starts with DCA configuration loaded and validated from appsettings.json"
    - "EF Core migrations apply on startup, creating Purchase table in PostgreSQL"
    - "Distributed lock acquires a real PostgreSQL advisory lock (not the existing stub)"
    - "Configuration changes in appsettings.json are picked up via IOptionsMonitor without restart"
  artifacts:
    - path: "TradingBot.ApiService/Configuration/DcaOptions.cs"
      provides: "DCA strategy configuration (base amount, schedule, multiplier tiers, bear boost)"
      contains: "class DcaOptions"
    - path: "TradingBot.ApiService/Configuration/HyperliquidOptions.cs"
      provides: "Hyperliquid API configuration (URL, testnet toggle)"
      contains: "class HyperliquidOptions"
    - path: "TradingBot.ApiService/Models/Purchase.cs"
      provides: "Purchase domain entity with all required fields"
      contains: "class Purchase"
    - path: "TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs"
      provides: "EF Core DbContext with Purchase entity configuration"
      contains: "class TradingBotDbContext"
    - path: "TradingBot.ApiService/Infrastructure/Locking/PostgresDistributedLock.cs"
      provides: "PostgreSQL advisory lock implementation replacing Dapr stub"
      contains: "class PostgresDistributedLock"
  key_links:
    - from: "TradingBot.ApiService/Program.cs"
      to: "DcaOptions"
      via: "IOptionsMonitor configuration binding"
      pattern: "Configure<DcaOptions>"
    - from: "TradingBot.ApiService/Program.cs"
      to: "TradingBotDbContext"
      via: "Aspire EF Core registration + auto-migrate"
      pattern: "AddNpgsqlDbContext<TradingBotDbContext>|MigrateAsync"
    - from: "TradingBot.ApiService/Infrastructure/Locking/PostgresDistributedLock.cs"
      to: "PostgreSQL"
      via: "DistributedLock.Postgres advisory locks"
      pattern: "PostgresDistributedSynchronizationProvider"
---

<objective>
Set up the internal foundation for the BTC Smart DCA Bot: configuration system with hot reload, domain models with EF Core persistence, and real distributed locking via PostgreSQL advisory locks.

Purpose: Everything in Phase 1 (and downstream phases) depends on configuration, persistence, and safe locking. This plan delivers all internal infrastructure before the external Hyperliquid integration.

Output: Configuration options classes bound to appsettings.json, Purchase entity persisted to PostgreSQL via EF Core with auto-migration, and a working PostgreSQL advisory lock replacing the existing Dapr stub.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-hyperliquid-client/01-CONTEXT.md
@.planning/phases/01-foundation-hyperliquid-client/01-RESEARCH.md

Key existing files to understand:
@TradingBot.ApiService/Program.cs
@TradingBot.ApiService/appsettings.json
@TradingBot.ApiService/TradingBot.ApiService.csproj
@TradingBot.ApiService/BuildingBlocks/BaseEntity.cs
@TradingBot.ApiService/BuildingBlocks/AuditedEntity.cs
@TradingBot.ApiService/BuildingBlocks/DistributedLocks/DistributedLock.cs
@TradingBot.ApiService/BuildingBlocks/DistributedLocks/ServiceCollectionExtensions.cs
@TradingBot.AppHost/AppHost.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configuration options classes and domain model</name>
  <files>
    TradingBot.ApiService/Configuration/DcaOptions.cs
    TradingBot.ApiService/Configuration/HyperliquidOptions.cs
    TradingBot.ApiService/Models/Purchase.cs
  </files>
  <action>
    Create configuration options and domain entity classes.

    **DcaOptions.cs** (`TradingBot.ApiService/Configuration/`):
    - `BaseDailyAmount` (decimal) - daily USD buy amount
    - `DailyBuyHour` (int) - UTC hour for daily buy
    - `DailyBuyMinute` (int) - UTC minute for daily buy
    - `HighLookbackDays` (int, default 30) - days for rolling high calculation
    - `BearMarketMaPeriod` (int, default 200) - MA period for bear market detection
    - `BearBoostFactor` (decimal, default 1.5m) - multiplier when in bear market
    - `DryRun` (bool, default false) - dry run mode toggle
    - `MultiplierTiers` - list/dictionary of drop percentage thresholds to multiplier values. Use a `List<MultiplierTier>` where `MultiplierTier` has `DropPercentage` (decimal) and `Multiplier` (decimal). Example tiers: 5%->1.5x, 10%->2x, 20%->3x. Default tier (0% drop) = 1x is implicit.
    - Add a `Validate()` method using `IValidateOptions<DcaOptions>` pattern to check: BaseDailyAmount > 0, DailyBuyHour 0-23, DailyBuyMinute 0-59, MultiplierTiers sorted by DropPercentage ascending, all multipliers > 0

    **HyperliquidOptions.cs** (`TradingBot.ApiService/Configuration/`):
    - `IsTestnet` (bool, default true) - testnet/mainnet toggle
    - `ApiUrl` (string) - computed property: returns testnet URL if IsTestnet, mainnet URL otherwise
      - Testnet: `https://api.hyperliquid-testnet.xyz`
      - Mainnet: `https://api.hyperliquid.xyz`
    - `WalletAddress` (string) - public wallet address (not sensitive, can log)
    - Do NOT put private key here. Private key goes in user secrets / env vars only, injected separately.
    - Override `ToString()` to show only non-sensitive fields

    **Purchase.cs** (`TradingBot.ApiService/Models/`):
    - Inherit from `BaseEntity` (gets `Id` as UUIDv7 and `CreatedAt`/`UpdatedAt`)
    - Properties: `ExecutedAt` (DateTimeOffset), `Price` (decimal), `Quantity` (decimal), `Cost` (decimal), `Multiplier` (decimal), `Status` (string: "Pending", "Filled", "PartiallyFilled", "Failed", "Cancelled"), `OrderId` (string?), `RawResponse` (string? - full API response JSON for debugging), `FailureReason` (string?)
    - Consider making Status an enum `PurchaseStatus` instead of string for type safety

    Follow existing conventions: file-scoped namespaces, primary constructors where appropriate, nullable enabled. Namespace pattern: `TradingBot.ApiService.Configuration`, `TradingBot.ApiService.Models`.
  </action>
  <verify>
    `dotnet build TradingBot.ApiService` compiles without errors. All three files exist in their respective directories.
  </verify>
  <done>
    DcaOptions has all DCA parameters with validation. HyperliquidOptions has testnet/mainnet URL logic. Purchase entity inherits BaseEntity with all required fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: EF Core DbContext, migration, and PostgreSQL distributed lock</name>
  <files>
    TradingBot.ApiService/Infrastructure/Data/TradingBotDbContext.cs
    TradingBot.ApiService/Infrastructure/Data/Migrations/*.cs
    TradingBot.ApiService/Infrastructure/Locking/PostgresDistributedLock.cs
    TradingBot.ApiService/Infrastructure/Locking/ServiceCollectionExtensions.cs
    TradingBot.ApiService/TradingBot.ApiService.csproj
  </files>
  <action>
    **TradingBotDbContext.cs** (`TradingBot.ApiService/Infrastructure/Data/`):
    - Inherit from `DbContext`
    - `DbSet<Purchase> Purchases => Set<Purchase>();`
    - In `OnModelCreating`:
      - Purchase: `HasKey(e => e.Id)`, `Property(e => e.Price).HasPrecision(18, 8)`, `Property(e => e.Quantity).HasPrecision(18, 8)`, `Property(e => e.Cost).HasPrecision(18, 2)`, `Property(e => e.Multiplier).HasPrecision(4, 2)`, `HasIndex(e => e.ExecutedAt)`, `Property(e => e.Status).HasMaxLength(20)`, `Property(e => e.OrderId).HasMaxLength(100)`, `Property(e => e.FailureReason).HasMaxLength(500)`
      - Store `RawResponse` as text (no max length)
    - Namespace: `TradingBot.ApiService.Infrastructure.Data`

    **Add NuGet package** to csproj:
    - `DistributedLock.Postgres` (latest stable, 1.x or 2.x)
    - Remove `Dapr.DistributedLock` package reference from csproj (no longer needed)

    **Create EF Core migration:**
    - Run: `dotnet ef migrations add InitialCreate --project TradingBot.ApiService --startup-project TradingBot.ApiService --output-dir Infrastructure/Data/Migrations`
    - Note: This may need a temporary connection string in appsettings for design-time. If EF tools complain about missing connection string, add `IDesignTimeDbContextFactory<TradingBotDbContext>` in a file `TradingBot.ApiService/Infrastructure/Data/DesignTimeDbContextFactory.cs` that uses a hardcoded dev connection string for migration generation only.

    **PostgresDistributedLock.cs** (`TradingBot.ApiService/Infrastructure/Locking/`):
    - Keep the existing `IDistributedLock` interface signature (in `BuildingBlocks/DistributedLocks/DistributedLock.cs`), but change the interface to NOT depend on Dapr types. Update `IDistributedLock` to return a simple `IAsyncDisposable` result with a `Success` property (keep existing `LockResponse` shape but remove Dapr dependency).
    - Create `PostgresDistributedLock` implementing `IDistributedLock` using `Medallion.Threading.Postgres.PostgresDistributedSynchronizationProvider`
    - Constructor takes connection string (injected via `IConfiguration` or `TradingBotDbContext.Database.GetConnectionString()`)
    - `AcquireLockAsync` calls `provider.TryAcquireLockAsync(key, timeout: ttl, cancellationToken)` and wraps result in `LockResponse`
    - When lock handle is non-null, `LockResponse.Success` = true and `DisposeAsync` releases the lock
    - When lock handle is null, `LockResponse.Success` = false

    **Update ServiceCollectionExtensions** (`TradingBot.ApiService/Infrastructure/Locking/`):
    - Create a new `ServiceCollectionExtensions.cs` in `Infrastructure/Locking/` that registers `PostgresDistributedLock` as `IDistributedLock`
    - The old `BuildingBlocks/DistributedLocks/ServiceCollectionExtensions.cs` should be updated to no longer register the Dapr lock. Either: move the interface to a shared location and delete the old DI registration, OR keep the interface in BuildingBlocks and replace only the implementation registration.
    - Preferred approach: Keep `IDistributedLock` and `LockResponse` in `BuildingBlocks/DistributedLocks/` (they're abstractions), delete `DaprDistributedLock` class, create `PostgresDistributedLock` in `Infrastructure/Locking/`, update the existing `ServiceCollectionExtensions` in `BuildingBlocks/DistributedLocks/` to register the Postgres implementation instead.
  </action>
  <verify>
    `dotnet build TradingBot.ApiService` compiles. Migration files exist in `Infrastructure/Data/Migrations/`. Run `dotnet ef migrations list --project TradingBot.ApiService --startup-project TradingBot.ApiService` to confirm migration is recognized.
  </verify>
  <done>
    TradingBotDbContext configured with Purchase entity and precision settings. EF Core migration generated. PostgresDistributedLock replaces DaprDistributedLock with real advisory locking. Dapr.DistributedLock package removed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire everything into Program.cs and AppHost</name>
  <files>
    TradingBot.ApiService/Program.cs
    TradingBot.ApiService/appsettings.json
    TradingBot.AppHost/AppHost.cs
  </files>
  <action>
    **appsettings.json** - Add DCA and Hyperliquid configuration sections:
    ```json
    {
      "DcaOptions": {
        "BaseDailyAmount": 10.0,
        "DailyBuyHour": 14,
        "DailyBuyMinute": 0,
        "HighLookbackDays": 30,
        "BearMarketMaPeriod": 200,
        "BearBoostFactor": 1.5,
        "DryRun": true,
        "MultiplierTiers": [
          { "DropPercentage": 5, "Multiplier": 1.5 },
          { "DropPercentage": 10, "Multiplier": 2.0 },
          { "DropPercentage": 20, "Multiplier": 3.0 }
        ]
      },
      "Hyperliquid": {
        "IsTestnet": true,
        "WalletAddress": ""
      }
    }
    ```
    Merge these into the existing appsettings.json (keep existing Serilog config).

    **Program.cs** - Add after `builder.AddServiceDefaults()`:
    1. Configuration binding with validation:
       ```csharp
       builder.Services.Configure<DcaOptions>(builder.Configuration.GetSection("DcaOptions"));
       builder.Services.Configure<HyperliquidOptions>(builder.Configuration.GetSection("Hyperliquid"));
       ```
       Register the IValidateOptions implementation for DcaOptions so validation runs at startup.
    2. EF Core DbContext via Aspire:
       ```csharp
       builder.AddNpgsqlDbContext<TradingBotDbContext>("tradingbotdb");
       ```
    3. After `var app = builder.Build();`, before `app.UseSerilogRequestLogging();`:
       ```csharp
       using (var scope = app.Services.CreateScope())
       {
           var dbContext = scope.ServiceProvider.GetRequiredService<TradingBotDbContext>();
           await dbContext.Database.MigrateAsync();
       }
       ```
    4. Update distributed lock registration: Replace `builder.Services.AddDistributedLock();` with the new PostgreSQL-based registration that takes the connection string from the Aspire-managed PostgreSQL.
    5. Remove the `using Dapr.DistributedLock;` and related Dapr lock imports if no longer needed.
    6. Remove `builder.AddRedisDistributedCache("redis");` ONLY if Redis is no longer needed for anything (check: it may still be used by Dapr pubsub). Actually, keep Redis for now - it's used by the pub-sub outbox. Just remove the Dapr distributed lock dependency.

    **AppHost.cs** - Ensure `postgresdb` reference is already passed to apiservice (it is). No changes needed if the existing setup already passes the database reference. Verify that the Aspire resource name "tradingbotdb" matches between AppHost and ApiService.

    Important: The `using` for the old DistributedLocks namespace may change. Update imports accordingly. Keep the code clean - remove any dead Dapr lock references.
  </action>
  <verify>
    1. `dotnet build` the entire solution succeeds.
    2. Start the Aspire AppHost: `dotnet run --project TradingBot.AppHost` and verify:
       - Application starts without configuration validation errors
       - PostgreSQL connection succeeds
       - Migration runs (check logs for "Applying migration" messages)
       - Health endpoint responds: `curl http://localhost:{port}/health`
    3. Verify no private key values appear in startup logs.
  </verify>
  <done>
    Application boots with validated DCA configuration from appsettings.json. EF Core auto-migrates Purchase table on startup. Distributed lock uses PostgreSQL advisory locks. Health check endpoint responds. No dead Dapr lock code remains.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Configuration:** Modify `DcaOptions.BaseDailyAmount` to an invalid value (e.g., -1) in appsettings.json and restart - app should fail with a clear validation error message.
2. **Persistence:** Connect to PostgreSQL via PgAdmin (localhost:5050) and verify `Purchases` table exists with correct columns and precision.
3. **Distributed Lock:** The old `DaprDistributedLock` class no longer exists. `IDistributedLock` resolves to `PostgresDistributedLock` in the DI container.
4. **Build:** `dotnet build` succeeds for entire solution with zero warnings related to our changes.
5. **No secrets in logs:** Review startup log output - no hex private key patterns (0x...) should appear.
</verification>

<success_criteria>
- DcaOptions and HyperliquidOptions bound from appsettings.json with IOptionsMonitor (hot reload capable)
- DcaOptions validated at startup with clear error messages for invalid values
- Purchase entity persisted in PostgreSQL with correct decimal precision
- EF Core migration auto-applies on startup
- PostgreSQL advisory locks replace the Dapr distributed lock stub
- Solution builds cleanly
- App starts and health check responds at /health
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-hyperliquid-client/01-01-SUMMARY.md`
</output>
